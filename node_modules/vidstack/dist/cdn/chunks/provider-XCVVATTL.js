import { VideoProvider } from './chunk-3ICYFQVF.js';
import { createRAFLoop } from './chunk-ZG5YNSDW.js';
import { preconnect, loadScript, HLS_LISTENERS, coerceToError } from './chunk-6ITALQHG.js';
import { isHLSSupported } from './chunk-WBYYK3WU.js';
import './chunk-YQW4DAXB.js';
import { dispatchEvent, DOMEvent, kebabToCamelCase, camelToKebabCase } from './chunk-5CN37FD6.js';
import { signal, isString, effect2, peek, isUndefined, isFunction2 } from './chunk-DVGRTHY2.js';

// src/player/media/providers/hls/lib-loader.ts
async function loadHLSLibrary(lib, { player, delegate, logger }) {
  {
    logger?.info("\u{1F3D7}\uFE0F Loading HLS Library");
  }
  const callbacks = {
    onLoadStart() {
      {
        logger?.infoGroup("Starting to load `hls.js`").labelledLog("URL", lib).dispatch();
      }
      dispatchEvent(player, "hls-lib-load-start");
    },
    onLoaded(ctor2) {
      {
        logger?.infoGroup("Loaded `hls.js`").labelledLog("Library", lib).labelledLog("Constructor", ctor2).dispatch();
      }
      dispatchEvent(player, "hls-lib-loaded", { detail: ctor2 });
    },
    onLoadError(e) {
      const error = coerceToError(e);
      {
        logger?.errorGroup("Failed to load `hls.js`").labelledLog("Library", lib).labelledLog("Error", e).dispatch();
      }
      dispatchEvent(player, "hls-lib-load-error", { detail: error });
      delegate.dispatch("error", { detail: { message: error.message, code: 4 } });
    }
  };
  let ctor = await loadHLSScript(lib, callbacks);
  if (isUndefined(ctor) && !isString(lib))
    ctor = await importHLS(lib, callbacks);
  if (!ctor)
    return null;
  if (!ctor.isSupported()) {
    const message = "[vidstack]: `hls.js` is not supported in this environment";
    logger?.error(message);
    dispatchEvent(player, "hls-unsupported");
    delegate.dispatch("error", { detail: { message, code: 4 } });
    return null;
  }
  return ctor;
}
async function importHLS(loader, callbacks = {}) {
  if (isUndefined(loader))
    return void 0;
  callbacks.onLoadStart?.();
  if (loader.prototype && loader.prototype !== Function) {
    callbacks.onLoaded?.(loader);
    return loader;
  }
  try {
    const ctor = (await loader())?.default;
    if (ctor && !!ctor.isSupported) {
      callbacks.onLoaded?.(ctor);
    } else {
      throw Error(
        true ? "[vidstack] failed importing `hls.js`. Dynamic import returned invalid constructor." : ""
      );
    }
    return ctor;
  } catch (err) {
    callbacks.onLoadError?.(err);
  }
  return void 0;
}
async function loadHLSScript(src, callbacks = {}) {
  if (!isString(src))
    return void 0;
  callbacks.onLoadStart?.();
  try {
    await loadScript(src);
    if (!isFunction2(window.Hls)) {
      throw Error(
        true ? "[vidstack] failed loading `hls.js`. Could not find a valid `Hls` constructor on window" : ""
      );
    }
    const ctor = window.Hls;
    callbacks.onLoaded?.(ctor);
    return ctor;
  } catch (err) {
    callbacks.onLoadError?.(err);
  }
  return void 0;
}

// src/player/media/providers/hls/use-hls.ts
var toDOMEventType = (type) => camelToKebabCase(type);
var toHLSEventType = (type) => kebabToCamelCase(type);
function useHLS(provider, config, $ctor, $instance, { player, logger, delegate, $store }, callbacks) {
  const listening = /* @__PURE__ */ new Set();
  effect2(() => {
    const ctor = $ctor();
    if (!ctor)
      return;
    const isLowLatencyStream = peek(() => $store.streamType).includes("ll-");
    const instance = new ctor({
      lowLatencyMode: isLowLatencyStream,
      ...config
    });
    effect2(() => void attachEventListeners(instance, player[HLS_LISTENERS]()));
    instance.on(ctor.Events.ERROR, onError);
    $instance.set(instance);
    for (const callback of callbacks)
      callback(instance);
    dispatchEvent(player, "hls-instance", { detail: instance });
    instance.attachMedia(provider.media);
    const levelLoadedEvent = peek($ctor).Events.LEVEL_LOADED;
    instance.on(levelLoadedEvent, onLevelLoaded);
    delegate.dispatch("provider-setup", { detail: provider });
    return () => {
      listening.clear();
      instance.destroy();
      $instance.set(null);
      logger?.info("\u{1F3D7}\uFE0F Destroyed HLS instance");
    };
  });
  effect2(() => {
    if (!$store.live)
      return;
    const instance = $instance();
    if (!instance)
      return;
    const rafLoop = createRAFLoop(() => {
      $store.liveSyncPosition = instance.liveSyncPosition ?? Infinity;
    });
    rafLoop.start();
    return rafLoop.stop;
  });
  function dispatchHLSEvent(eventType, detail) {
    player.dispatchEvent(new DOMEvent(toDOMEventType(eventType), { detail }));
  }
  function attachEventListeners(instance, listeners) {
    for (const type of listeners) {
      if (!listening.has(type)) {
        instance.on(toHLSEventType(type), dispatchHLSEvent);
        listening.add(type);
      }
    }
  }
  function onLevelLoaded(eventType, data) {
    if ($store.canPlay)
      return;
    const { type, live, totalduration: duration } = data.details;
    const event = new DOMEvent(eventType, { detail: data });
    delegate.dispatch("stream-type-change", {
      detail: live ? type === "EVENT" && Number.isFinite(duration) ? "live:dvr" : "live" : "on-demand",
      trigger: event
    });
    delegate.dispatch("duration-change", { detail: duration, trigger: event });
    const instance = $instance();
    const media = instance.media;
    media.dispatchEvent(new DOMEvent("canplay", { trigger: event }));
  }
  function onError(eventType, data) {
    {
      logger?.errorGroup(`HLS error \`${eventType}\``).labelledLog("Media Element", $instance()?.media).labelledLog("HLS Instance", $instance()).labelledLog("Event Type", eventType).labelledLog("Data", data).labelledLog("Src", $store.source).labelledLog("Media Store", { ...$store }).dispatch();
    }
    if (data.fatal) {
      switch (data.type) {
        case "networkError":
          $instance()?.startLoad();
          break;
        case "mediaError":
          $instance()?.recoverMediaError();
          break;
        default:
          $instance()?.destroy();
          $instance.set(null);
          break;
      }
    }
  }
}

// src/player/media/providers/hls/provider.ts
var HLS_PROVIDER = Symbol("HLS_PROVIDER" );
var JS_DELIVR_CDN = "https://cdn.jsdelivr.net";
var _a;
var HLSProvider = class extends VideoProvider {
  constructor() {
    super(...arguments);
    this[_a] = true;
    this._$ctor = signal(null);
    this._$instance = signal(null);
    this._instanceCallbacks = /* @__PURE__ */ new Set();
    this._library = `${JS_DELIVR_CDN}/npm/hls.js@^1.0.0/dist/hls${".js" }`;
    this.config = {};
  }
  get type() {
    return "hls";
  }
  get canLiveSync() {
    return true;
  }
  get library() {
    return this._library;
  }
  set library(library) {
    this._library = library;
  }
  preconnect() {
    if (!isString(this._library))
      return;
    preconnect(this._library);
  }
  setup(context) {
    super.setup(context);
    loadHLSLibrary(this._library, context).then((ctor) => this._$ctor.set(() => ctor));
    useHLS(this, this.config, this._$ctor, this._$instance, context, this._instanceCallbacks);
  }
  get ctor() {
    return this._$ctor();
  }
  get instance() {
    return this._$instance();
  }
  async loadSource({ src }) {
    effect2(() => {
      if (!isString(src))
        return;
      const instance = this._$instance();
      instance?.loadSource(src);
    });
  }
  onInstance(callback) {
    const instance = peek(this._$instance);
    if (instance)
      callback(instance);
    this._instanceCallbacks.add(callback);
    return () => this._instanceCallbacks.delete(callback);
  }
};
_a = HLS_PROVIDER;
HLSProvider.supported = isHLSSupported();

export { HLSProvider, HLS_PROVIDER };
