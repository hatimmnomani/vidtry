import { defineCustomElement, onAttach, $$_clone, $$_inner_html, useMedia, useARIAKeyShortcuts, $$_create_component, useFocusVisible, MediaRemoteControl, onConnect, preconnect, $$_effect, $$_attr, $$_listen, $$_ref, $$_insert_lite, functionThrottle, $$_create_template, PlayerDefinition, registerLiteCustomElement } from './chunks/chunk-6ITALQHG.js';
import './chunks/chunk-A6N4LKP3.js';
import './chunks/chunk-N656NADJ.js';
import './chunks/chunk-E2CGHFLX.js';
import { volume_high_default } from './chunks/chunk-CQRZLEJN.js';
import { volume_low_default } from './chunks/chunk-6QXH7OQE.js';
import './chunks/chunk-SG6VFWU2.js';
import { round, clampNumber, getNumberOfDecimalPlaces, IS_SAFARI } from './chunks/chunk-WBYYK3WU.js';
import './chunks/chunk-2XPFCID3.js';
import './chunks/chunk-EIE6PMK6.js';
import './chunks/chunk-BZ2WO45J.js';
import './chunks/chunk-JNIT5EPT.js';
import './chunks/chunk-RJTWOJOE.js';
import './chunks/chunk-RQSJUBXX.js';
import './chunks/chunk-MIPPFQCV.js';
import './chunks/chunk-P4BAEY42.js';
import './chunks/chunk-OHVAI7F3.js';
import './chunks/chunk-53S5GCOJ.js';
import './chunks/chunk-XYWHYIY2.js';
import './chunks/chunk-PRPGTFPQ.js';
import './chunks/chunk-6WKXMTRI.js';
import './chunks/chunk-65UFCRVC.js';
import './chunks/chunk-FC44I5VZ.js';
import './chunks/chunk-2AJ4X4AH.js';
import './chunks/chunk-SP4IGOFD.js';
import './chunks/chunk-XXIIUDUE.js';
import './chunks/chunk-Y5PX3JFX.js';
import { seek_backward_default } from './chunks/chunk-PI7GIF4N.js';
import './chunks/chunk-Z2ANHQ5T.js';
import './chunks/chunk-LJFX5D3O.js';
import './chunks/chunk-C54XFOJ3.js';
import { seek_forward_default } from './chunks/chunk-2BONCJKS.js';
import './chunks/chunk-7432G4KT.js';
import './chunks/chunk-MHEFK2EY.js';
import './chunks/chunk-ORVWKKAQ.js';
import './chunks/chunk-5R7G7Q4J.js';
import './chunks/chunk-56SRNP62.js';
import './chunks/chunk-F5RDITH7.js';
import './chunks/chunk-MPO64HXG.js';
import './chunks/chunk-F7MWPNUS.js';
import './chunks/chunk-OTCYATYN.js';
import { play_default } from './chunks/chunk-W7HWOFZF.js';
import './chunks/chunk-XBPOC46C.js';
import './chunks/chunk-DXADZAOT.js';
import './chunks/chunk-HYE5C5HX.js';
import './chunks/chunk-HTJYFPDX.js';
import './chunks/chunk-ZLWOXFKG.js';
import './chunks/chunk-LW2K3Y6T.js';
import './chunks/chunk-BZ5RL27N.js';
import './chunks/chunk-OF25C6CA.js';
import { mute_default } from './chunks/chunk-JL7GQJWY.js';
import './chunks/chunk-HP6KF3A5.js';
import './chunks/chunk-T473ENIQ.js';
import './chunks/chunk-LH6NV2UM.js';
import { pause_default } from './chunks/chunk-CLYPDTKR.js';
import './chunks/chunk-2VTGUV3H.js';
import './chunks/chunk-IA2YZYEN.js';
import './chunks/chunk-UH6WX2WX.js';
import './chunks/chunk-YFNHHDRM.js';
import './chunks/chunk-55NFH4UN.js';
import './chunks/chunk-UAAHYEKZ.js';
import './chunks/chunk-2BOIXDBC.js';
import './chunks/chunk-F45LLMS6.js';
import './chunks/chunk-JBO4TYBR.js';
import './chunks/chunk-WHPXMMEP.js';
import './chunks/chunk-H2SQHF5M.js';
import './chunks/chunk-MIAHLTQE.js';
import { fullscreen_exit_default } from './chunks/chunk-4U2YNSSH.js';
import { fullscreen_default } from './chunks/chunk-FNXV6FCM.js';
import './chunks/chunk-3RUY2EKQ.js';
import './chunks/chunk-VBQHOIKQ.js';
import './chunks/chunk-LY7VZCXR.js';
import './chunks/chunk-YZ47LH24.js';
import './chunks/chunk-3WFNX6NU.js';
import './chunks/chunk-NXDMHFXP.js';
import './chunks/chunk-5PAQJVPA.js';
import './chunks/chunk-KOFVRZSX.js';
import './chunks/chunk-KBGY74KK.js';
import './chunks/chunk-L2IIEHSQ.js';
import './chunks/chunk-COXJ3MTM.js';
import './chunks/chunk-T5U5UPOW.js';
import './chunks/chunk-EHEOJPSI.js';
import './chunks/chunk-O7CSZKUP.js';
import './chunks/chunk-DJVOGII6.js';
import './chunks/chunk-BKK24JQH.js';
import './chunks/chunk-CE2JRWGH.js';
import './chunks/chunk-IXE2O7XT.js';
import './chunks/chunk-XMGTQM4N.js';
import './chunks/chunk-CZBWXOXR.js';
import './chunks/chunk-BWHOBLHA.js';
import './chunks/chunk-2KAXPK5C.js';
import './chunks/chunk-IEH4Y437.js';
import './chunks/chunk-XHDFE3XD.js';
import './chunks/chunk-BKHCDMZF.js';
import './chunks/chunk-TXSSS7Q2.js';
import './chunks/chunk-JL4AYSMG.js';
import './chunks/chunk-YQW4DAXB.js';
import { mergeProperties, listenEvent, isKeyboardEvent, isKeyboardClick, dispatchEvent, ariaBool, setStyle, setAttribute, createEvent, isDOMEvent } from './chunks/chunk-5CN37FD6.js';
import { signal, effect2, peek, computed, createStore, createContext, useContext, provideContext, getScope, noop, scoped } from './chunks/chunk-DVGRTHY2.js';
import './chunks/chunk-LU53YACR.js';
import './chunks/chunk-2UHE76WB.js';
import './chunks/chunk-PECDGMGS.js';
import './chunks/chunk-MTRSHFC2.js';
import './chunks/chunk-5IG467JM.js';

// ../icons/dist/browser/index.js
var lazyPaths = {
  "add-note": () => import('./chunks/add-note-K6LY3JVJ-WG2NYAHV.js'),
  "add-playlist": () => import('./chunks/add-playlist-V2PDG55Q-MXYDBP3C.js'),
  "add-user": () => import('./chunks/add-user-UODFHPUX-XLZJG5BY.js'),
  "add": () => import('./chunks/add-MKWDO7OI-TD4PME6D.js'),
  "airplay": () => import('./chunks/airplay-BBSPJ74C-VKBBISYP.js'),
  "arrow-collapse-in": () => import('./chunks/arrow-collapse-in-YL2IDAI3-OWOP7XED.js'),
  "arrow-collapse": () => import('./chunks/arrow-collapse-NIQ3FMMB-VS6NFXD5.js'),
  "arrow-expand-out": () => import('./chunks/arrow-expand-out-5VKWMS7M-AIIHPBBP.js'),
  "arrow-expand": () => import('./chunks/arrow-expand-GB4FQX53-MKVWODCB.js'),
  "arrow-left": () => import('./chunks/arrow-left-VMFA4MD3-TKEEJENX.js'),
  "bookmark": () => import('./chunks/bookmark-2HY3747X-E3ZB34NX.js'),
  "camera": () => import('./chunks/camera-MCHD22GI-VWHEDZVU.js'),
  "chapters": () => import('./chunks/chapters-WZ5VBDWL-GZ575PNF.js'),
  "chat-collapse": () => import('./chunks/chat-collapse-HT2BVQBQ-SEB35CX3.js'),
  "chat": () => import('./chunks/chat-7SNHMFOE-UUS3VUGL.js'),
  "chevron-down": () => import('./chunks/chevron-down-GHFOTKXU-KURSHSTE.js'),
  "chevron-right": () => import('./chunks/chevron-right-RDCYIUTF-PZBNAMAD.js'),
  "chromecast": () => import('./chunks/chromecast-YZXROZN5-6OFTCABS.js'),
  "clip": () => import('./chunks/clip-UTUVK5ZJ-FKJUBIMQ.js'),
  "closed-captions-on": () => import('./chunks/closed-captions-on-AWV5GKOR-QRR3MIDW.js'),
  "closed-captions": () => import('./chunks/closed-captions-OL3H52PB-IC6O4MVA.js'),
  "comment": () => import('./chunks/comment-RHVNAV2Z-ZGFDDOD4.js'),
  "computer": () => import('./chunks/computer-PDN53TBJ-B6DFQXLE.js'),
  "device": () => import('./chunks/device-2Q4T5LRZ-J6ORVQYU.js'),
  "download": () => import('./chunks/download-VRWBBFI5-4SFC4ILA.js'),
  "episodes": () => import('./chunks/episodes-6LWZNPNN-L76IHC5L.js'),
  "eye": () => import('./chunks/eye-ARGO4OXU-GJKATE2X.js'),
  "fast-backward": () => import('./chunks/fast-backward-KOWPJ77P-DJHR44PK.js'),
  "fast-forward": () => import('./chunks/fast-forward-YHUA2RUX-C5P4CBEG.js'),
  "flag": () => import('./chunks/flag-7NS553YQ-BS3L7SUX.js'),
  "fullscreen-arrow-exit": () => import('./chunks/fullscreen-arrow-exit-UMGNEUBY-DO2KEDNL.js'),
  "fullscreen-arrow": () => import('./chunks/fullscreen-arrow-EAOJK5V6-7EM7MCTC.js'),
  "fullscreen-exit": () => import('./chunks/fullscreen-exit-5I5CX33N-ZS3MQ5CX.js'),
  "fullscreen": () => import('./chunks/fullscreen-6QBZ3YMF-ELTFAZMR.js'),
  "heart": () => import('./chunks/heart-QFV2QDNC-ZCXLWAP2.js'),
  "info": () => import('./chunks/info-WIOFGZIX-JZINX4FO.js'),
  "language": () => import('./chunks/language-6XZJKRI2-C7GB6YZX.js'),
  "link": () => import('./chunks/link-ML244RKU-TLOQRMAQ.js'),
  "lock-closed": () => import('./chunks/lock-closed-7PVUSTAD-MYXOPZ7R.js'),
  "lock-open": () => import('./chunks/lock-open-QLOH2QVT-YZZBAOAP.js'),
  "menu-horizontal": () => import('./chunks/menu-horizontal-KMADVH2U-TWRECWWL.js'),
  "menu-vertical": () => import('./chunks/menu-vertical-VWVRRCQ4-ELJ4ZXO7.js'),
  "microphone": () => import('./chunks/microphone-UVDVU7A5-O5U2N7NG.js'),
  "mobile": () => import('./chunks/mobile-R5RKTMDN-QG3VZKCP.js'),
  "moon": () => import('./chunks/moon-LLSORKH7-R4HOOKU2.js'),
  "music-off": () => import('./chunks/music-off-DYEDFBO2-JDMQ7GSQ.js'),
  "music": () => import('./chunks/music-SMN7SFSX-ZPBUN3MI.js'),
  "mute": () => import('./chunks/mute-5ALLANKA-JD3MXGQ7.js'),
  "next": () => import('./chunks/next-ADSQ667Q-EL2CEXK5.js'),
  "notification": () => import('./chunks/notification-5C3KPKVZ-UUXCRBDV.js'),
  "odometer": () => import('./chunks/odometer-VYJPIAWL-HOYI64IR.js'),
  "pause": () => import('./chunks/pause-KFO7OQUJ-HXNK2ARW.js'),
  "picture-in-picture-exit": () => import('./chunks/picture-in-picture-exit-74KJR6FY-6GDX75HO.js'),
  "picture-in-picture": () => import('./chunks/picture-in-picture-KJZV43E4-EOTEGYCW.js'),
  "play": () => import('./chunks/play-JBRWVFR6-GPSPIM4U.js'),
  "playback-speed-circle": () => import('./chunks/playback-speed-circle-ZOSXV76B-UNQSLRT7.js'),
  "playlist": () => import('./chunks/playlist-NECHL7LX-BIGAOIWT.js'),
  "previous": () => import('./chunks/previous-OZJVKMBD-RKZZGY6S.js'),
  "question-mark": () => import('./chunks/question-mark-TIDUQQLU-HASDMGGE.js'),
  "queue-list": () => import('./chunks/queue-list-6AMVOMWO-XRV5LQRR.js'),
  "radio-button-selected": () => import('./chunks/radio-button-selected-DXL7XNW2-DXREAM2I.js'),
  "radio-button": () => import('./chunks/radio-button-Q3ADRHH7-OSWQPN2N.js'),
  "repeat-on": () => import('./chunks/repeat-on-AUI56XZD-DXPE4PPT.js'),
  "repeat-square-on": () => import('./chunks/repeat-square-on-RXTHU34M-F2DHPBDN.js'),
  "repeat-square": () => import('./chunks/repeat-square-GMF4W5HF-LYX4MSMG.js'),
  "repeat": () => import('./chunks/repeat-QT2XRFPW-D4FX5ZMD.js'),
  "replay": () => import('./chunks/replay-T2RUVYAH-3C75ENIG.js'),
  "rotate": () => import('./chunks/rotate-KX4CNFR3-WGZ4KLLK.js'),
  "search": () => import('./chunks/search-2JYKNW4X-WWK7EJ6K.js'),
  "seek-backward-10": () => import('./chunks/seek-backward-10-Z6KZ4QTT-TH6HE26H.js'),
  "seek-backward-15": () => import('./chunks/seek-backward-15-Y4M7ZUTB-EWL3L5GK.js'),
  "seek-backward-30": () => import('./chunks/seek-backward-30-KL5HTV4A-263RDKB7.js'),
  "seek-backward": () => import('./chunks/seek-backward-725VG7KT-RBFY7PNY.js'),
  "seek-forward-10": () => import('./chunks/seek-forward-10-KH6RHT7A-WQSXG5JG.js'),
  "seek-forward-15": () => import('./chunks/seek-forward-15-RHQSPHCS-SXA6S4R6.js'),
  "seek-forward-30": () => import('./chunks/seek-forward-30-BJUOSAZO-JJL3VFMD.js'),
  "seek-forward": () => import('./chunks/seek-forward-PT5LOJZQ-O4B5JTKE.js'),
  "send": () => import('./chunks/send-LM6WLRAI-63VDU3Z5.js'),
  "settings-menu": () => import('./chunks/settings-menu-TPGMH5JT-XRUDP52G.js'),
  "settings-switch": () => import('./chunks/settings-switch-TUFPX7FQ-5DVTAN2P.js'),
  "settings": () => import('./chunks/settings-NIOTEDBE-UYKVNTJE.js'),
  "share-arrow": () => import('./chunks/share-arrow-QWD5PQVS-MUL5F5F4.js'),
  "share": () => import('./chunks/share-HMHTXN7I-XYK5G5IY.js'),
  "shuffle-on": () => import('./chunks/shuffle-on-CKD7E2HN-LWNZL44Q.js'),
  "shuffle": () => import('./chunks/shuffle-BUFG4YJQ-NURGYMMJ.js'),
  "stop": () => import('./chunks/stop-ZU2CJPIA-AL6CK3B5.js'),
  "subtitles": () => import('./chunks/subtitles-DXOKQAOQ-OFEMG7TB.js'),
  "sun": () => import('./chunks/sun-3URLHARM-4SAHTBMW.js'),
  "theatre-mode-exit": () => import('./chunks/theatre-mode-exit-NYUOZTLG-QRK2O7ES.js'),
  "theatre-mode": () => import('./chunks/theatre-mode-YZ37QE62-DKR4QQ34.js'),
  "thumbs-down": () => import('./chunks/thumbs-down-PB3QBVDG-POFVYU2X.js'),
  "thumbs-up": () => import('./chunks/thumbs-up-KR3RGBXP-62P44JIR.js'),
  "timer": () => import('./chunks/timer-LEKSHLMO-BTCJGTJ6.js'),
  "transcript": () => import('./chunks/transcript-WBVAFRPP-LLBJEQJS.js'),
  "tv": () => import('./chunks/tv-BBPMIKYK-HHDGLKDM.js'),
  "user": () => import('./chunks/user-XLENPSJP-2HU75KXR.js'),
  "volume-high": () => import('./chunks/volume-high-QFIQXACF-MPSMWDPG.js'),
  "volume-low": () => import('./chunks/volume-low-7G4R22Y3-GCE3EMAZ.js'),
  "x-mark": () => import('./chunks/x-mark-ORJKYZQ2-2D6JGP2M.js')
};

// src/icons/element.tsx
var $$_templ = /* @__PURE__ */ $$_create_template(`<svg viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" data-media-icon="true"></svg>`);
var MediaIconDefinition = defineCustomElement({
  tagName: "media-icon",
  props: {
    type: {}
  },
  setup({ host, props: { $type }, accessors }) {
    const $paths = signal("");
    onAttach(() => {
      let hydrate = host.el.hasAttribute("mk-h");
      effect2(() => {
        const type = $type();
        if (hydrate) {
          hydrate = false;
          return;
        }
        if (type && lazyPaths[type]) {
          lazyPaths[type]().then(({ default: paths2 }) => {
            if (type === peek($type))
              $paths.set(paths2);
          });
        } else
          $paths.set("");
      });
    });
    return mergeProperties(accessors(), {
      $render: () => (() => {
        const $$_root = $$_clone($$_templ);
        $$_inner_html($$_root, $paths);
        return $$_root;
      })()
    });
  }
});

// src/player/media/outlet/element.ts
var OutletDefinition = defineCustomElement({
  tagName: "media-outlet",
  setup({ host }) {
    const context = useMedia(), $rendered = signal(false);
    onAttach(() => {
      host.el.keepAlive = true;
    });
    effect2(() => {
      context.$loader();
      return () => $rendered.set(false);
    });
    effect2(() => {
      const loader = context.$loader();
      if (!$rendered() || !loader)
        return;
      peek(() => {
        loader.load(context).then((provider) => {
          if (peek(context.$loader) === loader) {
            context.delegate.dispatch("provider-change", {
              detail: provider
            });
          }
        });
      });
    });
    return () => () => {
      $rendered.set(true);
      return context.$loader()?.render(context.$store);
    };
  }
});

// src/icons/icon.tsx
var $$_templ2 = /* @__PURE__ */ $$_create_template(`<svg viewBox="0 0 32 32" fill="none" aria-hidden="true" focusable="false" data-media-icon="true"></svg>`);
function Icon({ slot, paths: paths2 }) {
  return (() => {
    const $$_root = $$_clone($$_templ2);
    $$_attr($$_root, "slot", slot);
    $$_inner_html($$_root, paths2);
    return $$_root;
  })();
}

// src/utils/dom.ts
function setAttributeIfEmpty(target, name, value) {
  if (!target.hasAttribute(name))
    target.setAttribute(name, value);
}
function setARIALabel(target, label) {
  if (target.hasAttribute("aria-label") || target.hasAttribute("aria-describedby"))
    return;
  function updateAriaDescription() {
    setAttribute(target, "aria-label", label());
  }
  effect2(updateAriaDescription);
}

// src/player/ui/toggle-button/props.ts
var toggleButtonProps = {
  disabled: { initial: false },
  defaultPressed: { initial: false },
  defaultAppearance: { initial: false }
};

// src/player/ui/toggle-button/use-toggle-button.ts
function useToggleButton(host, { $props: { $pressed, $disabled }, ...props }) {
  host.setAttributes({
    disabled: $disabled,
    "data-pressed": $pressed,
    "aria-pressed": () => ariaBool($pressed()),
    "data-media-button": true
  });
  useFocusVisible(host.$el);
  onAttach(() => {
    setAttributeIfEmpty(host.el, "tabindex", "0");
    setAttributeIfEmpty(host.el, "role", "button");
  });
  effect2(() => {
    const target = host.$el();
    if (!target)
      return;
    const clickEvents = ["pointerup", "keydown"];
    for (const eventType of clickEvents)
      listenEvent(target, eventType, onPress);
  });
  function onPress(event) {
    const disabled = $disabled();
    if (disabled || isKeyboardEvent(event) && !isKeyboardClick(event)) {
      if (disabled)
        event.stopImmediatePropagation();
      return;
    }
    props.onPress?.(event);
  }
  return {
    get pressed() {
      return $pressed();
    },
    get disabled() {
      return $disabled();
    }
  };
}

// src/player/ui/fullscreen-button/element.tsx
var FullscreenButtonDefinition = defineCustomElement({
  tagName: "media-fullscreen-button",
  props: {
    ...toggleButtonProps,
    target: { initial: "prefer-media" }
  },
  setup({ host, props: { $target, $disabled, $defaultAppearance }, accessors }) {
    const { $store: $media, remote } = useMedia(), $pressed = () => $media.fullscreen, toggle = useToggleButton(host, {
      $props: { $pressed, $disabled },
      onPress
    });
    useARIAKeyShortcuts(host, "toggleFullscreen");
    onAttach(() => {
      setARIALabel(host.el, () => $media.fullscreen ? "Exit Fullscreen" : "Enter Fullscreen");
    });
    host.setAttributes({
      "data-hidden": () => !$media.canFullscreen,
      "data-fullscreen": () => $media.fullscreen,
      "default-appearance": $defaultAppearance
    });
    function onPress(event) {
      if ($disabled())
        return;
      $pressed() ? remote.exitFullscreen($target(), event) : remote.enterFullscreen($target(), event);
    }
    return mergeProperties(toggle, accessors(), {
      $render: () => {
        return [
          $$_create_component(Icon, { paths: fullscreen_default, slot: "enter" }),
          $$_create_component(Icon, { paths: fullscreen_exit_default, slot: "exit" })
        ];
      }
    });
  }
});

// src/player/ui/live-indicator/element.tsx
var $$_templ3 = /* @__PURE__ */ $$_create_template(`<div part="container"><div part="text">LIVE</div></div>`);
var LiveIndicatorDefinition = defineCustomElement({
  tagName: "media-live-indicator",
  setup({ host }) {
    const { $store: $media, remote } = useMedia();
    useFocusVisible(host.$el);
    host.setAttributes({
      tabindex: () => $media.live ? 0 : null,
      role: () => $media.live ? "button" : null,
      "data-live": () => $media.live,
      "data-live-edge": () => $media.liveEdge,
      "data-media-button": true
    });
    onAttach(() => {
      setARIALabel(host.el, () => $media.live ? "Go live" : null);
      const clickEvents = ["pointerup", "keydown"];
      for (const eventType of clickEvents)
        listenEvent(host.el, eventType, onPress);
    });
    function onPress(event) {
      if ($media.liveEdge || isKeyboardEvent(event) && !isKeyboardClick(event))
        return;
      remote.seekToLiveEdge(event);
    }
    return () => $$_clone($$_templ3);
  }
});

// src/player/ui/mute-button/element.tsx
var MuteButtonDefinition = defineCustomElement({
  tagName: "media-mute-button",
  props: toggleButtonProps,
  setup({ host, props: { $disabled, $defaultAppearance } }) {
    const { $store: $media, remote } = useMedia(), $pressed = computed(() => $media.muted || $media.volume === 0), toggle = useToggleButton(host, {
      $props: { $pressed, $disabled },
      onPress
    });
    useARIAKeyShortcuts(host, "toggleMuted");
    onAttach(() => {
      setARIALabel(host.el, () => $pressed() ? "Unmute" : "Mute");
    });
    host.setAttributes({
      "data-muted": $pressed,
      "data-volume": getVolumeText,
      "default-appearance": $defaultAppearance
    });
    function getVolumeText() {
      if ($media.muted || $media.volume === 0)
        return "muted";
      else if ($media.volume >= 0.5)
        return "high";
      else if ($media.volume < 0.5)
        return "low";
    }
    function onPress(event) {
      if ($disabled())
        return;
      $pressed() ? remote.unmute(event) : remote.mute(event);
    }
    return mergeProperties(toggle, {
      $render: () => {
        return [
          $$_create_component(Icon, { paths: volume_high_default, slot: "volume-high" }),
          $$_create_component(Icon, { paths: volume_low_default, slot: "volume-low" }),
          $$_create_component(Icon, { paths: mute_default, slot: "volume-muted" })
        ];
      }
    });
  }
});

// src/player/ui/play-button/element.tsx
var PlayButtonDefinition = defineCustomElement({
  tagName: "media-play-button",
  props: toggleButtonProps,
  setup({ host, props: { $disabled, $defaultAppearance } }) {
    const { $store: $media, remote } = useMedia(), $pressed = () => !$media.paused, toggle = useToggleButton(host, {
      $props: { $pressed, $disabled },
      onPress
    });
    useARIAKeyShortcuts(host, "togglePaused");
    onAttach(() => {
      setARIALabel(host.el, () => $media.paused ? "Play" : "Pause");
    });
    host.setAttributes({
      "default-appearance": $defaultAppearance,
      "data-paused": () => $media.paused
    });
    function onPress(event) {
      if ($disabled())
        return;
      $pressed() ? remote.pause(event) : remote.play(event);
    }
    return mergeProperties(toggle, {
      $render: () => {
        return [
          $$_create_component(Icon, { paths: play_default, slot: "play" }),
          $$_create_component(Icon, { paths: pause_default, slot: "pause" })
        ];
      }
    });
  }
});

// src/player/ui/poster/props.ts
var posterProps = {
  alt: {}
};

// src/player/ui/poster/element.tsx
var $$_templ4 = /* @__PURE__ */ $$_create_template(`<img part="img" />`);
var PosterDefinition = defineCustomElement({
  tagName: "media-poster",
  props: posterProps,
  setup({ host, props: { $alt } }) {
    const { $store: $media } = useMedia(), remote = new MediaRemoteControl();
    const $imgSrc = () => $media.canLoad && $media.poster.length ? $media.poster : null, $imgAlt = () => $imgSrc() ? $alt() : null, $imgLoading = signal(true), $imgError = signal(false);
    host.setAttributes({
      "data-loading": $imgLoading,
      "data-hidden": $imgError
    });
    onConnect(() => {
      window.requestAnimationFrame(() => {
        if (!$media.canLoad)
          preconnect($media.poster);
      });
      remote.setTarget(host.el);
      remote.hidePoster();
      return () => remote.showPoster();
    });
    effect2(() => {
      const isLoading = $media.canLoad && !!$media.poster;
      $imgLoading.set(isLoading);
      $imgError.set(false);
    });
    function onLoad() {
      $imgLoading.set(false);
    }
    function onError() {
      $imgLoading.set(false);
      $imgError.set(true);
    }
    return () => (() => {
      const $$_root = $$_clone($$_templ4);
      $$_effect(() => $$_attr($$_root, "src", $imgSrc()));
      $$_effect(() => $$_attr($$_root, "alt", $imgAlt()));
      $$_listen($$_root, "load", onLoad);
      $$_listen($$_root, "error", onError);
      return $$_root;
    })();
  }
});

// src/player/ui/seek-button/element.tsx
var SeekButtonDefinition = defineCustomElement({
  tagName: "media-seek-button",
  props: { seconds: { initial: 30 }, defaultAppearance: { initial: false } },
  setup({ host, props: { $seconds, $defaultAppearance } }) {
    const { $store: $media, remote } = useMedia();
    useFocusVisible(host.$el);
    onAttach(() => {
      setAttributeIfEmpty(host.el, "tabindex", "0");
      setAttributeIfEmpty(host.el, "role", "button");
      setARIALabel(
        host.el,
        () => `Seek ${$seconds() > 0 ? "forward" : "backward"} ${$seconds()} seconds`
      );
      const clickEvents = ["pointerup", "keydown"];
      for (const eventType of clickEvents)
        listenEvent(host.el, eventType, onPress);
    });
    host.setAttributes({
      seconds: $seconds,
      "data-media-button": true,
      "default-appearance": $defaultAppearance,
      "data-hidden": () => !$media.canSeek
    });
    function onPress(event) {
      if (isKeyboardEvent(event) && !isKeyboardClick(event))
        return;
      remote.seek($media.currentTime + $seconds(), event);
    }
    return () => [
      $$_create_component(Icon, { paths: seek_backward_default, slot: "backward" }),
      $$_create_component(Icon, { paths: seek_forward_default, slot: "forward" })
    ];
  }
});

// src/player/ui/slider/store.ts
var sliderStore = createStore({
  min: 0,
  max: 100,
  value: 50,
  pointerValue: 0,
  focused: false,
  dragging: false,
  pointing: false,
  get interactive() {
    return this.dragging || this.focused || this.pointing;
  },
  get fillRate() {
    return calcRate(this.min, this.max, this.value);
  },
  get fillPercent() {
    return this.fillRate * 100;
  },
  get pointerRate() {
    return calcRate(this.min, this.max, this.pointerValue);
  },
  get pointerPercent() {
    return this.pointerRate * 100;
  }
});
function calcRate(min, max, value) {
  const range = max - min, offset = value - min;
  return range > 0 ? offset / range : 0;
}
var sliderStoreContext = createContext(() => sliderStore.create());
function useSliderStore() {
  return useContext(sliderStoreContext);
}

// src/player/ui/slider-thumbnail/element.tsx
var $$_templ5 = /* @__PURE__ */ $$_create_template(`<div part="container"><img part="img" loading="eager" decoding="async" /></div>`);
var SliderThumbnailDefinition = defineCustomElement({
  tagName: "media-slider-thumbnail",
  props: { src: { initial: "" } },
  setup({ host, props: { $src } }) {
    const $img = signal(null), $imgSrc = signal(""), $imgLoaded = signal(false), $error = signal(false), $coords = signal(null), $cueList = signal(null), $activeCue = signal(null), $hidden = () => $error() || !Number.isFinite($media.duration), $slider = useSliderStore(), { $store: $media } = useMedia();
    host.setAttributes({
      "data-loading": () => !$hidden() && !$imgLoaded(),
      "data-hidden": $hidden
    });
    effect2(() => {
      if (!$media.canLoad)
        return;
      const video = document.createElement("video");
      video.crossOrigin = "";
      const track = document.createElement("track");
      track.src = $src();
      track.default = true;
      track.kind = "metadata";
      video.append(track);
      let cancelled = false;
      $error.set(false);
      $imgLoaded.set(false);
      track.onload = () => {
        if (cancelled)
          return;
        $cueList.set(track.track.cues);
      };
      track.onerror = () => $error.set(true);
      return () => {
        cancelled = true;
        $cueList.set(null);
      };
    });
    effect2(() => {
      const cues = $cueList();
      if (!cues || !Number.isFinite($media.duration)) {
        $activeCue.set(null);
        return;
      }
      const currentTime = $slider.pointerRate * $media.duration;
      for (let i = 0; i < cues.length; i++) {
        if (currentTime >= cues[i].startTime && currentTime <= cues[i].endTime) {
          $activeCue.set(cues[i]);
          break;
        }
      }
    });
    effect2(() => {
      const cue = $activeCue();
      if (!cue) {
        $imgSrc.set("");
        $coords.set(null);
        return;
      }
      const [_src, _coords] = (cue.text || "").split("#");
      const [_props, _values] = _coords.split("=");
      $imgSrc.set(
        !peek($src).startsWith("/") && _src.startsWith("/") ? `${new URL(peek($src)).origin}${_src}` : _src
      );
      if (_props && _values) {
        const coords = {}, values = _values.split(",");
        for (let i = 0; i < _props.length; i++)
          coords[_props[i]] = +values[i];
        $coords.set(coords);
      } else {
        $coords.set(null);
      }
    });
    effect2(() => {
      $imgSrc();
      $imgLoaded.set(false);
    });
    const styleReverts = [];
    function applyStyle(el, name, value, priority) {
      el.style.setProperty(name, value, priority);
      styleReverts.push(() => el.style.removeProperty(name));
    }
    effect2(() => {
      const img = $img(), coords = $coords();
      if (!img || !coords || !$imgLoaded()) {
        for (const revert of styleReverts)
          revert();
        return;
      }
      const { w, h, x, y } = coords, { maxWidth, maxHeight, minWidth, minHeight } = getComputedStyle(host.el), minRatio = Math.max(parseInt(minWidth) / w, parseInt(minHeight) / h), maxRatio = Math.min(parseInt(maxWidth) / w, parseInt(maxHeight) / h), scale = maxRatio < 1 ? maxRatio : minRatio > 1 ? minRatio : 1;
      styleReverts.length = 0;
      applyStyle(host.el, "--thumbnail-width", `${w * scale}px`);
      applyStyle(host.el, "--thumbnail-height", `${h * scale}px`);
      applyStyle(img, "width", `${img.naturalWidth * scale}px`);
      applyStyle(img, "height", `${img.naturalHeight * scale}px`);
      applyStyle(img, "transform", `translate(-${x * scale}px, -${y * scale}px)`);
    });
    return () => (() => {
      const $$_root = $$_clone($$_templ5), $$_el = $$_root.firstChild;
      $$_effect(() => $$_attr($$_el, "src", $imgSrc()));
      $$_listen($$_el, "load", () => $imgLoaded.set(true));
      $$_ref($$_el, $img.set);
      return $$_root;
    })();
  }
});

// src/utils/time.ts
function padNumberWithZeroes(num, expectedLength) {
  const str = String(num);
  const actualLength = str.length;
  const shouldPad = actualLength < expectedLength;
  if (shouldPad) {
    const padLength = expectedLength - actualLength;
    const padding = `0`.repeat(padLength);
    return `${padding}${num}`;
  }
  return str;
}
function parseTime(duration) {
  const hours = Math.trunc(duration / 3600);
  const minutes = Math.trunc(duration % 3600 / 60);
  const seconds = Math.trunc(duration % 60);
  const fraction = Number((duration - Math.trunc(duration)).toPrecision(3));
  return {
    hours,
    minutes,
    seconds,
    fraction
  };
}
function formatTime(duration, shouldPadHours = false, shouldAlwaysShowHours = false) {
  const { hours, minutes, seconds } = parseTime(duration);
  const paddedHours = shouldPadHours ? padNumberWithZeroes(hours, 2) : hours;
  const paddedMinutes = padNumberWithZeroes(minutes, 2);
  const paddedSeconds = padNumberWithZeroes(seconds, 2);
  if (hours > 0 || shouldAlwaysShowHours) {
    return `${paddedHours}:${paddedMinutes}:${paddedSeconds}`;
  }
  return `${minutes}:${paddedSeconds}`;
}
function formatSpokenTime(duration) {
  const spokenParts = [];
  const { hours, minutes, seconds } = parseTime(duration);
  const pluralize = (num, word) => num === 1 ? word : `${word}s`;
  if (hours > 0) {
    spokenParts.push(`${hours} ${pluralize(hours, "hour")}`);
  }
  if (minutes > 0) {
    spokenParts.push(`${minutes} ${pluralize(minutes, "minute")}`);
  }
  if (seconds > 0 || spokenParts.length === 0) {
    spokenParts.push(`${seconds} ${pluralize(seconds, "second")}`);
  }
  return spokenParts.join(", ");
}

// src/player/ui/slider/format.ts
var sliderValueFormattersContext = createContext(() => ({}));

// src/player/ui/slider-value/props.ts
var sliderValueTextProps = {
  type: { initial: "current" },
  format: {},
  showHours: { initial: false },
  padHours: { initial: false },
  decimalPlaces: { initial: 2 }
};

// src/player/ui/slider-value/element.tsx
var $$_templ6 = /* @__PURE__ */ $$_create_template(`<span></span>`);
var SliderValueDefinition = defineCustomElement({
  tagName: "media-slider-value",
  props: sliderValueTextProps,
  setup({ props: { $type, $format, $decimalPlaces, $padHours, $showHours } }) {
    const $slider = useSliderStore(), formatters = useContext(sliderValueFormattersContext);
    const $text = computed(() => {
      const value = $type() === "current" ? $slider.value : $slider.pointerValue;
      const format = $format();
      if (format === "percent") {
        const range = $slider.max - $slider.min;
        const percent = value / range * 100;
        return (formatters.percent ?? round)(percent, $decimalPlaces()) + "\uFE6A";
      } else if (format === "time") {
        return (formatters.time ?? formatTime)(value, $padHours(), $showHours());
      } else {
        return formatters.value?.(value) ?? value.toFixed(2);
      }
    });
    return () => (() => {
      const $$_root = $$_clone($$_templ6);
      $$_insert_lite($$_root, $text);
      return $$_root;
    })();
  }
});

// src/player/ui/slider-video/props.ts
var sliderVideoProps = {
  src: {}
};

// src/player/ui/slider-video/element.tsx
var $$_templ7 = /* @__PURE__ */ $$_create_template(`<video muted="" playsinline="" preload="auto" part="video" style="max-width: unset"></video>`);
var SliderVideoDefinition = defineCustomElement({
  tagName: "media-slider-video",
  props: sliderVideoProps,
  setup({ host, props: { $src } }) {
    let videoElement = null;
    const $canPlay = signal(false), $error = signal(false), $slider = useSliderStore(), { $store: $media } = useMedia(), $videoSrc = () => $media.canLoad ? $src() : null, $hidden = () => !!$error() || !Number.isFinite($media.duration);
    host.setAttributes({
      "data-loading": () => !$canPlay() && !$hidden(),
      "data-hidden": $hidden
    });
    effect2(() => {
      if ($canPlay() && videoElement && Number.isFinite($media.duration)) {
        videoElement.currentTime = $slider.pointerRate * $media.duration;
      }
    });
    effect2(() => {
      $src();
      $canPlay.set(false);
      $error.set(false);
    });
    onConnect(() => {
      if (videoElement.readyState >= 2)
        onCanPlay();
    });
    function onCanPlay(trigger) {
      $canPlay.set(true);
      dispatchEvent(host.el, "can-play", { trigger });
    }
    function onError(trigger) {
      $error.set(true);
      dispatchEvent(host.el, "error", { trigger });
    }
    return () => (() => {
      const $$_root = $$_clone($$_templ7);
      $$_effect(() => $$_attr($$_root, "src", $videoSrc()));
      $$_listen($$_root, "canplay", onCanPlay);
      $$_listen($$_root, "error", onError);
      $$_ref($$_root, (el) => void (videoElement = el));
      return $$_root;
    })();
  }
});

// src/player/ui/slider/utils.ts
function getClampedValue(min, max, value, step) {
  return clampNumber(min, round(value, getNumberOfDecimalPlaces(step)), max);
}
function getValueFromRate(min, max, rate, step) {
  const boundRate = clampNumber(0, rate, 1);
  const range = max - min;
  const fill = range * boundRate;
  const stepRatio = Math.round(fill / step);
  const steps = step * stepRatio;
  return min + steps;
}

// src/player/ui/slider/use-events.ts
var SliderKeyDirection = {
  Left: -1,
  ArrowLeft: -1,
  Up: 1,
  ArrowUp: 1,
  Right: 1,
  ArrowRight: 1,
  Down: -1,
  ArrowDown: -1
};
function useSliderEvents(host, { $disabled, $step, $keyStep, $shiftKeyMultiplier }, { onValueChange, onDragStart, onDragValueChange, onDragEnd }, $store) {
  const remote = useMedia().remote;
  effect2(() => {
    const target = host.$el();
    if (!target || $disabled())
      return;
    listenEvent(target, "focus", onFocus);
    listenEvent(target, "pointerenter", onPointerEnter);
    listenEvent(target, "pointermove", onPointerMove);
    listenEvent(target, "pointerleave", onPointerLeave);
    listenEvent(target, "pointerdown", onPointerDown);
    listenEvent(target, "keydown", onKeyDown);
    listenEvent(target, "keyup", onKeyUp);
  });
  effect2(() => {
    if ($disabled() || !$store.dragging)
      return;
    listenEvent(document, "pointerup", onDocumentPointerUp);
    listenEvent(document, "pointermove", onDocumentPointerMove);
    if (IS_SAFARI)
      listenEvent(document, "touchmove", onDocumentTouchMove, { passive: false });
  });
  function onFocus() {
    updatePointerValue($store.value);
  }
  function updateValue(value, trigger) {
    $store.value = Math.max($store.min, Math.min(value, $store.max));
    const event = createEvent(host.el, "value-change", { detail: $store.value, trigger });
    host.el?.dispatchEvent(event);
    onValueChange?.(event);
    if ($store.dragging) {
      const event2 = createEvent(host.el, "drag-value-change", { detail: value, trigger });
      host.el?.dispatchEvent(event2);
      onDragValueChange?.(event2);
    }
  }
  function updatePointerValue(value, trigger) {
    $store.pointerValue = Math.max($store.min, Math.min(value, $store.max));
    dispatchEvent(host.el, "pointer-value-change", { detail: value, trigger });
    if ($store.dragging)
      updateValue(value, trigger);
  }
  function getPointerValue(event) {
    const thumbClientX = event.clientX;
    const { left: trackLeft, width: trackWidth } = host.el.getBoundingClientRect();
    const thumbPositionRate = (thumbClientX - trackLeft) / trackWidth;
    return getValueFromRate($store.min, $store.max, thumbPositionRate, $step());
  }
  function onPointerEnter() {
    $store.pointing = true;
  }
  function onPointerMove(event) {
    if ($store.dragging)
      return;
    updatePointerValue(getPointerValue(event), event);
  }
  function onPointerLeave(event) {
    $store.pointing = false;
  }
  function onPointerDown(event) {
    const value = getPointerValue(event);
    onStartDragging(value, event);
    updatePointerValue(value, event);
  }
  function onStartDragging(value, trigger) {
    if ($store.dragging)
      return;
    $store.dragging = true;
    const dragStartEvent = createEvent(host.el, "drag-start", { detail: value, trigger });
    host.el?.dispatchEvent(dragStartEvent);
    onDragStart?.(dragStartEvent);
  }
  function onStopDragging(value, trigger) {
    if (!$store.dragging)
      return;
    $store.dragging = false;
    remote.resumeUserIdle(trigger);
    const dragEndEvent = createEvent(host.el, "drag-start", { detail: value, trigger });
    host.el?.dispatchEvent(dragEndEvent);
    onDragEnd?.(dragEndEvent);
  }
  let lastDownKey;
  function onKeyDown(event) {
    if (isDOMEvent(event)) {
      const trigger = event.trigger;
      if (isKeyboardEvent(trigger))
        event = trigger;
      else
        return;
    }
    const { key } = event;
    if (key === "Home" || key === "PageUp") {
      updatePointerValue($store.min, event);
      updateValue($store.min, event);
      return;
    } else if (key === "End" || key === "PageDown") {
      updatePointerValue($store.max, event);
      updateValue($store.max, event);
      return;
    } else if (/[0-9]/.test(key)) {
      const value2 = ($store.max - $store.min) / 10 * Number(key);
      updatePointerValue(value2, event);
      updateValue(value2, event);
      return;
    }
    const value = getKeyValue(event);
    if (!value)
      return;
    const repeat = key === lastDownKey;
    if (!$store.dragging && repeat)
      onStartDragging(value, event);
    updatePointerValue(value, event);
    if (!repeat)
      updateValue(value, event);
    lastDownKey = key;
  }
  function onKeyUp(event) {
    if (isDOMEvent(event)) {
      const trigger = event.trigger;
      if (isKeyboardEvent(trigger))
        event = trigger;
      else
        return;
    }
    lastDownKey = "";
    if (!$store.dragging)
      return;
    const value = getKeyValue(event) ?? $store.value;
    updatePointerValue(value);
    onStopDragging(value, event);
  }
  function getKeyValue(event) {
    const { key, shiftKey } = event, isValidKey = Object.keys(SliderKeyDirection).includes(key);
    if (!isValidKey)
      return;
    const modifiedStep = !shiftKey ? $keyStep() : $keyStep() * $shiftKeyMultiplier(), direction = Number(SliderKeyDirection[key]), diff = modifiedStep * direction, steps = ($store.value + diff) / $step();
    return Number(($step() * steps).toFixed(3));
  }
  function onDocumentPointerUp(event) {
    const value = getPointerValue(event);
    updatePointerValue(value, event);
    onStopDragging(value, event);
  }
  function onDocumentTouchMove(event) {
    event.preventDefault();
  }
  function onDocumentPointerMove(event) {
    updatePointerValue(getPointerValue(event), event);
  }
}

// src/player/ui/slider/create.tsx
var $$_templ8 = /* @__PURE__ */ $$_create_template(`<div part="track"></div>`);
var $$_templ_2 = /* @__PURE__ */ $$_create_template(`<div part="track track-fill"></div>`);
var $$_templ_3 = /* @__PURE__ */ $$_create_template(`<div part="track track-progress"></div>`);
var $$_templ_4 = /* @__PURE__ */ $$_create_template(`<div part="thumb-container"><div part="thumb"></div></div>`);
function createSlider(host, { $props, readonly, aria, ...callbacks }, accessors) {
  provideContext(sliderStoreContext);
  provideContext(sliderValueFormattersContext);
  const scope = getScope(), $store = useContext(sliderStoreContext), $focused = useFocusVisible(host.$el), { $disabled, $min, $max, $value, $step } = $props;
  host.setAttributes({
    disabled: $disabled,
    "data-dragging": () => $store.dragging,
    "data-pointing": () => $store.pointing,
    "data-interactive": () => $store.interactive,
    "aria-disabled": () => ariaBool($disabled()),
    "aria-valuemin": aria?.valueMin ?? (() => $store.min),
    "aria-valuemax": aria?.valueMax ?? (() => $store.max),
    "aria-valuenow": aria?.valueNow ?? (() => Math.round($store.value)),
    "aria-valuetext": aria?.valueText ?? (() => round($store.value / $store.max * 100, 2) + "%"),
    "data-media-slider": true
  });
  host.setCSSVars({
    "--slider-fill-rate": () => $store.fillRate,
    "--slider-fill-value": () => $store.value,
    "--slider-fill-percent": () => $store.fillPercent + "%",
    "--slider-pointer-rate": () => $store.pointerRate,
    "--slider-pointer-value": () => $store.pointerValue,
    "--slider-pointer-percent": () => $store.pointerPercent + "%"
  });
  useSliderEvents(host, $props, callbacks, $store);
  onAttach(() => {
    setAttributeIfEmpty(host.el, "role", "slider");
    setAttributeIfEmpty(host.el, "tabindex", "0");
    setAttributeIfEmpty(host.el, "aria-orientation", "horizontal");
    setAttributeIfEmpty(host.el, "autocomplete", "off");
  });
  effect2(() => {
    $store.focused = $focused();
  });
  effect2(() => {
    const target = host.$el();
    if (!target || $disabled())
      return;
    const preview = target.querySelector('[slot="preview"]');
    if (!preview)
      return;
    const rect = preview.getBoundingClientRect();
    const styles = {
      "--computed-width": rect.width + "px",
      "--computed-height": rect.height + "px",
      "--preview-top": "calc(-1 * var(--media-slider-preview-gap, calc(var(--preview-height) + 6px)))",
      "--preview-width": "var(--media-slider-preview-width, var(--computed-width))",
      "--preview-height": "var(--media-slider-preview-height, var(--computed-height))",
      "--preview-width-half": "calc(var(--preview-width) / 2)",
      "--preview-left-clamp": "max(var(--preview-width-half), var(--slider-pointer-percent))",
      "--preview-right-clamp": "calc(100% - var(--preview-width-half))",
      "--preview-left": "min(var(--preview-left-clamp), var(--preview-right-clamp))"
    };
    for (const name of Object.keys(styles)) {
      setStyle(preview, name, styles[name]);
    }
    function onPreviewResize() {
      const rect2 = preview.getBoundingClientRect();
      setStyle(preview, "--computed-width", rect2.width + "px");
      setStyle(preview, "--computed-height", rect2.height + "px");
    }
    window.requestAnimationFrame(onPreviewResize);
    const observer = new ResizeObserver(onPreviewResize);
    observer.observe(preview);
    return () => observer.disconnect();
  });
  if (!readonly) {
    effect2(() => {
      $store.min = $min();
      $store.max = $max();
    });
    effect2(() => {
      if (peek(() => $store.dragging))
        return;
      $store.value = getClampedValue($store.min, $store.max, $value(), $step());
    });
  }
  effect2(() => {
    if (!$disabled())
      return;
    $store.dragging = false;
    $store.pointing = false;
  });
  return {
    $store,
    members: mergeProperties(
      accessors(),
      {
        get value() {
          return $store.value;
        },
        set value(value) {
          $store.value = value;
        },
        get $store() {
          return $store;
        },
        state: new Proxy($store, {
          set: noop
        }),
        subscribe: (callback) => scoped(() => effect2(() => callback($store)), scope),
        $render: () => {
          return [$$_clone($$_templ8), $$_clone($$_templ_2), $$_clone($$_templ_3), $$_clone($$_templ_4)];
        }
      },
      {}
    )
  };
}

// src/player/ui/slider/props.ts
var sliderProps = {
  min: { initial: 0 },
  max: { initial: 100 },
  disabled: { initial: false, type: { from: false } },
  value: { initial: 100 },
  step: { initial: 1 },
  keyStep: { initial: 1 },
  shiftKeyMultiplier: { initial: 5 }
};

// src/player/ui/slider/element.ts
var SliderDefinition = defineCustomElement({
  tagName: "media-slider",
  props: sliderProps,
  setup({ host, props, accessors }) {
    const { members } = createSlider(host, { $props: props }, accessors);
    return members;
  }
});

// src/player/ui/time-slider/props.ts
var timeSliderProps = {
  ...sliderProps,
  min: { initial: 0, attribute: false },
  max: { initial: 0, attribute: false },
  value: { initial: 0, attribute: false },
  pauseWhileDragging: { initial: false },
  seekingRequestThrottle: { initial: 100 }
};

// src/player/ui/time-slider/element.tsx
var TimeSliderDefinition = defineCustomElement({
  tagName: "media-time-slider",
  props: timeSliderProps,
  setup({
    host,
    props: { $pauseWhileDragging, $seekingRequestThrottle, $disabled, ...props },
    accessors
  }) {
    const { $store: $media, remote } = useMedia(), { $store, members } = createSlider(
      host,
      {
        $props: {
          ...props,
          $step: () => props.$step() / $media.duration * 100,
          $keyStep: () => props.$keyStep() / $media.duration * 100,
          $disabled: () => $disabled() || !$media.canSeek
        },
        readonly: true,
        aria: { valueMin: 0, valueMax: 100, valueText: getSpokenText },
        onDragStart,
        onDragEnd,
        onValueChange,
        onDragValueChange
      },
      accessors
    );
    onAttach(() => {
      setAttributeIfEmpty(host.el, "aria-label", "Media time");
    });
    effect2(() => {
      const newValue = getPercent($media.currentTime);
      if (!peek(() => $store.dragging)) {
        $store.value = newValue;
        dispatchEvent(host.el, "value-change", { detail: newValue });
      }
    });
    let dispatchSeeking;
    effect2(() => {
      dispatchSeeking = functionThrottle(seeking, $seekingRequestThrottle());
    });
    function seeking(time, event) {
      remote.seeking(time, event);
    }
    function seek(time, percent, event) {
      dispatchSeeking.cancel();
      if ($media.live && percent >= 99) {
        remote.seekToLiveEdge(event);
        return;
      }
      remote.seek(time, event);
    }
    let wasPlayingBeforeDragStart = false;
    function onDragStart(event) {
      if ($pauseWhileDragging()) {
        wasPlayingBeforeDragStart = !$media.paused;
        remote.pause(event);
      }
    }
    function onValueChange(event) {
      if ($store.dragging || !event.trigger)
        return;
      onDragEnd(event);
    }
    function onDragValueChange(event) {
      dispatchSeeking(getTime(event.detail), event);
    }
    function onDragEnd(event) {
      const percent = event.detail;
      seek(getTime(percent), percent, event);
      if ($pauseWhileDragging() && wasPlayingBeforeDragStart) {
        remote.play(event);
        wasPlayingBeforeDragStart = false;
      }
    }
    function getTime(percent) {
      return Math.round(percent / 100 * $media.duration);
    }
    function getPercent(time) {
      const rate = Math.max(
        0,
        Math.min(1, $media.liveEdge ? 1 : Math.min(time, $media.duration) / $media.duration)
      );
      return Number.isNaN(rate) ? 0 : Number.isFinite(rate) ? rate * 100 : 100;
    }
    function getSpokenText() {
      const time = getTime($store.value);
      return Number.isFinite(time) ? `${formatSpokenTime(time)} out of ${formatSpokenTime($media.duration)}` : "live";
    }
    provideContext(sliderValueFormattersContext, {
      value(percent) {
        const time = getTime(percent);
        return Number.isFinite(time) ? ($media.live ? time - $media.duration : time).toFixed(0) : "LIVE";
      },
      time(percent, padHours, showHours) {
        const time = getTime(percent);
        const value = $media.live ? time - $media.duration : time;
        return Number.isFinite(time) ? `${value < 0 ? "-" : ""}${formatTime(Math.abs(value), padHours, showHours)}` : "LIVE";
      }
    });
    return mergeProperties(members, {
      get min() {
        return members.min;
      },
      get max() {
        return members.max;
      },
      get value() {
        return members.value;
      }
    });
  }
});

// src/player/ui/time/props.ts
var timeProps = {
  type: { initial: "current" },
  showHours: { initial: false },
  padHours: { initial: false },
  remainder: { initial: false }
};

// src/player/ui/time/element.tsx
var $$_templ9 = /* @__PURE__ */ $$_create_template(`<span></span>`);
var TimeDefinition = defineCustomElement({
  tagName: "media-time",
  props: timeProps,
  setup({ props: { $remainder, $padHours, $showHours, $type } }) {
    const $media = useMedia().$store;
    const $formattedTime = computed(() => {
      const seconds = getSeconds($type(), $media), duration = $media.duration;
      if (!Number.isFinite(seconds + duration))
        return "LIVE";
      const time = $remainder() ? Math.max(0, duration - seconds) : seconds;
      return formatTime(time, $padHours(), $showHours());
    });
    return () => (() => {
      const $$_root = $$_clone($$_templ9);
      $$_insert_lite($$_root, $formattedTime);
      return $$_root;
    })();
  }
});
function getSeconds(type, $media) {
  switch (type) {
    case "buffered":
      return $media.bufferedEnd;
    case "duration":
      return $media.duration;
    default:
      return $media.currentTime;
  }
}

// src/player/ui/toggle-button/element.ts
var ToggleButtonDefinition = defineCustomElement({
  tagName: "media-toggle-button",
  props: toggleButtonProps,
  setup({ host, props }) {
    const $pressed = signal(props.$defaultPressed()), toggle = useToggleButton(host, {
      $props: { ...props, $pressed },
      onPress
    });
    function onPress() {
      if (props.$disabled())
        return;
      $pressed.set((p) => !p);
    }
    return toggle;
  }
});

// src/player/ui/volume-slider/props.ts
var volumeSliderProps = {
  ...sliderProps,
  min: { initial: 0, attribute: false },
  max: { initial: 100, attribute: false },
  value: { initial: 100, attribute: false }
};

// src/player/ui/volume-slider/element.tsx
var VolumeSliderDefinition = defineCustomElement({
  tagName: "media-volume-slider",
  props: volumeSliderProps,
  setup({ host, props, accessors }) {
    const { $store: $media, remote } = useMedia(), { $store, members } = createSlider(
      host,
      {
        $props: props,
        readonly: true,
        aria: { valueMin: 0, valueMax: 100 },
        onValueChange: functionThrottle(onVolumeChange, 25)
      },
      accessors
    );
    onAttach(() => {
      setAttributeIfEmpty(host.el, "aria-label", "Media volume");
    });
    effect2(() => {
      const newValue = $media.muted ? 0 : $media.volume * 100;
      $store.value = newValue;
      dispatchEvent(host.el, "value-change", { detail: newValue });
    });
    function onVolumeChange(event) {
      if (!event.trigger)
        return;
      const mediaVolume = round(event.detail / 100, 3);
      remote.changeVolume(mediaVolume, event);
    }
    return mergeProperties(members, {
      get min() {
        return members.min;
      },
      get max() {
        return members.max;
      },
      get value() {
        return members.value;
      }
    });
  }
});

// src/register.ts
function registerAllElements() {
  [
    MediaIconDefinition,
    PlayerDefinition,
    OutletDefinition,
    PosterDefinition,
    PlayButtonDefinition,
    MuteButtonDefinition,
    SeekButtonDefinition,
    FullscreenButtonDefinition,
    TimeSliderDefinition,
    VolumeSliderDefinition,
    ToggleButtonDefinition,
    TimeDefinition,
    SliderDefinition,
    SliderValueDefinition,
    SliderThumbnailDefinition,
    SliderVideoDefinition,
    LiveIndicatorDefinition
  ].map(registerLiteCustomElement);
}

// src/cdn.ts
registerAllElements();
