import { VideoProvider } from './chunk-U654IJ5Z.js';
import { createRAFLoop } from './chunk-R25FJ2GA.js';
import { HLS_LISTENERS, coerceToError } from './chunk-X7B54CIG.js';
import { preconnect, loadScript } from './chunk-PU7R6IPU.js';
import { isHLSSupported } from './chunk-OJUUTMEH.js';
import { signal, effect, peek } from 'maverick.js';
import { isString, isUndefined, dispatchEvent, isFunction, DOMEvent, kebabToCamelCase, camelToKebabCase } from 'maverick.js/std';

async function loadHLSLibrary(lib, { player, delegate, logger }) {
  const callbacks = {
    onLoadStart() {
      dispatchEvent(player, "hls-lib-load-start");
    },
    onLoaded(ctor2) {
      dispatchEvent(player, "hls-lib-loaded", { detail: ctor2 });
    },
    onLoadError(e) {
      const error = coerceToError(e);
      dispatchEvent(player, "hls-lib-load-error", { detail: error });
      delegate.dispatch("error", { detail: { message: error.message, code: 4 } });
    }
  };
  let ctor = await loadHLSScript(lib, callbacks);
  if (isUndefined(ctor) && !isString(lib))
    ctor = await importHLS(lib, callbacks);
  if (!ctor)
    return null;
  if (!ctor.isSupported()) {
    const message = "[vidstack]: `hls.js` is not supported in this environment";
    dispatchEvent(player, "hls-unsupported");
    delegate.dispatch("error", { detail: { message, code: 4 } });
    return null;
  }
  return ctor;
}
async function importHLS(loader, callbacks = {}) {
  var _a2, _b, _c, _d, _e;
  if (isUndefined(loader))
    return void 0;
  (_a2 = callbacks.onLoadStart) == null ? void 0 : _a2.call(callbacks);
  if (loader.prototype && loader.prototype !== Function) {
    (_b = callbacks.onLoaded) == null ? void 0 : _b.call(callbacks, loader);
    return loader;
  }
  try {
    const ctor = (_c = await loader()) == null ? void 0 : _c.default;
    if (ctor && !!ctor.isSupported) {
      (_d = callbacks.onLoaded) == null ? void 0 : _d.call(callbacks, ctor);
    } else {
      throw Error(
        false ? "[vidstack] failed importing `hls.js`. Dynamic import returned invalid constructor." : ""
      );
    }
    return ctor;
  } catch (err) {
    (_e = callbacks.onLoadError) == null ? void 0 : _e.call(callbacks, err);
  }
  return void 0;
}
async function loadHLSScript(src, callbacks = {}) {
  var _a2, _b, _c;
  if (!isString(src))
    return void 0;
  (_a2 = callbacks.onLoadStart) == null ? void 0 : _a2.call(callbacks);
  try {
    await loadScript(src);
    if (!isFunction(window.Hls)) {
      throw Error(
        false ? "[vidstack] failed loading `hls.js`. Could not find a valid `Hls` constructor on window" : ""
      );
    }
    const ctor = window.Hls;
    (_b = callbacks.onLoaded) == null ? void 0 : _b.call(callbacks, ctor);
    return ctor;
  } catch (err) {
    (_c = callbacks.onLoadError) == null ? void 0 : _c.call(callbacks, err);
  }
  return void 0;
}
var toDOMEventType = (type) => camelToKebabCase(type);
var toHLSEventType = (type) => kebabToCamelCase(type);
function useHLS(provider, config, $ctor, $instance, { player, logger, delegate, $store }, callbacks) {
  const listening = /* @__PURE__ */ new Set();
  effect(() => {
    const ctor = $ctor();
    if (!ctor)
      return;
    const isLowLatencyStream = peek(() => $store.streamType).includes("ll-");
    const instance = new ctor({
      lowLatencyMode: isLowLatencyStream,
      ...config
    });
    effect(() => void attachEventListeners(instance, player[HLS_LISTENERS]()));
    instance.on(ctor.Events.ERROR, onError);
    $instance.set(instance);
    for (const callback of callbacks)
      callback(instance);
    dispatchEvent(player, "hls-instance", { detail: instance });
    instance.attachMedia(provider.media);
    const levelLoadedEvent = peek($ctor).Events.LEVEL_LOADED;
    instance.on(levelLoadedEvent, onLevelLoaded);
    delegate.dispatch("provider-setup", { detail: provider });
    return () => {
      listening.clear();
      instance.destroy();
      $instance.set(null);
    };
  });
  effect(() => {
    if (!$store.live)
      return;
    const instance = $instance();
    if (!instance)
      return;
    const rafLoop = createRAFLoop(() => {
      $store.liveSyncPosition = instance.liveSyncPosition ?? Infinity;
    });
    rafLoop.start();
    return rafLoop.stop;
  });
  function dispatchHLSEvent(eventType, detail) {
    player.dispatchEvent(new DOMEvent(toDOMEventType(eventType), { detail }));
  }
  function attachEventListeners(instance, listeners) {
    for (const type of listeners) {
      if (!listening.has(type)) {
        instance.on(toHLSEventType(type), dispatchHLSEvent);
        listening.add(type);
      }
    }
  }
  function onLevelLoaded(eventType, data) {
    if ($store.canPlay)
      return;
    const { type, live, totalduration: duration } = data.details;
    const event = new DOMEvent(eventType, { detail: data });
    delegate.dispatch("stream-type-change", {
      detail: live ? type === "EVENT" && Number.isFinite(duration) ? "live:dvr" : "live" : "on-demand",
      trigger: event
    });
    delegate.dispatch("duration-change", { detail: duration, trigger: event });
    const instance = $instance();
    const media = instance.media;
    media.dispatchEvent(new DOMEvent("canplay", { trigger: event }));
  }
  function onError(eventType, data) {
    var _b, _c, _d;
    if (data.fatal) {
      switch (data.type) {
        case "networkError":
          (_b = $instance()) == null ? void 0 : _b.startLoad();
          break;
        case "mediaError":
          (_c = $instance()) == null ? void 0 : _c.recoverMediaError();
          break;
        default:
          (_d = $instance()) == null ? void 0 : _d.destroy();
          $instance.set(null);
          break;
      }
    }
  }
}

// src/player/media/providers/hls/provider.ts
var HLS_PROVIDER = Symbol(0);
var JS_DELIVR_CDN = "https://cdn.jsdelivr.net";
var _a;
var HLSProvider = class extends VideoProvider {
  constructor() {
    super(...arguments);
    this[_a] = true;
    this._$ctor = signal(null);
    this._$instance = signal(null);
    this._instanceCallbacks = /* @__PURE__ */ new Set();
    this._library = `${JS_DELIVR_CDN}/npm/hls.js@^1.0.0/dist/hls${".min.js"}`;
    this.config = {};
  }
  get type() {
    return "hls";
  }
  get canLiveSync() {
    return true;
  }
  get library() {
    return this._library;
  }
  set library(library) {
    this._library = library;
  }
  preconnect() {
    if (!isString(this._library))
      return;
    preconnect(this._library);
  }
  setup(context) {
    super.setup(context);
    loadHLSLibrary(this._library, context).then((ctor) => this._$ctor.set(() => ctor));
    useHLS(this, this.config, this._$ctor, this._$instance, context, this._instanceCallbacks);
  }
  get ctor() {
    return this._$ctor();
  }
  get instance() {
    return this._$instance();
  }
  async loadSource({ src }) {
    effect(() => {
      if (!isString(src))
        return;
      const instance = this._$instance();
      instance == null ? void 0 : instance.loadSource(src);
    });
  }
  onInstance(callback) {
    const instance = peek(this._$instance);
    if (instance)
      callback(instance);
    this._instanceCallbacks.add(callback);
    return () => this._instanceCallbacks.delete(callback);
  }
};
_a = HLS_PROVIDER;
HLSProvider.supported = isHLSSupported();

export { HLSProvider, HLS_PROVIDER };
