'use strict';

var maverick_js = require('maverick.js');
var element = require('maverick.js/element');
var std = require('maverick.js/std');
var ssr = require('maverick.js/ssr');
var mediaIcons = require('media-icons');

var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
function useMedia() {
  return maverick_js.useContext(exports.mediaContext);
}
exports.mediaContext = void 0;
var init_context = __esm({
  "src/player/media/context.ts"() {
    exports.mediaContext = maverick_js.createContext();
  }
});
function useKeyboard({ $player, $store: $media, ariaKeys, remote }, { $keyShortcuts, $keyDisabled, $keyTarget }) {
  maverick_js.effect(() => {
    const player = $player();
    if (!player || $keyDisabled())
      return;
    const target = $keyTarget() === "player" ? player : document, $active = maverick_js.signal(false);
    if (target === player) {
      std.listenEvent(player, "focusin", () => $active.set(true));
      std.listenEvent(player, "focusout", (event) => {
        if (!player.contains(event.target))
          $active.set(false);
      });
    } else {
      std.listenEvent(document, "focusin", (event) => {
        const activePlayer = event.composedPath().find((el) => el instanceof Element && el.localName === "media-player");
        if (activePlayer !== void 0)
          $active.set(player === activePlayer);
      });
    }
    maverick_js.effect(() => {
      if (!$active())
        return;
      std.listenEvent(target, "keyup", onKeyUp);
      std.listenEvent(target, "keydown", onKeyDown);
    });
    let seekTotal;
    function calcSeekAmount(event, type) {
      const seekBy = event.shiftKey ? 10 : 5;
      return seekTotal = Math.max(
        0,
        Math.min(
          (seekTotal ?? $media.currentTime) + (type === "seekForward" ? +seekBy : -seekBy),
          $media.duration
        )
      );
    }
    let timeSlider = null;
    function forwardTimeKeyEvent(event) {
      timeSlider == null ? void 0 : timeSlider.dispatchEvent(new std.DOMEvent(event.type, { trigger: event }));
    }
    function seeking(event, type) {
      if (!$media.canSeek)
        return;
      if (!timeSlider)
        timeSlider = player.querySelector("media-time-slider");
      if (timeSlider) {
        forwardTimeKeyEvent(event);
      } else {
        remote.seeking(calcSeekAmount(event, type), event);
      }
    }
    function onKeyUp(event) {
      const focused = document.activeElement, sliderFocused = focused == null ? void 0 : focused.hasAttribute("data-media-slider");
      if (!event.key || !$media.canSeek || sliderFocused || (focused == null ? void 0 : focused.matches(IGNORE_SELECTORS))) {
        return;
      }
      const method = getMatchingMethod(event);
      if (method == null ? void 0 : method.startsWith("seek")) {
        event.preventDefault();
        if (timeSlider) {
          forwardTimeKeyEvent(event);
          timeSlider = null;
        } else {
          remote.seek(calcSeekAmount(event, method), event);
          seekTotal = 0;
        }
      }
      if (method == null ? void 0 : method.startsWith("volume")) {
        const volumeSlider = player.querySelector("media-volume-slider");
        volumeSlider == null ? void 0 : volumeSlider.dispatchEvent(new std.DOMEvent("keyup", { trigger: event }));
      }
    }
    function onKeyDown(event) {
      var _a4;
      if (!event.key || MODIFIER_KEYS.has(event.key))
        return;
      const focused = document.activeElement;
      if ((focused == null ? void 0 : focused.matches(IGNORE_SELECTORS)) || std.isKeyboardClick(event) && (focused == null ? void 0 : focused.matches(BUTTON_SELECTORS))) {
        return;
      }
      const sliderFocused = focused == null ? void 0 : focused.hasAttribute("data-media-slider"), method = getMatchingMethod(event);
      if (!method && /[0-9]/.test(event.key) && !sliderFocused) {
        event.preventDefault();
        remote.seek($media.duration / 10 * Number(event.key), event);
        return;
      }
      if (!method || /volume|seek/.test(method) && sliderFocused)
        return;
      event.preventDefault();
      switch (method) {
        case "seekForward":
        case "seekBackward":
          seeking(event, method);
          break;
        case "volumeUp":
        case "volumeDown":
          const volumeSlider = player.querySelector("media-volume-slider");
          if (volumeSlider) {
            volumeSlider.dispatchEvent(new std.DOMEvent("keydown", { trigger: event }));
          } else {
            const value = event.shiftKey ? 0.1 : 0.05;
            remote.changeVolume($media.volume + (method === "volumeUp" ? +value : -value), event);
          }
          break;
        case "toggleFullscreen":
          remote.toggleFullscreen("prefer-media", event);
        default:
          (_a4 = remote[method]) == null ? void 0 : _a4.call(remote, event);
      }
    }
    function getMatchingMethod(event) {
      const keyShortcuts = { ...$keyShortcuts(), ...ariaKeys };
      return Object.keys(keyShortcuts).find(
        (method) => keyShortcuts[method].split(" ").some(
          (keys) => replaceSymbolKeys(keys).replace(/Control/g, "Ctrl").split("+").every(
            (key2) => MODIFIER_KEYS.has(key2) ? event[key2.toLowerCase() + "Key"] : event.key === key2.replace("Space", " ")
          )
        )
      );
    }
  });
}
function useARIAKeyShortcuts(host, shortcut) {
  element.onAttach(() => {
    const { $keyShortcuts, ariaKeys } = useMedia(), keys = host.el.getAttribute("aria-keyshortcuts");
    if (keys) {
      ariaKeys[shortcut] = keys;
      return;
    }
    const shortcuts = $keyShortcuts()[shortcut];
    if (shortcuts)
      host.el.setAttribute("aria-keyshortcuts", shortcuts);
  });
}
function replaceSymbolKeys(key2) {
  return key2.replace(/Shift\+(\d)/g, (_, num) => SYMBOL_KEY_MAP[num - 1]);
}
exports.MEDIA_KEY_SHORTCUTS = void 0; var MODIFIER_KEYS, BUTTON_SELECTORS, IGNORE_SELECTORS, SYMBOL_KEY_MAP;
var init_keyboard = __esm({
  "src/player/element/keyboard.ts"() {
    init_context();
    exports.MEDIA_KEY_SHORTCUTS = {
      togglePaused: "k Space",
      toggleMuted: "m",
      toggleFullscreen: "f",
      seekBackward: "ArrowLeft",
      seekForward: "ArrowRight",
      volumeUp: "ArrowUp",
      volumeDown: "ArrowDown"
    };
    MODIFIER_KEYS = /* @__PURE__ */ new Set(["Shift", "Alt", "Meta", "Control"]);
    BUTTON_SELECTORS = 'button, [role="button"]';
    IGNORE_SELECTORS = 'video, input, textarea, select, [contenteditable], [role^="menuitem"]';
    SYMBOL_KEY_MAP = ["!", "@", "#", "$", "%", "^", "&", "*", "(", ")"];
  }
});
exports.MediaRemoteControl = void 0;
var init_remote_control = __esm({
  "src/player/media/remote-control.ts"() {
    exports.MediaRemoteControl = class {
      constructor(_logger) {
        this._logger = _logger;
        this._target = null;
        this._player = null;
      }
      setTarget(target) {
        this._target = target;
      }
      getPlayer(target) {
        var _a4;
        if (this._player)
          return this._player;
        (_a4 = target ?? this._target) == null ? void 0 : _a4.dispatchEvent(
          new std.DOMEvent("find-media-player", {
            detail: (player) => void (this._player = player),
            bubbles: true,
            composed: true
          })
        );
        return this._player;
      }
      setPlayer(player) {
        this._player = player;
      }
      startLoading(trigger) {
        this._dispatchRequest("media-start-loading", trigger);
      }
      play(trigger) {
        this._dispatchRequest("media-play-request", trigger);
      }
      pause(trigger) {
        this._dispatchRequest("media-pause-request", trigger);
      }
      mute(trigger) {
        this._dispatchRequest("media-mute-request", trigger);
      }
      unmute(trigger) {
        this._dispatchRequest("media-unmute-request", trigger);
      }
      enterFullscreen(target, trigger) {
        this._dispatchRequest("media-enter-fullscreen-request", trigger, target);
      }
      exitFullscreen(target, trigger) {
        this._dispatchRequest("media-exit-fullscreen-request", trigger, target);
      }
      seeking(time, trigger) {
        this._dispatchRequest("media-seeking-request", trigger, time);
      }
      seek(time, trigger) {
        this._dispatchRequest("media-seek-request", trigger, time);
      }
      seekToLiveEdge(trigger) {
        this._dispatchRequest("media-live-edge-request", trigger);
      }
      changeVolume(volume, trigger) {
        this._dispatchRequest("media-volume-change-request", trigger, Math.max(0, Math.min(1, volume)));
      }
      resumeUserIdle(trigger) {
        this._dispatchRequest("media-resume-user-idle-request", trigger);
      }
      pauseUserIdle(trigger) {
        this._dispatchRequest("media-pause-user-idle-request", trigger);
      }
      showPoster(trigger) {
        this._dispatchRequest("media-show-poster-request", trigger);
      }
      hidePoster(trigger) {
        this._dispatchRequest("media-hide-poster-request", trigger);
      }
      togglePaused(trigger) {
        const player = this.getPlayer(trigger == null ? void 0 : trigger.target);
        if (!player) {
          return;
        }
        if (player.state.paused)
          this.play(trigger);
        else
          this.pause(trigger);
      }
      toggleMuted(trigger) {
        const player = this.getPlayer(trigger == null ? void 0 : trigger.target);
        if (!player) {
          return;
        }
        if (player.state.muted)
          this.unmute(trigger);
        else
          this.mute(trigger);
      }
      toggleFullscreen(target, trigger) {
        const player = this.getPlayer(trigger == null ? void 0 : trigger.target);
        if (!player) {
          return;
        }
        if (player.state.fullscreen)
          this.exitFullscreen(target, trigger);
        else
          this.enterFullscreen(target, trigger);
      }
      _dispatchRequest(type, trigger, detail) {
        const request = new std.DOMEvent(type, {
          bubbles: true,
          composed: true,
          detail,
          trigger
        });
        const target = (trigger == null ? void 0 : trigger.target) === document || (trigger == null ? void 0 : trigger.target) === window || (trigger == null ? void 0 : trigger.target) === document.body ? this._target ?? this.getPlayer() : (trigger == null ? void 0 : trigger.target) ?? this._target;
        target == null ? void 0 : target.dispatchEvent(request);
      }
      _noPlayerWarning(method) {
      }
    };
  }
});
function getRange(fnName, valueIndex, ranges, rangeIndex) {
  return ranges[rangeIndex][valueIndex] || Infinity;
}
function buildTimeRanges(ranges) {
  if (std.isUndefined(ranges) || ranges.length === 0) {
    return { length: 0, start: emptyTimeRange, end: emptyTimeRange };
  }
  return {
    length: ranges.length,
    start: getRange.bind(null, "start", 0, ranges),
    end: getRange.bind(null, "end", 1, ranges)
  };
}
function createTimeRanges(start, end) {
  if (std.isArray(start)) {
    return buildTimeRanges(start);
  } else if (std.isUndefined(start) || std.isUndefined(end)) {
    return buildTimeRanges();
  }
  return buildTimeRanges([[start, end]]);
}
function getTimeRangesStart(ranges) {
  if (!ranges.length)
    return null;
  let min = ranges.start(0);
  for (let i = 1; i < ranges.length; i++) {
    const value = ranges.start(i);
    if (value < min)
      min = value;
  }
  return min;
}
function getTimeRangesEnd(ranges) {
  if (!ranges.length)
    return null;
  let max = ranges.end(0);
  for (let i = 1; i < ranges.length; i++) {
    const value = ranges.end(i);
    if (value > max)
      max = value;
  }
  return max;
}
function emptyTimeRange() {
  throw new Error("empty");
}
var init_time_ranges = __esm({
  "src/player/media/time-ranges.ts"() {
  }
});
function softResetMediaStore($media) {
  exports.mediaStore.reset($media, (prop) => !DO_NOT_RESET_ON_SRC_CHANGE.has(prop));
  maverick_js.tick();
}
exports.mediaStore = void 0; var DO_NOT_RESET_ON_SRC_CHANGE;
var init_store = __esm({
  "src/player/media/store.ts"() {
    init_time_ranges();
    exports.mediaStore = maverick_js.createStore({
      autoplay: false,
      autoplayError: void 0,
      buffered: createTimeRanges(),
      duration: 0,
      canLoad: false,
      canFullscreen: false,
      canPlay: false,
      controls: false,
      poster: "",
      currentTime: 0,
      ended: false,
      error: void 0,
      fullscreen: false,
      loop: false,
      logLevel: "silent",
      mediaType: "unknown",
      muted: false,
      paused: true,
      played: createTimeRanges(),
      playing: false,
      playsinline: false,
      preload: "metadata",
      seekable: createTimeRanges(),
      seeking: false,
      source: { src: "", type: "" },
      sources: [],
      started: false,
      volume: 1,
      waiting: false,
      get viewType() {
        return this.providedViewType !== "unknown" ? this.providedViewType : this.mediaType;
      },
      get streamType() {
        return this.providedStreamType !== "unknown" ? this.providedStreamType : this.inferredStreamType;
      },
      get currentSrc() {
        return this.source;
      },
      get bufferedStart() {
        return getTimeRangesStart(this.buffered) ?? 0;
      },
      get bufferedEnd() {
        return getTimeRangesEnd(this.buffered) ?? 0;
      },
      get seekableStart() {
        return getTimeRangesStart(this.seekable) ?? 0;
      },
      get seekableEnd() {
        return this.canPlay ? getTimeRangesEnd(this.seekable) ?? Infinity : 0;
      },
      get seekableWindow() {
        return Math.max(0, this.seekableEnd - this.seekableStart);
      },
      userIdle: false,
      userBehindLiveEdge: false,
      liveEdgeTolerance: 10,
      minLiveDVRWindow: 60,
      get canSeek() {
        return /unknown|on-demand|:dvr/.test(this.streamType) && Number.isFinite(this.seekableWindow) && (!this.live || /:dvr/.test(this.streamType) && this.seekableWindow >= this.minLiveDVRWindow);
      },
      get live() {
        return this.streamType.includes("live") || !Number.isFinite(this.duration);
      },
      get liveEdgeStart() {
        return this.live && Number.isFinite(this.seekableEnd) ? Math.max(0, (this.liveSyncPosition ?? this.seekableEnd) - this.liveEdgeTolerance) : 0;
      },
      get liveEdge() {
        return this.live && (!this.canSeek || !this.userBehindLiveEdge && this.currentTime >= this.liveEdgeStart);
      },
      get liveEdgeWindow() {
        return this.live && Number.isFinite(this.seekableEnd) ? this.seekableEnd - this.liveEdgeStart : 0;
      },
      attemptingAutoplay: false,
      canLoadPoster: null,
      providedViewType: "unknown",
      providedStreamType: "unknown",
      inferredStreamType: "unknown",
      liveSyncPosition: null
    });
    DO_NOT_RESET_ON_SRC_CHANGE = /* @__PURE__ */ new Set([
      "autoplay",
      "canFullscreen",
      "canLoad",
      "controls",
      "loop",
      "logLevel",
      "muted",
      "playsinline",
      "preload",
      "poster",
      "source",
      "sources",
      "volume",
      "canLoadPoster",
      "providedStreamType",
      "providedViewType"
    ]);
  }
});
function isHLSSrc({ src, type }) {
  return std.isString(src) && HLS_VIDEO_EXTENSIONS.test(src) || HLS_VIDEO_TYPES.has(type);
}
var AUDIO_EXTENSIONS, AUDIO_TYPES, VIDEO_EXTENSIONS, VIDEO_TYPES, HLS_VIDEO_EXTENSIONS, HLS_VIDEO_TYPES;
var init_mime = __esm({
  "src/utils/mime.ts"() {
    AUDIO_EXTENSIONS = /\.(m4a|m4b|mp4a|mpga|mp2|mp2a|mp3|m2a|m3a|wav|weba|aac|oga|spx)($|\?)/i;
    AUDIO_TYPES = /* @__PURE__ */ new Set([
      "audio/mpeg",
      "audio/ogg",
      "audio/3gp",
      "audio/mp4",
      "audio/webm",
      "audio/flac"
    ]);
    VIDEO_EXTENSIONS = /\.(mp4|og[gv]|webm|mov|m4v)(#t=[,\d+]+)?($|\?)/i;
    VIDEO_TYPES = /* @__PURE__ */ new Set([
      "video/mp4",
      "video/webm",
      "video/3gp",
      "video/ogg",
      "video/avi",
      "video/mpeg"
    ]);
    HLS_VIDEO_EXTENSIONS = /\.(m3u8)($|\?)/i;
    HLS_VIDEO_TYPES = /* @__PURE__ */ new Set([
      "application/vnd.apple.mpegurl",
      "audio/mpegurl",
      "audio/x-mpegurl",
      "application/x-mpegurl",
      "video/x-mpegurl",
      "video/mpegurl",
      "application/mpegurl"
    ]);
  }
});
function createRAFLoop(callback) {
  let id;
  function start() {
    if (!std.isUndefined(id))
      return;
    loop();
  }
  function loop() {
    id = window.requestAnimationFrame(function rafLoop() {
      if (std.isUndefined(id))
        return;
      callback();
      loop();
    });
  }
  function stop() {
    if (std.isNumber(id))
      window.cancelAnimationFrame(id);
    id = void 0;
  }
  return {
    start,
    stop
  };
}
var init_raf_loop = __esm({
  "src/foundation/hooks/raf-loop.ts"() {
  }
});

// src/utils/number.ts
function round(num, decimalPlaces = 2) {
  return Number(num.toFixed(decimalPlaces));
}
function getNumberOfDecimalPlaces(num) {
  var _a4;
  return ((_a4 = String(num).split(".")[1]) == null ? void 0 : _a4.length) ?? 0;
}
function clampNumber(min, value, max) {
  return Math.max(min, Math.min(max, value));
}
var init_number = __esm({
  "src/utils/number.ts"() {
  }
});
function canOrientScreen() {
  return false;
}
function isHLSSupported() {
  return false;
}
var IS_IOS, IS_SAFARI;
var init_support = __esm({
  "src/utils/support.ts"() {
    IS_IOS = false;
    IS_SAFARI = false;
  }
});
function useHTMLMediaElementEvents(provider, { player, $store: $media, delegate, logger }) {
  const disposal = std.useDisposalBin();
  let isMediaWaiting = false, attachedLoadStartEventListeners = false, attachedCanPlayEventListeners = false;
  const timeRafLoop = createRAFLoop(() => {
    const newTime = provider.currentTime;
    if ($media.currentTime !== newTime)
      updateCurrentTime(newTime);
  });
  attachInitialEventListeners();
  maverick_js.onDispose(() => {
    timeRafLoop.stop();
    disposal.empty();
  });
  function attachMediaEventListener(eventType, handler) {
    return std.listenEvent(
      provider.media,
      eventType,
      handler
    );
  }
  function attachInitialEventListeners() {
    attachMediaEventListener("loadstart", onLoadStart);
    attachMediaEventListener("abort", onAbort);
    attachMediaEventListener("emptied", onEmptied);
    attachMediaEventListener("error", onError);
  }
  function attachLoadStartEventListeners() {
    if (attachedLoadStartEventListeners)
      return;
    disposal.add(
      attachMediaEventListener("loadeddata", onLoadedData),
      attachMediaEventListener("loadedmetadata", onLoadedMetadata),
      attachMediaEventListener("canplay", onCanPlay),
      attachMediaEventListener("canplaythrough", onCanPlayThrough),
      attachMediaEventListener("durationchange", onDurationChange),
      attachMediaEventListener("play", onPlay),
      attachMediaEventListener("progress", onProgress),
      attachMediaEventListener("stalled", onStalled),
      attachMediaEventListener("suspend", onSuspend)
    );
    attachedLoadStartEventListeners = true;
  }
  function attachCanPlayEventListeners() {
    if (attachedCanPlayEventListeners)
      return;
    disposal.add(
      attachMediaEventListener("pause", onPause),
      attachMediaEventListener("playing", onPlaying),
      attachMediaEventListener("ratechange", onRateChange),
      attachMediaEventListener("seeked", onSeeked),
      attachMediaEventListener("seeking", onSeeking),
      attachMediaEventListener("ended", onEnded),
      attachMediaEventListener("volumechange", onVolumeChange),
      attachMediaEventListener("waiting", onWaiting)
    );
    attachedCanPlayEventListeners = true;
  }
  function updateCurrentTime(newTime, trigger) {
    delegate.dispatch("time-update", {
      detail: {
        currentTime: Math.min(newTime, $media.seekableEnd),
        played: provider.media.played
      },
      trigger
    });
  }
  function onAbort(event) {
    delegate.dispatch("abort", { trigger: event });
  }
  function onLoadStart(event) {
    if (provider.media.networkState === 3) {
      onAbort(event);
      return;
    }
    attachLoadStartEventListeners();
    delegate.dispatch("load-start", { trigger: event });
  }
  function onEmptied(event) {
    delegate.dispatch("emptied", { trigger: event });
  }
  function onLoadedData(event) {
    delegate.dispatch("loaded-data", { trigger: event });
  }
  function onLoadedMetadata(event) {
    onStreamTypeChange();
    attachCanPlayEventListeners();
    delegate.dispatch("volume-change", {
      detail: { volume: provider.media.volume, muted: provider.media.muted }
    });
    delegate.dispatch("loaded-metadata", { trigger: event });
    if (IS_SAFARI && isHLSSrc($media.source)) {
      delegate.ready(getCanPlayDetail(), event);
    }
  }
  function getCanPlayDetail() {
    return {
      duration: provider.media.duration,
      buffered: provider.media.buffered,
      seekable: provider.media.seekable
    };
  }
  function onStreamTypeChange() {
    if ($media.streamType !== "unknown")
      return;
    const isLive = !Number.isFinite(provider.media.duration);
    delegate.dispatch("stream-type-change", {
      detail: isLive ? "live" : "on-demand"
    });
  }
  function onPlay(event) {
    delegate.dispatch("play", { trigger: event });
  }
  function onPause(event) {
    if (provider.media.readyState === 1 && !isMediaWaiting)
      return;
    isMediaWaiting = false;
    timeRafLoop.stop();
    delegate.dispatch("pause", { trigger: event });
  }
  function onCanPlay(event) {
    delegate.ready(getCanPlayDetail(), event);
  }
  function onCanPlayThrough(event) {
    if ($media.started)
      return;
    delegate.dispatch("can-play-through", {
      trigger: event,
      detail: getCanPlayDetail()
    });
  }
  function onPlaying(event) {
    isMediaWaiting = false;
    delegate.dispatch("playing", { trigger: event });
    timeRafLoop.start();
  }
  function onStalled(event) {
    delegate.dispatch("stalled", { trigger: event });
    if (provider.media.readyState < 3) {
      isMediaWaiting = true;
      delegate.dispatch("waiting", { trigger: event });
    }
  }
  function onWaiting(event) {
    if (provider.media.readyState < 3) {
      isMediaWaiting = true;
      delegate.dispatch("waiting", { trigger: event });
    }
  }
  function onEnded(event) {
    timeRafLoop.stop();
    updateCurrentTime(provider.media.duration, event);
    delegate.dispatch("end", { trigger: event });
    if ($media.loop) {
      onLoop();
    } else {
      delegate.dispatch("ended", { trigger: event });
    }
  }
  function onDurationChange(event) {
    if ($media.ended)
      updateCurrentTime(provider.media.duration, event);
    delegate.dispatch("duration-change", {
      detail: provider.media.duration,
      trigger: event
    });
  }
  function onVolumeChange(event) {
    delegate.dispatch("volume-change", {
      detail: {
        volume: provider.media.volume,
        muted: provider.media.muted
      },
      trigger: event
    });
  }
  function onSeeked(event) {
    delegate.dispatch("seeked", {
      detail: provider.media.currentTime,
      trigger: event
    });
    if (Math.trunc(provider.media.currentTime) === Math.trunc(provider.media.duration) && getNumberOfDecimalPlaces(provider.media.duration) > getNumberOfDecimalPlaces(provider.media.currentTime)) {
      updateCurrentTime(provider.media.duration, event);
      if (!provider.media.ended) {
        std.dispatchEvent(player, "media-play-request", { trigger: event });
      }
    }
  }
  function onSeeking(event) {
    delegate.dispatch("seeking", {
      detail: provider.media.currentTime,
      trigger: event
    });
  }
  function onProgress(event) {
    delegate.dispatch("progress", {
      detail: {
        buffered: provider.media.buffered,
        seekable: provider.media.seekable
      },
      trigger: event
    });
  }
  function onLoop() {
    const hasCustomControls = std.isNil(provider.media.controls);
    if (hasCustomControls)
      provider.media.controls = false;
    std.dispatchEvent(player, "media-loop-request");
  }
  function onSuspend(event) {
    delegate.dispatch("suspend", { trigger: event });
  }
  function onRateChange(event) {
  }
  function onError(event) {
    const mediaError = provider.media.error;
    if (!mediaError)
      return;
    delegate.dispatch("error", {
      detail: {
        message: mediaError.message,
        code: mediaError.code,
        mediaError
      },
      trigger: event
    });
  }
}
var init_use_events = __esm({
  "src/player/media/providers/html/use-events.ts"() {
    init_raf_loop();
    init_mime();
    init_number();
    init_support();
  }
});
var HTMLMediaProvider;
var init_provider = __esm({
  "src/player/media/providers/html/provider.ts"() {
    init_mime();
    init_use_events();
    HTMLMediaProvider = class {
      constructor(_media) {
        this._media = _media;
      }
      setup(context) {
        useHTMLMediaElementEvents(this, context);
      }
      get type() {
        return "";
      }
      get media() {
        return this._media;
      }
      get paused() {
        return this._media.paused;
      }
      get muted() {
        return this._media.muted;
      }
      set muted(muted) {
        this._media.muted = muted;
      }
      get volume() {
        return this._media.volume;
      }
      set volume(volume) {
        this._media.volume = volume;
      }
      get currentTime() {
        return this._media.currentTime;
      }
      set currentTime(time) {
        this._media.currentTime = time;
      }
      get playsinline() {
        return this._media.hasAttribute("playsinline");
      }
      set playsinline(playsinline) {
        std.setAttribute(this._media, "playsinline", playsinline);
      }
      async play() {
        return this._media.play();
      }
      async pause() {
        return this._media.pause();
      }
      async loadSource({ src }, preload) {
        this._media.preload = preload;
        {
          this._media.srcObject = null;
          this._media.src = std.isString(src) ? src : window.URL.createObjectURL(src);
        }
        this._media.load();
      }
    };
  }
});

// src/player/media/providers/audio/provider.ts
var provider_exports = {};
__export(provider_exports, {
  AUDIO_PROVIDER: () => AUDIO_PROVIDER,
  AudioProvider: () => AudioProvider
});
var AUDIO_PROVIDER, _a, AudioProvider;
var init_provider2 = __esm({
  "src/player/media/providers/audio/provider.ts"() {
    init_provider();
    AUDIO_PROVIDER = Symbol(0);
    AudioProvider = class extends HTMLMediaProvider {
      constructor() {
        super(...arguments);
        this[_a] = true;
      }
      get type() {
        return "audio";
      }
      setup(context) {
        super.setup(context);
        if (this.type === "audio")
          context.delegate.dispatch("provider-setup", { detail: this });
      }
      get audio() {
        return this._media;
      }
    };
    _a = AUDIO_PROVIDER;
  }
});
function preconnect(url, rel = "preconnect") {
  return false;
}
function loadScript(src) {
  if (pendingRequests[src])
    return pendingRequests[src].promise;
  const promise = std.deferredPromise(), exists = document.querySelector(`script[src="${src}"]`);
  if (!std.isNull(exists)) {
    promise.resolve();
    return promise.promise;
  }
  const script = document.createElement("script");
  script.src = src;
  script.onload = () => {
    promise.resolve();
    delete pendingRequests[src];
  };
  script.onerror = () => {
    promise.reject();
    delete pendingRequests[src];
  };
  setTimeout(() => document.head.append(script), 0);
  return promise.promise;
}
var pendingRequests;
var init_network = __esm({
  "src/utils/network.ts"() {
    pendingRequests = {};
  }
});
function useVideoPresentation(video, { $player, logger, delegate }) {
  const $mode = maverick_js.signal("inline"), $supported = () => std.isFunction(video.webkitSetPresentationMode);
  if ($supported()) {
    std.listenEvent(video, "webkitpresentationmodechanged", onPresentationModeChange);
  }
  function onPresentationModeChange(event) {
    $mode.set(video.webkitPresentationMode);
    std.dispatchEvent($player(), "video-presentation-change", {
      detail: $mode(),
      trigger: event
    });
    delegate.dispatch("fullscreen-change", {
      detail: $mode() === "fullscreen",
      trigger: event
    });
  }
  return {
    get mode() {
      return $mode();
    },
    get active() {
      return $mode() === "fullscreen";
    },
    get supported() {
      return maverick_js.peek($supported);
    },
    async enter() {
      if (maverick_js.peek($mode) === "fullscreen")
        return;
      await video.webkitSetPresentationMode("fullscreen");
    },
    async exit() {
      if (maverick_js.peek($mode) === "inline")
        return;
      await video.webkitSetPresentationMode("inline");
    }
  };
}
var init_use_video_presentation = __esm({
  "src/player/media/providers/video/presentation/use-video-presentation.ts"() {
  }
});

// src/player/media/providers/video/provider.ts
var provider_exports2 = {};
__export(provider_exports2, {
  VIDEO_PROVIDER: () => VIDEO_PROVIDER,
  VideoProvider: () => VideoProvider
});
var VIDEO_PROVIDER, _a2, VideoProvider;
var init_provider3 = __esm({
  "src/player/media/providers/video/provider.ts"() {
    init_provider();
    init_use_video_presentation();
    VIDEO_PROVIDER = Symbol(0);
    VideoProvider = class extends HTMLMediaProvider {
      constructor(media, context) {
        super(media);
        this[_a2] = true;
        this.fullscreen = useVideoPresentation(media, context);
      }
      get type() {
        return "video";
      }
      setup(context) {
        super.setup(context);
        if (this.type === "video")
          context.delegate.dispatch("provider-setup", { detail: this });
      }
      get video() {
        return this._media;
      }
    };
    _a2 = VIDEO_PROVIDER;
  }
});

// src/utils/error.ts
function coerceToError(error) {
  return error instanceof Error ? error : Error(JSON.stringify(error));
}
var init_error = __esm({
  "src/utils/error.ts"() {
  }
});
async function loadHLSLibrary(lib, { player, delegate, logger }) {
  const callbacks = {
    onLoadStart() {
      std.dispatchEvent(player, "hls-lib-load-start");
    },
    onLoaded(ctor2) {
      std.dispatchEvent(player, "hls-lib-loaded", { detail: ctor2 });
    },
    onLoadError(e) {
      const error = coerceToError(e);
      std.dispatchEvent(player, "hls-lib-load-error", { detail: error });
      delegate.dispatch("error", { detail: { message: error.message, code: 4 } });
    }
  };
  let ctor = await loadHLSScript(lib, callbacks);
  if (std.isUndefined(ctor) && !std.isString(lib))
    ctor = await importHLS(lib, callbacks);
  if (!ctor)
    return null;
  if (!ctor.isSupported()) {
    const message = "[vidstack]: `hls.js` is not supported in this environment";
    std.dispatchEvent(player, "hls-unsupported");
    delegate.dispatch("error", { detail: { message, code: 4 } });
    return null;
  }
  return ctor;
}
async function importHLS(loader, callbacks = {}) {
  var _a4, _b, _c, _d, _e;
  if (std.isUndefined(loader))
    return void 0;
  (_a4 = callbacks.onLoadStart) == null ? void 0 : _a4.call(callbacks);
  if (loader.prototype && loader.prototype !== Function) {
    (_b = callbacks.onLoaded) == null ? void 0 : _b.call(callbacks, loader);
    return loader;
  }
  try {
    const ctor = (_c = await loader()) == null ? void 0 : _c.default;
    if (ctor && !!ctor.isSupported) {
      (_d = callbacks.onLoaded) == null ? void 0 : _d.call(callbacks, ctor);
    } else {
      throw Error(
        false ? "[vidstack] failed importing `hls.js`. Dynamic import returned invalid constructor." : ""
      );
    }
    return ctor;
  } catch (err) {
    (_e = callbacks.onLoadError) == null ? void 0 : _e.call(callbacks, err);
  }
  return void 0;
}
async function loadHLSScript(src, callbacks = {}) {
  var _a4, _b, _c;
  if (!std.isString(src))
    return void 0;
  (_a4 = callbacks.onLoadStart) == null ? void 0 : _a4.call(callbacks);
  try {
    await loadScript(src);
    if (!std.isFunction(window.Hls)) {
      throw Error(
        false ? "[vidstack] failed loading `hls.js`. Could not find a valid `Hls` constructor on window" : ""
      );
    }
    const ctor = window.Hls;
    (_b = callbacks.onLoaded) == null ? void 0 : _b.call(callbacks, ctor);
    return ctor;
  } catch (err) {
    (_c = callbacks.onLoadError) == null ? void 0 : _c.call(callbacks, err);
  }
  return void 0;
}
var init_lib_loader = __esm({
  "src/player/media/providers/hls/lib-loader.ts"() {
    init_error();
    init_network();
  }
});

// ../../node_modules/.pnpm/just-throttle@4.2.0/node_modules/just-throttle/index.mjs
function throttle(fn, interval, options) {
  var timeoutId = null;
  var throttledFn = null;
  var leading = options && options.leading;
  var trailing = options && options.trailing;
  if (leading == null) {
    leading = true;
  }
  if (trailing == null) {
    trailing = !leading;
  }
  if (leading == true) {
    trailing = false;
  }
  var cancel = function() {
    if (timeoutId) {
      clearTimeout(timeoutId);
      timeoutId = null;
    }
  };
  var flush = function() {
    var call = throttledFn;
    cancel();
    if (call) {
      call();
    }
  };
  var throttleWrapper = function() {
    var callNow = leading && !timeoutId;
    var context = this;
    var args = arguments;
    throttledFn = function() {
      return fn.apply(context, args);
    };
    if (!timeoutId) {
      timeoutId = setTimeout(function() {
        timeoutId = null;
        if (trailing) {
          return throttledFn();
        }
      }, interval);
    }
    if (callNow) {
      callNow = false;
      return throttledFn();
    }
  };
  throttleWrapper.cancel = cancel;
  throttleWrapper.flush = flush;
  return throttleWrapper;
}
var functionThrottle;
var init_just_throttle = __esm({
  "../../node_modules/.pnpm/just-throttle@4.2.0/node_modules/just-throttle/index.mjs"() {
    functionThrottle = throttle;
  }
});
function useFocusVisible($target) {
  const $focused = maverick_js.signal(false);
  element.onConnect(() => {
    const target = $target();
    maverick_js.effect(() => {
      if (!$keyboard()) {
        $focused.set(false);
        updateFocusAttr(target, false);
        std.listenEvent(target, "pointerenter", () => updateHoverAttr(target, true));
        std.listenEvent(target, "pointerleave", () => updateHoverAttr(target, false));
        return;
      }
      const active = document.activeElement === target;
      $focused.set(active);
      updateFocusAttr(target, active);
      std.listenEvent(target, "focus", () => {
        $focused.set(true);
        updateFocusAttr(target, true);
      });
      std.listenEvent(target, "blur", () => {
        $focused.set(false);
        updateFocusAttr(target, false);
      });
    });
  });
  return $focused;
}
function updateFocusAttr(target, isFocused) {
  std.setAttribute(target, "data-focus", isFocused);
  std.setAttribute(target, "data-hocus", isFocused);
}
function updateHoverAttr(target, isHovering) {
  std.setAttribute(target, "data-hocus", isHovering);
}
var $keyboard;
var init_use_focus_visible = __esm({
  "src/foundation/observers/use-focus-visible.ts"() {
    $keyboard = maverick_js.signal(false);
  }
});
var init_intersection_observer = __esm({
  "src/foundation/observers/intersection-observer.ts"() {
  }
});
function useMediaCanLoad($controller, $load, callback) {
  return;
}
var init_can_load = __esm({
  "src/player/media/controller/can-load.ts"() {
    init_intersection_observer();
  }
});
function createMediaControllerDelegate({ $player, $store, logger }, handle) {
  {
    return {
      dispatch: std.noop,
      ready: std.noop
    };
  }
}
var init_controller_delegate = __esm({
  "src/player/media/controller/controller-delegate.ts"() {
  }
});
var init_prop_change = __esm({
  "src/player/media/controller/prop-change.ts"() {
  }
});
var RequestQueue;
var init_request_queue = __esm({
  "src/foundation/queue/request-queue.ts"() {
    RequestQueue = class {
      constructor() {
        this._serving = false;
        this._pending = std.deferredPromise();
        this._queue = /* @__PURE__ */ new Map();
      }
      get _size() {
        return this._queue.size;
      }
      get _isServing() {
        return this._serving;
      }
      async _waitForFlush() {
        if (this._serving)
          return;
        await this._pending.promise;
      }
      _enqueue(key2, callback) {
        if (this._serving) {
          callback();
          return;
        }
        this._queue.delete(key2);
        this._queue.set(key2, callback);
      }
      _serve(key2) {
        var _a4;
        (_a4 = this._queue.get(key2)) == null ? void 0 : _a4();
        this._queue.delete(key2);
      }
      _start() {
        this._flush();
        this._serving = true;
        if (this._queue.size > 0)
          this._flush();
      }
      _stop() {
        this._serving = false;
      }
      _reset() {
        this._stop();
        this._queue.clear();
        this._release();
      }
      _flush() {
        for (const key2 of this._queue.keys())
          this._serve(key2);
        this._release();
      }
      _release() {
        this._pending.resolve();
        this._pending = std.deferredPromise();
      }
    };
  }
});
function useMediaProviderDelegate({ $provider, $store: $media }, requestManager, { $paused, $volume, $muted, $currentTime, $playsinline }) {
  const canPlayQueue = new RequestQueue();
  maverick_js.effect(() => {
    if ($media.canPlay && $provider())
      canPlayQueue._start();
    else
      canPlayQueue._stop();
  });
  maverick_js.effect(() => setMuted($muted()));
  maverick_js.effect(() => setPaused($paused()));
  maverick_js.effect(() => setVolume($volume()));
  maverick_js.effect(() => setCurrentTime($currentTime()));
  maverick_js.effect(() => setPlaysinline($playsinline()));
  function setPaused(paused) {
    if (paused)
      canPlayQueue._enqueue("paused", requestManager._pause);
    else
      canPlayQueue._enqueue("paused", requestManager._play);
  }
  function setVolume(volume) {
    const newVolume = clampNumber(0, volume, 1);
    canPlayQueue._enqueue("volume", () => $provider().volume = newVolume);
  }
  function setMuted(muted) {
    canPlayQueue._enqueue("muted", () => $provider().muted = muted);
  }
  function setCurrentTime(currentTime) {
    canPlayQueue._enqueue("currentTime", () => {
      const adapter = $provider();
      if (currentTime !== adapter.currentTime) {
        maverick_js.peek(() => {
          const boundTime = Math.min(
            Math.max($media.seekableStart + 0.1, currentTime),
            $media.seekableEnd - 0.1
          );
          if (Number.isFinite(boundTime))
            adapter.currentTime = boundTime;
        });
      }
    });
  }
  function setPlaysinline(playsinline) {
    canPlayQueue._enqueue("playsinline", () => $provider().playsinline = playsinline);
  }
  const delegate = {};
  const setters = {
    paused: setPaused,
    muted: setMuted,
    volume: setVolume,
    currentTime: setCurrentTime,
    playsinline: setPlaysinline
  };
  for (const prop of Object.keys(setters)) {
    Object.defineProperty(delegate, prop, {
      get: () => $media[prop],
      set: setters[prop]
    });
  }
  return delegate;
}
var init_provider_delegate = __esm({
  "src/player/media/controller/provider-delegate.ts"() {
    init_request_queue();
    init_number();
  }
});

// ../../node_modules/.pnpm/fscreen@1.2.0/node_modules/fscreen/dist/fscreen.esm.js
var key, webkit, moz, ms, document2, vendor, fscreen, fscreen_esm_default;
var init_fscreen_esm = __esm({
  "../../node_modules/.pnpm/fscreen@1.2.0/node_modules/fscreen/dist/fscreen.esm.js"() {
    key = {
      fullscreenEnabled: 0,
      fullscreenElement: 1,
      requestFullscreen: 2,
      exitFullscreen: 3,
      fullscreenchange: 4,
      fullscreenerror: 5,
      fullscreen: 6
    };
    webkit = [
      "webkitFullscreenEnabled",
      "webkitFullscreenElement",
      "webkitRequestFullscreen",
      "webkitExitFullscreen",
      "webkitfullscreenchange",
      "webkitfullscreenerror",
      "-webkit-full-screen"
    ];
    moz = [
      "mozFullScreenEnabled",
      "mozFullScreenElement",
      "mozRequestFullScreen",
      "mozCancelFullScreen",
      "mozfullscreenchange",
      "mozfullscreenerror",
      "-moz-full-screen"
    ];
    ms = [
      "msFullscreenEnabled",
      "msFullscreenElement",
      "msRequestFullscreen",
      "msExitFullscreen",
      "MSFullscreenChange",
      "MSFullscreenError",
      "-ms-fullscreen"
    ];
    document2 = typeof window !== "undefined" && typeof window.document !== "undefined" ? window.document : {};
    vendor = "fullscreenEnabled" in document2 && Object.keys(key) || webkit[0] in document2 && webkit || moz[0] in document2 && moz || ms[0] in document2 && ms || [];
    fscreen = {
      requestFullscreen: function(element) {
        return element[vendor[key.requestFullscreen]]();
      },
      requestFullscreenFunction: function(element) {
        return element[vendor[key.requestFullscreen]];
      },
      get exitFullscreen() {
        return document2[vendor[key.exitFullscreen]].bind(document2);
      },
      get fullscreenPseudoClass() {
        return ":" + vendor[key.fullscreen];
      },
      addEventListener: function(type, handler, options) {
        return document2.addEventListener(vendor[key[type]], handler, options);
      },
      removeEventListener: function(type, handler, options) {
        return document2.removeEventListener(vendor[key[type]], handler, options);
      },
      get fullscreenEnabled() {
        return Boolean(document2[vendor[key.fullscreenEnabled]]);
      },
      set fullscreenEnabled(val) {
      },
      get fullscreenElement() {
        return document2[vendor[key.fullscreenElement]];
      },
      set fullscreenElement(val) {
      },
      get onfullscreenchange() {
        return document2[("on" + vendor[key.fullscreenchange]).toLowerCase()];
      },
      set onfullscreenchange(handler) {
        return document2[("on" + vendor[key.fullscreenchange]).toLowerCase()] = handler;
      },
      get onfullscreenerror() {
        return document2[("on" + vendor[key.fullscreenerror]).toLowerCase()];
      },
      set onfullscreenerror(handler) {
        return document2[("on" + vendor[key.fullscreenerror]).toLowerCase()] = handler;
      }
    };
    fscreen_esm_default = fscreen;
  }
});
function createFullscreenAdapter($target) {
  const $active = maverick_js.signal(false), exit = () => exitFullscreen(maverick_js.peek($target));
  let listening = false;
  maverick_js.effect(() => {
    const target = $target();
    if (target) {
      std.listenEvent(fscreen_esm_default, "fullscreenchange", async (trigger) => {
        const active = isFullscreen(target);
        if (active === $active())
          return;
        if (!active)
          listening = false;
        $active.set(active);
        std.dispatchEvent(target, "fullscreen-change", { detail: active, trigger });
      });
      std.listenEvent(fscreen_esm_default, "fullscreenerror", (trigger) => {
        if (!listening)
          return;
        std.dispatchEvent(target, "fullscreen-error", { detail: null, trigger });
        listening = false;
      });
      return async () => {
        if (canFullscreen())
          await exit();
      };
    }
    return;
  });
  return {
    get active() {
      return $active();
    },
    get supported() {
      return canFullscreen();
    },
    async enter() {
      try {
        listening = true;
        return await requestFullscreen(maverick_js.peek($target));
      } catch (error) {
        listening = false;
        throw error;
      }
    },
    exit
  };
}
function canFullscreen() {
  return fscreen_esm_default.fullscreenEnabled;
}
function isFullscreen(host) {
  if (fscreen_esm_default.fullscreenElement === host)
    return true;
  try {
    return host.matches(
      fscreen_esm_default.fullscreenPseudoClass
    );
  } catch (error) {
    return false;
  }
}
async function requestFullscreen(host) {
  if (!host || isFullscreen(host))
    return;
  assertFullscreenAPI();
  return fscreen_esm_default.requestFullscreen(host);
}
async function exitFullscreen(host) {
  if (!host || !isFullscreen(host))
    return;
  assertFullscreenAPI();
  return fscreen_esm_default.exitFullscreen();
}
function assertFullscreenAPI() {
  if (canFullscreen())
    return;
  throw Error(
    "[vidstack] no fullscreen API"
  );
}
var init_fullscreen = __esm({
  "src/foundation/fullscreen/fullscreen.ts"() {
    init_fscreen_esm();
  }
});
function createScreenOrientationAdapter($target) {
  const $orientation = maverick_js.signal(getScreenOrientation()), $locked = maverick_js.signal(false);
  let currentLock;
  if (CAN_ORIENT_SCREEN) {
    maverick_js.effect(() => {
      const target = $target();
      if (!target)
        return;
      std.listenEvent(screen.orientation, "change", (trigger) => {
        const orientation = getScreenOrientation();
        $orientation.set(orientation);
        std.dispatchEvent(target, "orientation-change", {
          detail: { orientation, lock: currentLock },
          trigger
        });
      });
      return async () => {
        if (CAN_ORIENT_SCREEN && $locked())
          await unlock();
      };
    });
  }
  async function lock(lockType) {
    if (maverick_js.peek($locked))
      return;
    assertScreenOrientationAPI();
    await screen.orientation.lock(lockType);
    $locked.set(true);
    currentLock = lockType;
  }
  async function unlock() {
    if (!maverick_js.peek($locked))
      return;
    assertScreenOrientationAPI();
    currentLock = void 0;
    await screen.orientation.unlock();
    $locked.set(false);
  }
  return {
    get orientation() {
      return $orientation();
    },
    get locked() {
      return $locked();
    },
    get supported() {
      return CAN_ORIENT_SCREEN;
    },
    lock,
    unlock
  };
}
function assertScreenOrientationAPI() {
  if (!CAN_ORIENT_SCREEN)
    return;
  throw Error(
    "[vidstack] no orientation API"
  );
}
function getScreenOrientation() {
  return void 0 ;
}
var CAN_ORIENT_SCREEN;
var init_screen_orientation = __esm({
  "src/foundation/orientation/screen-orientation.ts"() {
    init_support();
    CAN_ORIENT_SCREEN = canOrientScreen();
  }
});

// src/foundation/queue/queue.ts
var Queue;
var init_queue = __esm({
  "src/foundation/queue/queue.ts"() {
    Queue = class {
      constructor() {
        this._queue = /* @__PURE__ */ new Map();
      }
      _enqueue(key2, item) {
        if (!this._queue.has(key2))
          this._queue.set(key2, /* @__PURE__ */ new Set());
        this._queue.get(key2).add(item);
      }
      _serve(key2, callback) {
        const items = this._queue.get(key2);
        if (items)
          for (const item of items)
            callback(item);
        this._queue.delete(key2);
      }
      _delete(key2) {
        this._queue.delete(key2);
      }
      _size(key2) {
        var _a4;
        return ((_a4 = this._queue.get(key2)) == null ? void 0 : _a4.size) ?? 0;
      }
      _reset() {
        this._queue.clear();
      }
    };
  }
});
function createMediaUser($controller, $media) {
  let idleTimeout, delay = 2e3, trigger, $idle = maverick_js.signal(false), $userPaused = maverick_js.signal(false), $paused = maverick_js.computed(() => $userPaused() || $media.paused);
  maverick_js.effect(() => {
    const target = $controller();
    if (!target)
      return;
    maverick_js.effect(() => {
      if ($paused())
        return;
      for (const eventType of STOP_IDLE_EVENTS) {
        std.listenEvent(target, eventType, stopIdling);
      }
    });
    maverick_js.effect(() => {
      window.clearTimeout(idleTimeout);
      const idle = $idle() && !$paused();
      $media.userIdle = idle;
      std.dispatchEvent(target, "user-idle-change", { detail: idle, trigger });
      trigger = void 0;
    });
    return () => $idle.set(false);
  });
  function stopIdling(event) {
    if ($idle())
      trigger = event;
    $idle.set(false);
    window.clearTimeout(idleTimeout);
    idleTimeout = window.setTimeout(() => $idle.set(!maverick_js.peek($paused)), delay);
  }
  return {
    idle: {
      get idling() {
        return $idle();
      },
      get paused() {
        return $userPaused();
      },
      set paused(paused) {
        $userPaused.set(paused);
      },
      get delay() {
        return delay;
      },
      set delay(newDelay) {
        delay = newDelay;
      }
    }
  };
}
var STOP_IDLE_EVENTS;
var init_user = __esm({
  "src/player/media/user.ts"() {
    STOP_IDLE_EVENTS = ["pointerup", "pointermove", "focus", "keydown", "playing"];
  }
});
function createMediaRequestManager({ $player, $store: $media, $provider, logger }, handler, requests, $props) {
  const user = createMediaUser($player, $media), orientation = createScreenOrientationAdapter($player); createFullscreenAdapter($player);
  {
    return {
      _user: user,
      _orientation: orientation,
      _play: std.noop,
      _pause: std.noop,
      _seekToLiveEdge: std.noop,
      _enterFullscreen: std.noop,
      _exitFullscreen: std.noop
    };
  }
}
var MediaRequestContext;
var init_request_manager = __esm({
  "src/player/media/controller/request-manager.ts"() {
    init_fullscreen();
    init_screen_orientation();
    init_queue();
    init_error();
    init_user();
    MediaRequestContext = class {
      constructor() {
        this._queue = new Queue();
        this._$isSeeking = maverick_js.signal(false);
        this._$isLooping = maverick_js.signal(false);
        this._$isReplay = maverick_js.signal(false);
      }
    };
  }
});
var init_just_debounce_it = __esm({
  "../../node_modules/.pnpm/just-debounce-it@3.2.0/node_modules/just-debounce-it/index.mjs"() {
  }
});
function createMediaStateManager({ $player, $loader, $provider, $store: $media, logger }, requests) {
  return { handle: std.noop };
}
var init_state_manager = __esm({
  "src/player/media/controller/state-manager.ts"() {
    init_just_debounce_it();
    init_just_throttle();
    init_store();
  }
});
function createMediaController(props) {
  const context = {
    $player: maverick_js.signal(null),
    $loader: maverick_js.signal(null),
    $provider: maverick_js.signal(null),
    $store: exports.mediaStore.create()
  };
  maverick_js.provideContext(exports.mediaContext, context);
  context.remote = new exports.MediaRemoteControl(void 0);
  const $store = context.$store; new MediaRequestContext(); const stateManager = createMediaStateManager(context), requestManager = createMediaRequestManager(context), delegate = createMediaControllerDelegate(context, stateManager.handle), providerDelegate = useMediaProviderDelegate(context, requestManager, props);
  context.delegate = delegate;
  const providedProps = {
    viewType: "providedViewType",
    streamType: "providedStreamType"
  };
  for (const prop of Object.keys(props)) {
    const propName = prop.slice(1);
    if (propName in $store)
      $store[providedProps[propName] ?? propName] = props[prop]();
  }
  maverick_js.effect(() => {
    $store.providedViewType = props.$viewType();
    $store.providedStreamType = props.$streamType();
  });
  $store.muted = props.$muted() || props.$volume() === 0;
  useMediaCanLoad(context.$player, props.$load);
  function startLoadingMedia() {
    delegate.dispatch("can-load");
  }
  return {
    _context: context,
    _start: startLoadingMedia,
    _request: requestManager,
    _provider: providerDelegate
  };
}
var init_create_controller = __esm({
  "src/player/media/controller/create-controller.ts"() {
    init_context();
    init_remote_control();
    init_store();
    init_can_load();
    init_controller_delegate();
    init_prop_change();
    init_provider_delegate();
    init_request_manager();
    init_state_manager();
  }
});
var $$_templ, AudioProviderLoader;
var init_loader = __esm({
  "src/player/media/providers/audio/loader.tsx"() {
    init_mime();
    $$_templ = ["<!$><audio", "", "", "", ' preload="none"></audio>'];
    AudioProviderLoader = class {
      canPlay({ src, type }) {
        return std.isString(src) ? AUDIO_EXTENSIONS.test(src) || AUDIO_TYPES.has(type) || src.startsWith("blob:") && type === "audio/object" : type === "audio/object";
      }
      mediaType() {
        return "audio";
      }
      async load() {
        return new (await Promise.resolve().then(() => (init_provider2(), provider_exports))).AudioProvider(this._audio);
      }
      render($store) {
        {
          const src = $store.source.src;
          return ssr.$$_ssr(
            $$_templ,
            ssr.$$_attr("src", std.isString(src) ? src : null),
            ssr.$$_attr("muted", $store.muted),
            ssr.$$_attr("controls", $store.controls),
            ssr.$$_attr("playsinline", $store.playsinline)
          );
        }
      }
    };
  }
});
var $$_templ2, VideoProviderLoader;
var init_loader2 = __esm({
  "src/player/media/providers/video/loader.tsx"() {
    init_mime();
    $$_templ2 = ["<!$><video", "", "", "", "", ' preload="none"></video>'];
    VideoProviderLoader = class {
      canPlay(src) {
        return std.isString(src.src) ? VIDEO_EXTENSIONS.test(src.src) || VIDEO_TYPES.has(src.type) || src.src.startsWith("blob:") && src.type === "video/object" || isHLSSrc(src) && true : src.type === "video/object";
      }
      mediaType() {
        return "video";
      }
      async load(context) {
        return new (await Promise.resolve().then(() => (init_provider3(), provider_exports2))).VideoProvider(this._video, context);
      }
      render($store) {
        {
          const src = $store.source.src;
          return ssr.$$_ssr(
            $$_templ2,
            ssr.$$_attr("src", std.isString(src) ? src : null),
            ssr.$$_attr("poster", $store.poster),
            ssr.$$_attr("muted", $store.muted),
            ssr.$$_attr("controls", $store.controls),
            ssr.$$_attr("playsinline", $store.playsinline)
          );
        }
      }
    };
  }
});
var _HLSProviderLoader, HLSProviderLoader;
var init_loader3 = __esm({
  "src/player/media/providers/hls/loader.tsx"() {
    init_mime();
    init_network();
    init_support();
    init_loader2();
    _HLSProviderLoader = class extends VideoProviderLoader {
      preconnect() {
      }
      canPlay({ src, type }) {
        return _HLSProviderLoader.supported && std.isString(src) && (HLS_VIDEO_EXTENSIONS.test(src) || HLS_VIDEO_TYPES.has(type));
      }
      async load(context) {
        return new (await Promise.resolve().then(() => (init_provider4(), provider_exports3))).HLSProvider(this._video, context);
      }
    };
    HLSProviderLoader = _HLSProviderLoader;
    HLSProviderLoader.supported = isHLSSupported();
  }
});
function useSourceSelection($src, $preferNativeHLS, context) {
  const { $loader, $store, delegate } = context;
  const HLS_LOADER = new HLSProviderLoader(), VIDEO_LOADER = new VideoProviderLoader(), AUDIO_LOADER = new AudioProviderLoader();
  const $loaders = maverick_js.computed(() => {
    return $preferNativeHLS() ? [VIDEO_LOADER, AUDIO_LOADER, HLS_LOADER] : [HLS_LOADER, VIDEO_LOADER, AUDIO_LOADER];
  });
  {
    $store.sources = normalizeSrc($src());
    for (const src of $store.sources) {
      const loader = $loaders().find((loader2) => loader2.canPlay(src));
      if (loader) {
        $store.source = src;
        $store.mediaType = loader.mediaType(src);
        $loader.set(loader);
      }
    }
    return;
  }
}
function normalizeSrc(src) {
  return (std.isArray(src) ? src : [!std.isString(src) && "src" in src ? src : { src }]).map(
    ({ src: src2, type }) => ({
      src: src2,
      type: type ?? (!std.isString(src2) || src2.startsWith("blob:") ? "video/object" : "?")
    })
  );
}
var init_source_selection = __esm({
  "src/player/media/controller/source-selection.ts"() {
    init_network();
    init_loader();
    init_loader3();
    init_loader2();
  }
});

// src/player/element/props.ts
var mediaPlayerProps;
var init_props = __esm({
  "src/player/element/props.ts"() {
    init_keyboard();
    mediaPlayerProps = {
      autoplay: { initial: false },
      aspectRatio: {
        initial: null,
        type: {
          from(value) {
            if (!value)
              return null;
            const [width, height] = value.split("/").map(Number);
            return +(width / height).toFixed(4);
          }
        }
      },
      controls: { initial: false },
      currentTime: { initial: 0 },
      fullscreenOrientation: {},
      load: { initial: "visible" },
      logLevel: { initial: "silent" },
      loop: { initial: false },
      muted: { initial: false },
      paused: { initial: true },
      playsinline: { initial: false },
      poster: { initial: "" },
      preload: { initial: "metadata" },
      preferNativeHLS: {
        initial: false,
        attribute: "prefer-native-hls"
      },
      src: { initial: "" },
      userIdleDelay: { initial: 2e3 },
      viewType: { initial: "unknown" },
      streamType: { initial: "unknown" },
      volume: { initial: 1 },
      liveEdgeTolerance: { initial: 10 },
      minLiveDVRWindow: { initial: 60 },
      keyDisabled: { initial: false },
      keyTarget: { initial: "player" },
      keyShortcuts: { initial: exports.MEDIA_KEY_SHORTCUTS }
    };
  }
});
var MEDIA_ATTRIBUTES, HLS_LISTENERS; exports.PlayerDefinition = void 0;
var init_element = __esm({
  "src/player/element/element.ts"() {
    init_use_focus_visible();
    init_support();
    init_create_controller();
    init_source_selection();
    init_keyboard();
    init_props();
    MEDIA_ATTRIBUTES = [
      "autoplay",
      "autoplayError",
      "canFullscreen",
      "canLoad",
      "canPlay",
      "canSeek",
      "ended",
      "error",
      "fullscreen",
      "loop",
      "live",
      "liveEdge",
      "mediaType",
      "muted",
      "paused",
      "playing",
      "playsinline",
      "seeking",
      "started",
      "streamType",
      "userIdle",
      "viewType",
      "waiting"
    ];
    HLS_LISTENERS = Symbol(0);
    exports.PlayerDefinition = element.defineCustomElement({
      tagName: "media-player",
      props: mediaPlayerProps,
      construct() {
        this[HLS_LISTENERS] = maverick_js.signal([]);
        const addEventListener = this.addEventListener;
        this.addEventListener = function(type, handler, options) {
          if (type.startsWith("hls-"))
            this[HLS_LISTENERS].set((x) => [...x, type]);
          return addEventListener.call(this, type, handler, options);
        };
      },
      setup({ host, props, accessors }) {
        const scope = maverick_js.getScope(), controller = createMediaController(props), context = controller._context, $media = context.$store;
        element.onAttach(() => {
          host.el.setAttribute("tabindex", "0");
          if (!host.el.hasAttribute("aria-label")) {
            host.el.setAttribute("aria-label", "Media Player");
          }
          context.$player.set(host.el);
          context.remote.setTarget(host.el);
          context.remote.setPlayer(host.el);
          std.listenEvent(host.el, "find-media-player", ({ detail }) => detail(host.el));
        });
        element.onConnect(() => {
          std.dispatchEvent(host.el, "media-player-connect", {
            detail: host.el,
            bubbles: true,
            composed: true
          });
          window.requestAnimationFrame(() => {
            if (std.isNull($media.canLoadPoster))
              $media.canLoadPoster = true;
          });
        });
        context.ariaKeys = {};
        context.$keyShortcuts = props.$keyShortcuts;
        useKeyboard(context, props);
        useFocusVisible(host.$el);
        useSourceSelection(props.$src, props.$preferNativeHLS, controller._context);
        const $attrs = {
          "aspect-ratio": props.$aspectRatio,
          "data-ios-controls": () => IS_IOS && $media.mediaType === "video" && $media.controls && (!props.$playsinline() || $media.fullscreen)
        };
        for (const prop of MEDIA_ATTRIBUTES) {
          $attrs["data-" + std.camelToKebabCase(prop)] = () => $media[prop];
        }
        host.setAttributes($attrs);
        host.setCSSVars({
          "--media-aspect-ratio": () => {
            const ratio = props.$aspectRatio();
            return ratio ? +ratio.toFixed(4) : null;
          },
          "--media-buffered": () => +$media.bufferedEnd.toFixed(3),
          "--media-current-time": () => +$media.currentTime.toFixed(3),
          "--media-duration": () => Number.isFinite($media.duration) ? +$media.duration.toFixed(3) : 0
        });
        maverick_js.onDispose(() => {
          std.dispatchEvent(host.el, "destroy");
        });
        return std.mergeProperties(
          {
            get user() {
              return controller._request._user;
            },
            get orientation() {
              return controller._request._orientation;
            },
            get provider() {
              return context.$provider();
            },
            get $store() {
              return $media;
            },
            state: new Proxy($media, {
              set: std.noop
            }),
            subscribe: (callback) => maverick_js.scoped(() => maverick_js.effect(() => callback($media)), scope),
            startLoading: controller._start,
            play: controller._request._play,
            pause: controller._request._pause,
            seekToLiveEdge: controller._request._seekToLiveEdge,
            enterFullscreen: controller._request._enterFullscreen,
            exitFullscreen: controller._request._exitFullscreen
          },
          accessors(),
          controller._provider
        );
      }
    });
  }
});
function useHLS(provider, config, $ctor, $instance, { player, logger, delegate, $store }, callbacks) {
  const listening = /* @__PURE__ */ new Set();
  maverick_js.effect(() => {
    const ctor = $ctor();
    if (!ctor)
      return;
    const isLowLatencyStream = maverick_js.peek(() => $store.streamType).includes("ll-");
    const instance = new ctor({
      lowLatencyMode: isLowLatencyStream,
      ...config
    });
    maverick_js.effect(() => void attachEventListeners(instance, player[HLS_LISTENERS]()));
    instance.on(ctor.Events.ERROR, onError);
    $instance.set(instance);
    for (const callback of callbacks)
      callback(instance);
    std.dispatchEvent(player, "hls-instance", { detail: instance });
    instance.attachMedia(provider.media);
    const levelLoadedEvent = maverick_js.peek($ctor).Events.LEVEL_LOADED;
    instance.on(levelLoadedEvent, onLevelLoaded);
    delegate.dispatch("provider-setup", { detail: provider });
    return () => {
      listening.clear();
      instance.destroy();
      $instance.set(null);
    };
  });
  maverick_js.effect(() => {
    if (!$store.live)
      return;
    const instance = $instance();
    if (!instance)
      return;
    const rafLoop = createRAFLoop(() => {
      $store.liveSyncPosition = instance.liveSyncPosition ?? Infinity;
    });
    rafLoop.start();
    return rafLoop.stop;
  });
  function dispatchHLSEvent(eventType, detail) {
    player.dispatchEvent(new std.DOMEvent(toDOMEventType(eventType), { detail }));
  }
  function attachEventListeners(instance, listeners) {
    for (const type of listeners) {
      if (!listening.has(type)) {
        instance.on(toHLSEventType(type), dispatchHLSEvent);
        listening.add(type);
      }
    }
  }
  function onLevelLoaded(eventType, data) {
    if ($store.canPlay)
      return;
    const { type, live, totalduration: duration } = data.details;
    const event = new std.DOMEvent(eventType, { detail: data });
    delegate.dispatch("stream-type-change", {
      detail: live ? type === "EVENT" && Number.isFinite(duration) ? "live:dvr" : "live" : "on-demand",
      trigger: event
    });
    delegate.dispatch("duration-change", { detail: duration, trigger: event });
    const instance = $instance();
    const media = instance.media;
    media.dispatchEvent(new std.DOMEvent("canplay", { trigger: event }));
  }
  function onError(eventType, data) {
    var _b, _c, _d;
    if (data.fatal) {
      switch (data.type) {
        case "networkError":
          (_b = $instance()) == null ? void 0 : _b.startLoad();
          break;
        case "mediaError":
          (_c = $instance()) == null ? void 0 : _c.recoverMediaError();
          break;
        default:
          (_d = $instance()) == null ? void 0 : _d.destroy();
          $instance.set(null);
          break;
      }
    }
  }
}
var toDOMEventType, toHLSEventType;
var init_use_hls = __esm({
  "src/player/media/providers/hls/use-hls.ts"() {
    init_just_throttle();
    init_raf_loop();
    init_element();
    toDOMEventType = (type) => std.camelToKebabCase(type);
    toHLSEventType = (type) => std.kebabToCamelCase(type);
  }
});

// src/player/media/providers/hls/provider.ts
var provider_exports3 = {};
__export(provider_exports3, {
  HLSProvider: () => HLSProvider,
  HLS_PROVIDER: () => HLS_PROVIDER
});
var HLS_PROVIDER, JS_DELIVR_CDN, _a3, HLSProvider;
var init_provider4 = __esm({
  "src/player/media/providers/hls/provider.ts"() {
    init_network();
    init_support();
    init_provider3();
    init_lib_loader();
    init_use_hls();
    HLS_PROVIDER = Symbol(0);
    JS_DELIVR_CDN = "https://cdn.jsdelivr.net";
    HLSProvider = class extends VideoProvider {
      constructor() {
        super(...arguments);
        this[_a3] = true;
        this._$ctor = maverick_js.signal(null);
        this._$instance = maverick_js.signal(null);
        this._instanceCallbacks = /* @__PURE__ */ new Set();
        this._library = `${JS_DELIVR_CDN}/npm/hls.js@^1.0.0/dist/hls${".min.js"}`;
        this.config = {};
      }
      get type() {
        return "hls";
      }
      get canLiveSync() {
        return true;
      }
      get library() {
        return this._library;
      }
      set library(library) {
        this._library = library;
      }
      preconnect() {
        if (!std.isString(this._library))
          return;
        preconnect(this._library);
      }
      setup(context) {
        super.setup(context);
        loadHLSLibrary(this._library, context).then((ctor) => this._$ctor.set(() => ctor));
        useHLS(this, this.config, this._$ctor, this._$instance, context, this._instanceCallbacks);
      }
      get ctor() {
        return this._$ctor();
      }
      get instance() {
        return this._$instance();
      }
      async loadSource({ src }) {
        maverick_js.effect(() => {
          if (!std.isString(src))
            return;
          const instance = this._$instance();
          instance == null ? void 0 : instance.loadSource(src);
        });
      }
      onInstance(callback) {
        const instance = maverick_js.peek(this._$instance);
        if (instance)
          callback(instance);
        this._instanceCallbacks.add(callback);
        return () => this._instanceCallbacks.delete(callback);
      }
    };
    _a3 = HLS_PROVIDER;
    HLSProvider.supported = isHLSSupported();
  }
});

// src/index.ts
init_keyboard();
init_context();
init_remote_control();
init_store();
init_time_ranges();

// src/player/media/providers/type-check.ts
init_provider2();
init_provider4();
init_provider3();
function isAudioProvider(provider) {
  return !!(provider == null ? void 0 : provider[AUDIO_PROVIDER]);
}
function isVideoProvider(provider) {
  return !!(provider == null ? void 0 : provider[VIDEO_PROVIDER]);
}
function isHLSProvider(provider) {
  return !!(provider == null ? void 0 : provider[HLS_PROVIDER]);
}
function isHTMLAudioElement(element) {
  return false;
}
function isHTMLVideoElement(element) {
  return false;
}
var sliderStore = maverick_js.createStore({
  min: 0,
  max: 100,
  value: 50,
  pointerValue: 0,
  focused: false,
  dragging: false,
  pointing: false,
  get interactive() {
    return this.dragging || this.focused || this.pointing;
  },
  get fillRate() {
    return calcRate(this.min, this.max, this.value);
  },
  get fillPercent() {
    return this.fillRate * 100;
  },
  get pointerRate() {
    return calcRate(this.min, this.max, this.pointerValue);
  },
  get pointerPercent() {
    return this.pointerRate * 100;
  }
});
function calcRate(min, max, value) {
  const range = max - min, offset = value - min;
  return range > 0 ? offset / range : 0;
}
var sliderStoreContext = maverick_js.createContext(() => sliderStore.create());
function useSliderStore() {
  return maverick_js.useContext(sliderStoreContext);
}
var $$_templ3 = ['<!$><svg viewBox="0 0 32 32" fill="none" aria-hidden="true" focusable="false" data-media-icon="true"', ">", "</svg>"];
function Icon({ slot, paths: paths2 }) {
  return ssr.$$_ssr($$_templ3, ssr.$$_attr("slot", slot), ssr.$$_inject_html(paths2));
}
function setAttributeIfEmpty(target, name, value) {
  if (!target.hasAttribute(name))
    target.setAttribute(name, value);
}
function setARIALabel(target, label) {
  if (target.hasAttribute("aria-label") || target.hasAttribute("aria-describedby"))
    return;
  function updateAriaDescription() {
    std.setAttribute(target, "aria-label", label());
  }
  updateAriaDescription();
}

// src/player/ui/fullscreen-button/element.tsx
init_keyboard();
init_context();

// src/player/ui/toggle-button/props.ts
var toggleButtonProps = {
  disabled: { initial: false },
  defaultPressed: { initial: false },
  defaultAppearance: { initial: false }
};

// src/player/ui/toggle-button/use-toggle-button.ts
init_use_focus_visible();
function useToggleButton(host, { $props: { $pressed, $disabled }, ...props }) {
  host.setAttributes({
    disabled: $disabled,
    "data-pressed": $pressed,
    "aria-pressed": () => std.ariaBool($pressed()),
    "data-media-button": true
  });
  useFocusVisible(host.$el);
  element.onAttach(() => {
    setAttributeIfEmpty(host.el, "tabindex", "0");
    setAttributeIfEmpty(host.el, "role", "button");
  });
  maverick_js.effect(() => {
    const target = host.$el();
    if (!target)
      return;
    const clickEvents = ["pointerup", "keydown"];
    for (const eventType of clickEvents)
      std.listenEvent(target, eventType, onPress);
  });
  function onPress(event) {
    var _a4;
    const disabled = $disabled();
    if (disabled || std.isKeyboardEvent(event) && !std.isKeyboardClick(event)) {
      if (disabled)
        event.stopImmediatePropagation();
      return;
    }
    (_a4 = props.onPress) == null ? void 0 : _a4.call(props, event);
  }
  return {
    get pressed() {
      return $pressed();
    },
    get disabled() {
      return $disabled();
    }
  };
}

// src/player/ui/fullscreen-button/element.tsx
var FullscreenButtonDefinition = element.defineCustomElement({
  tagName: "media-fullscreen-button",
  props: {
    ...toggleButtonProps,
    target: { initial: "prefer-media" }
  },
  setup({ host, props: { $target, $disabled, $defaultAppearance }, accessors }) {
    const { $store: $media, remote } = useMedia(), $pressed = () => $media.fullscreen, toggle = useToggleButton(host, {
      $props: { $pressed, $disabled },
      onPress
    });
    useARIAKeyShortcuts(host, "toggleFullscreen");
    element.onAttach(() => {
      setARIALabel(host.el, () => $media.fullscreen ? "Exit Fullscreen" : "Enter Fullscreen");
    });
    host.setAttributes({
      "data-hidden": () => !$media.canFullscreen,
      "data-fullscreen": () => $media.fullscreen,
      "default-appearance": $defaultAppearance
    });
    function onPress(event) {
      if ($disabled())
        return;
      $pressed() ? remote.exitFullscreen($target(), event) : remote.enterFullscreen($target(), event);
    }
    return std.mergeProperties(toggle, accessors(), {
      $render: () => {
        return [
          ssr.$$_create_component(Icon, { paths: mediaIcons.fullscreenPaths, slot: "enter" }),
          ssr.$$_create_component(Icon, { paths: mediaIcons.fullscreenExitPaths, slot: "exit" })
        ];
      }
    });
  }
});

// src/player/ui/live-indicator/element.tsx
init_use_focus_visible();
init_context();
var $$_templ4 = ['<!$><div part="container"><div part="text">LIVE</div></div>'];
var LiveIndicatorDefinition = element.defineCustomElement({
  tagName: "media-live-indicator",
  setup({ host }) {
    const { $store: $media, remote } = useMedia();
    useFocusVisible(host.$el);
    host.setAttributes({
      tabindex: () => $media.live ? 0 : null,
      role: () => $media.live ? "button" : null,
      "data-live": () => $media.live,
      "data-live-edge": () => $media.liveEdge,
      "data-media-button": true
    });
    element.onAttach(() => {
      setARIALabel(host.el, () => $media.live ? "Go live" : null);
      const clickEvents = ["pointerup", "keydown"];
      for (const eventType of clickEvents)
        std.listenEvent(host.el, eventType, onPress);
    });
    function onPress(event) {
      if ($media.liveEdge || std.isKeyboardEvent(event) && !std.isKeyboardClick(event))
        return;
      remote.seekToLiveEdge(event);
    }
    return () => ssr.$$_ssr($$_templ4);
  }
});
var $$_templ5 = ['<!$><svg viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" data-media-icon="true">', "</svg>"];
var MediaIconDefinition = element.defineCustomElement({
  tagName: "media-icon",
  props: {
    type: {}
  },
  setup({ host, props: { $type }, accessors }) {
    const $paths = maverick_js.signal("");
    {
      const type = $type();
      if (type && mediaIcons.paths[type])
        $paths.set(mediaIcons.paths[type]);
    }
    element.onAttach(() => {
      let hydrate = host.el.hasAttribute("mk-h");
      maverick_js.effect(() => {
        const type = $type();
        if (hydrate) {
          hydrate = false;
          return;
        }
        if (type && mediaIcons.lazyPaths[type]) {
          mediaIcons.lazyPaths[type]().then(({ default: paths2 }) => {
            if (type === maverick_js.peek($type))
              $paths.set(paths2);
          });
        } else
          $paths.set("");
      });
    });
    return std.mergeProperties(accessors(), {
      $render: () => ssr.$$_ssr($$_templ5, ssr.$$_inject_html($paths))
    });
  }
});
init_keyboard();
init_context();
var MuteButtonDefinition = element.defineCustomElement({
  tagName: "media-mute-button",
  props: toggleButtonProps,
  setup({ host, props: { $disabled, $defaultAppearance } }) {
    const { $store: $media, remote } = useMedia(), $pressed = maverick_js.computed(() => $media.muted || $media.volume === 0), toggle = useToggleButton(host, {
      $props: { $pressed, $disabled },
      onPress
    });
    useARIAKeyShortcuts(host, "toggleMuted");
    element.onAttach(() => {
      setARIALabel(host.el, () => $pressed() ? "Unmute" : "Mute");
    });
    host.setAttributes({
      "data-muted": $pressed,
      "data-volume": getVolumeText,
      "default-appearance": $defaultAppearance
    });
    function getVolumeText() {
      if ($media.muted || $media.volume === 0)
        return "muted";
      else if ($media.volume >= 0.5)
        return "high";
      else if ($media.volume < 0.5)
        return "low";
    }
    function onPress(event) {
      if ($disabled())
        return;
      $pressed() ? remote.unmute(event) : remote.mute(event);
    }
    return std.mergeProperties(toggle, {
      $render: () => {
        return [
          ssr.$$_create_component(Icon, { paths: mediaIcons.volumeHighPaths, slot: "volume-high" }),
          ssr.$$_create_component(Icon, { paths: mediaIcons.volumeLowPaths, slot: "volume-low" }),
          ssr.$$_create_component(Icon, { paths: mediaIcons.mutePaths, slot: "volume-muted" })
        ];
      }
    });
  }
});

// src/player/media/outlet/element.ts
init_context();
var OutletDefinition = element.defineCustomElement({
  tagName: "media-outlet",
  setup({ host }) {
    const context = useMedia(), $rendered = maverick_js.signal(false);
    element.onAttach(() => {
      host.el.keepAlive = true;
    });
    maverick_js.effect(() => {
      context.$loader();
      return () => $rendered.set(false);
    });
    maverick_js.effect(() => {
      const loader = context.$loader();
      if (!$rendered() || !loader)
        return;
      maverick_js.peek(() => {
        loader.load(context).then((provider) => {
          if (maverick_js.peek(context.$loader) === loader) {
            context.delegate.dispatch("provider-change", {
              detail: provider
            });
          }
        });
      });
    });
    return () => () => {
      var _a4;
      $rendered.set(true);
      return (_a4 = context.$loader()) == null ? void 0 : _a4.render(context.$store);
    };
  }
});
init_keyboard();
init_context();
var PlayButtonDefinition = element.defineCustomElement({
  tagName: "media-play-button",
  props: toggleButtonProps,
  setup({ host, props: { $disabled, $defaultAppearance } }) {
    const { $store: $media, remote } = useMedia(), $pressed = () => !$media.paused, toggle = useToggleButton(host, {
      $props: { $pressed, $disabled },
      onPress
    });
    useARIAKeyShortcuts(host, "togglePaused");
    element.onAttach(() => {
      setARIALabel(host.el, () => $media.paused ? "Play" : "Pause");
    });
    host.setAttributes({
      "default-appearance": $defaultAppearance,
      "data-paused": () => $media.paused
    });
    function onPress(event) {
      if ($disabled())
        return;
      $pressed() ? remote.pause(event) : remote.play(event);
    }
    return std.mergeProperties(toggle, {
      $render: () => {
        return [
          ssr.$$_create_component(Icon, { paths: mediaIcons.playPaths, slot: "play" }),
          ssr.$$_create_component(Icon, { paths: mediaIcons.pausePaths, slot: "pause" })
        ];
      }
    });
  }
});

// src/index.ts
init_element();

// src/player/ui/poster/element.tsx
init_network();
init_context();
init_remote_control();

// src/player/ui/poster/props.ts
var posterProps = {
  alt: {}
};

// src/player/ui/poster/element.tsx
var $$_templ6 = ["<!$><img", "", ' part="img" />'];
var PosterDefinition = element.defineCustomElement({
  tagName: "media-poster",
  props: posterProps,
  setup({ host, props: { $alt } }) {
    const { $store: $media } = useMedia(), remote = new exports.MediaRemoteControl();
    const $imgSrc = () => $media.canLoad && $media.poster.length ? $media.poster : null, $imgAlt = () => $imgSrc() ? $alt() : null, $imgLoading = maverick_js.signal(true), $imgError = maverick_js.signal(false);
    host.setAttributes({
      "data-loading": $imgLoading,
      "data-hidden": $imgError
    });
    element.onConnect(() => {
      window.requestAnimationFrame(() => {
        if (!$media.canLoad)
          preconnect($media.poster);
      });
      remote.setTarget(host.el);
      remote.hidePoster();
      return () => remote.showPoster();
    });
    maverick_js.effect(() => {
      const isLoading = $media.canLoad && !!$media.poster;
      $imgLoading.set(isLoading);
      $imgError.set(false);
    });
    return () => ssr.$$_ssr($$_templ6, ssr.$$_attr("src", $imgSrc), ssr.$$_attr("alt", $imgAlt));
  }
});

// src/player/ui/seek-button/element.tsx
init_use_focus_visible();
init_context();
var SeekButtonDefinition = element.defineCustomElement({
  tagName: "media-seek-button",
  props: { seconds: { initial: 30 }, defaultAppearance: { initial: false } },
  setup({ host, props: { $seconds, $defaultAppearance } }) {
    const { $store: $media, remote } = useMedia();
    useFocusVisible(host.$el);
    element.onAttach(() => {
      setAttributeIfEmpty(host.el, "tabindex", "0");
      setAttributeIfEmpty(host.el, "role", "button");
      setARIALabel(
        host.el,
        () => `Seek ${$seconds() > 0 ? "forward" : "backward"} ${$seconds()} seconds`
      );
      const clickEvents = ["pointerup", "keydown"];
      for (const eventType of clickEvents)
        std.listenEvent(host.el, eventType, onPress);
    });
    host.setAttributes({
      seconds: $seconds,
      "data-media-button": true,
      "default-appearance": $defaultAppearance,
      "data-hidden": () => !$media.canSeek
    });
    function onPress(event) {
      if (std.isKeyboardEvent(event) && !std.isKeyboardClick(event))
        return;
      remote.seek($media.currentTime + $seconds(), event);
    }
    return () => [
      ssr.$$_create_component(Icon, { paths: mediaIcons.seekBackwardPaths, slot: "backward" }),
      ssr.$$_create_component(Icon, { paths: mediaIcons.seekForwardPaths, slot: "forward" })
    ];
  }
});

// src/player/ui/slider/create.tsx
init_use_focus_visible();
init_number();
var sliderValueFormattersContext = maverick_js.createContext(() => ({}));

// src/player/ui/slider/use-events.ts
init_support();
init_context();

// src/player/ui/slider/utils.ts
init_number();
function getClampedValue(min, max, value, step) {
  return clampNumber(min, round(value, getNumberOfDecimalPlaces(step)), max);
}
function getValueFromRate(min, max, rate, step) {
  const boundRate = clampNumber(0, rate, 1);
  const range = max - min;
  const fill = range * boundRate;
  const stepRatio = Math.round(fill / step);
  const steps = step * stepRatio;
  return min + steps;
}

// src/player/ui/slider/use-events.ts
var SliderKeyDirection = {
  Left: -1,
  ArrowLeft: -1,
  Up: 1,
  ArrowUp: 1,
  Right: 1,
  ArrowRight: 1,
  Down: -1,
  ArrowDown: -1
};
function useSliderEvents(host, { $disabled, $step, $keyStep, $shiftKeyMultiplier }, { onValueChange, onDragStart, onDragValueChange, onDragEnd }, $store) {
  const remote = useMedia().remote;
  maverick_js.effect(() => {
    const target = host.$el();
    if (!target || $disabled())
      return;
    std.listenEvent(target, "focus", onFocus);
    std.listenEvent(target, "pointerenter", onPointerEnter);
    std.listenEvent(target, "pointermove", onPointerMove);
    std.listenEvent(target, "pointerleave", onPointerLeave);
    std.listenEvent(target, "pointerdown", onPointerDown);
    std.listenEvent(target, "keydown", onKeyDown);
    std.listenEvent(target, "keyup", onKeyUp);
  });
  maverick_js.effect(() => {
    if ($disabled() || !$store.dragging)
      return;
    std.listenEvent(document, "pointerup", onDocumentPointerUp);
    std.listenEvent(document, "pointermove", onDocumentPointerMove);
    if (IS_SAFARI)
      std.listenEvent(document, "touchmove", onDocumentTouchMove, { passive: false });
  });
  function onFocus() {
    updatePointerValue($store.value);
  }
  function updateValue(value, trigger) {
    var _a4, _b;
    $store.value = Math.max($store.min, Math.min(value, $store.max));
    const event = std.createEvent(host.el, "value-change", { detail: $store.value, trigger });
    (_a4 = host.el) == null ? void 0 : _a4.dispatchEvent(event);
    onValueChange == null ? void 0 : onValueChange(event);
    if ($store.dragging) {
      const event2 = std.createEvent(host.el, "drag-value-change", { detail: value, trigger });
      (_b = host.el) == null ? void 0 : _b.dispatchEvent(event2);
      onDragValueChange == null ? void 0 : onDragValueChange(event2);
    }
  }
  function updatePointerValue(value, trigger) {
    $store.pointerValue = Math.max($store.min, Math.min(value, $store.max));
    std.dispatchEvent(host.el, "pointer-value-change", { detail: value, trigger });
    if ($store.dragging)
      updateValue(value, trigger);
  }
  function getPointerValue(event) {
    const thumbClientX = event.clientX;
    const { left: trackLeft, width: trackWidth } = host.el.getBoundingClientRect();
    const thumbPositionRate = (thumbClientX - trackLeft) / trackWidth;
    return getValueFromRate($store.min, $store.max, thumbPositionRate, $step());
  }
  function onPointerEnter() {
    $store.pointing = true;
  }
  function onPointerMove(event) {
    if ($store.dragging)
      return;
    updatePointerValue(getPointerValue(event), event);
  }
  function onPointerLeave(event) {
    $store.pointing = false;
  }
  function onPointerDown(event) {
    const value = getPointerValue(event);
    onStartDragging(value, event);
    updatePointerValue(value, event);
  }
  function onStartDragging(value, trigger) {
    var _a4;
    if ($store.dragging)
      return;
    $store.dragging = true;
    const dragStartEvent = std.createEvent(host.el, "drag-start", { detail: value, trigger });
    (_a4 = host.el) == null ? void 0 : _a4.dispatchEvent(dragStartEvent);
    onDragStart == null ? void 0 : onDragStart(dragStartEvent);
  }
  function onStopDragging(value, trigger) {
    var _a4;
    if (!$store.dragging)
      return;
    $store.dragging = false;
    remote.resumeUserIdle(trigger);
    const dragEndEvent = std.createEvent(host.el, "drag-start", { detail: value, trigger });
    (_a4 = host.el) == null ? void 0 : _a4.dispatchEvent(dragEndEvent);
    onDragEnd == null ? void 0 : onDragEnd(dragEndEvent);
  }
  let lastDownKey;
  function onKeyDown(event) {
    if (std.isDOMEvent(event)) {
      const trigger = event.trigger;
      if (std.isKeyboardEvent(trigger))
        event = trigger;
      else
        return;
    }
    const { key: key2 } = event;
    if (key2 === "Home" || key2 === "PageUp") {
      updatePointerValue($store.min, event);
      updateValue($store.min, event);
      return;
    } else if (key2 === "End" || key2 === "PageDown") {
      updatePointerValue($store.max, event);
      updateValue($store.max, event);
      return;
    } else if (/[0-9]/.test(key2)) {
      const value2 = ($store.max - $store.min) / 10 * Number(key2);
      updatePointerValue(value2, event);
      updateValue(value2, event);
      return;
    }
    const value = getKeyValue(event);
    if (!value)
      return;
    const repeat = key2 === lastDownKey;
    if (!$store.dragging && repeat)
      onStartDragging(value, event);
    updatePointerValue(value, event);
    if (!repeat)
      updateValue(value, event);
    lastDownKey = key2;
  }
  function onKeyUp(event) {
    if (std.isDOMEvent(event)) {
      const trigger = event.trigger;
      if (std.isKeyboardEvent(trigger))
        event = trigger;
      else
        return;
    }
    lastDownKey = "";
    if (!$store.dragging)
      return;
    const value = getKeyValue(event) ?? $store.value;
    updatePointerValue(value);
    onStopDragging(value, event);
  }
  function getKeyValue(event) {
    const { key: key2, shiftKey } = event, isValidKey = Object.keys(SliderKeyDirection).includes(key2);
    if (!isValidKey)
      return;
    const modifiedStep = !shiftKey ? $keyStep() : $keyStep() * $shiftKeyMultiplier(), direction = Number(SliderKeyDirection[key2]), diff = modifiedStep * direction, steps = ($store.value + diff) / $step();
    return Number(($step() * steps).toFixed(3));
  }
  function onDocumentPointerUp(event) {
    const value = getPointerValue(event);
    updatePointerValue(value, event);
    onStopDragging(value, event);
  }
  function onDocumentTouchMove(event) {
    event.preventDefault();
  }
  function onDocumentPointerMove(event) {
    updatePointerValue(getPointerValue(event), event);
  }
}

// src/player/ui/slider/create.tsx
var $$_templ7 = ['<!$><div part="track"></div>'];
var $$_templ_23 = ['<!$><div part="track track-fill"></div>'];
var $$_templ_3 = ['<!$><div part="track track-progress"></div>'];
var $$_templ_4 = ['<!$><div part="thumb-container"><div part="thumb"></div></div>'];
function createSlider(host, { $props, readonly, aria, ...callbacks }, accessors) {
  maverick_js.provideContext(sliderStoreContext);
  maverick_js.provideContext(sliderValueFormattersContext);
  const scope = maverick_js.getScope(), $store = maverick_js.useContext(sliderStoreContext), $focused = useFocusVisible(host.$el), { $disabled, $min, $max, $value, $step } = $props;
  host.setAttributes({
    disabled: $disabled,
    "data-dragging": () => $store.dragging,
    "data-pointing": () => $store.pointing,
    "data-interactive": () => $store.interactive,
    "aria-disabled": () => std.ariaBool($disabled()),
    "aria-valuemin": (aria == null ? void 0 : aria.valueMin) ?? (() => $store.min),
    "aria-valuemax": (aria == null ? void 0 : aria.valueMax) ?? (() => $store.max),
    "aria-valuenow": (aria == null ? void 0 : aria.valueNow) ?? (() => Math.round($store.value)),
    "aria-valuetext": (aria == null ? void 0 : aria.valueText) ?? (() => round($store.value / $store.max * 100, 2) + "%"),
    "data-media-slider": true
  });
  host.setCSSVars({
    "--slider-fill-rate": () => $store.fillRate,
    "--slider-fill-value": () => $store.value,
    "--slider-fill-percent": () => $store.fillPercent + "%",
    "--slider-pointer-rate": () => $store.pointerRate,
    "--slider-pointer-value": () => $store.pointerValue,
    "--slider-pointer-percent": () => $store.pointerPercent + "%"
  });
  useSliderEvents(host, $props, callbacks, $store);
  element.onAttach(() => {
    setAttributeIfEmpty(host.el, "role", "slider");
    setAttributeIfEmpty(host.el, "tabindex", "0");
    setAttributeIfEmpty(host.el, "aria-orientation", "horizontal");
    setAttributeIfEmpty(host.el, "autocomplete", "off");
  });
  maverick_js.effect(() => {
    $store.focused = $focused();
  });
  maverick_js.effect(() => {
    const target = host.$el();
    if (!target || $disabled())
      return;
    const preview = target.querySelector('[slot="preview"]');
    if (!preview)
      return;
    const rect = preview.getBoundingClientRect();
    const styles = {
      "--computed-width": rect.width + "px",
      "--computed-height": rect.height + "px",
      "--preview-top": "calc(-1 * var(--media-slider-preview-gap, calc(var(--preview-height) + 6px)))",
      "--preview-width": "var(--media-slider-preview-width, var(--computed-width))",
      "--preview-height": "var(--media-slider-preview-height, var(--computed-height))",
      "--preview-width-half": "calc(var(--preview-width) / 2)",
      "--preview-left-clamp": "max(var(--preview-width-half), var(--slider-pointer-percent))",
      "--preview-right-clamp": "calc(100% - var(--preview-width-half))",
      "--preview-left": "min(var(--preview-left-clamp), var(--preview-right-clamp))"
    };
    for (const name of Object.keys(styles)) {
      std.setStyle(preview, name, styles[name]);
    }
    function onPreviewResize() {
      const rect2 = preview.getBoundingClientRect();
      std.setStyle(preview, "--computed-width", rect2.width + "px");
      std.setStyle(preview, "--computed-height", rect2.height + "px");
    }
    window.requestAnimationFrame(onPreviewResize);
    const observer = new ResizeObserver(onPreviewResize);
    observer.observe(preview);
    return () => observer.disconnect();
  });
  if (!readonly) {
    maverick_js.effect(() => {
      $store.min = $min();
      $store.max = $max();
    });
    maverick_js.effect(() => {
      if (maverick_js.peek(() => $store.dragging))
        return;
      $store.value = getClampedValue($store.min, $store.max, $value(), $step());
    });
  }
  maverick_js.effect(() => {
    if (!$disabled())
      return;
    $store.dragging = false;
    $store.pointing = false;
  });
  return {
    $store,
    members: std.mergeProperties(
      accessors(),
      {
        get value() {
          return $store.value;
        },
        set value(value) {
          $store.value = value;
        },
        get $store() {
          return $store;
        },
        state: new Proxy($store, {
          set: std.noop
        }),
        subscribe: (callback) => maverick_js.scoped(() => maverick_js.effect(() => callback($store)), scope),
        $render: () => {
          return [ssr.$$_ssr($$_templ7), ssr.$$_ssr($$_templ_23), ssr.$$_ssr($$_templ_3), ssr.$$_ssr($$_templ_4)];
        }
      },
      {}
    )
  };
}

// src/player/ui/slider/props.ts
var sliderProps = {
  min: { initial: 0 },
  max: { initial: 100 },
  disabled: { initial: false, type: { from: false } },
  value: { initial: 100 },
  step: { initial: 1 },
  keyStep: { initial: 1 },
  shiftKeyMultiplier: { initial: 5 }
};

// src/player/ui/slider/element.ts
var SliderDefinition = element.defineCustomElement({
  tagName: "media-slider",
  props: sliderProps,
  setup({ host, props, accessors }) {
    const { members } = createSlider(host, { $props: props }, accessors);
    return members;
  }
});

// src/player/ui/slider-thumbnail/element.tsx
init_context();
var $$_templ8 = ['<!$><div part="container"><!$><img', ' part="img" loading="eager" decoding="async" /></div>'];
var SliderThumbnailDefinition = element.defineCustomElement({
  tagName: "media-slider-thumbnail",
  props: { src: { initial: "" } },
  setup({ host, props: { $src } }) {
    const $img = maverick_js.signal(null), $imgSrc = maverick_js.signal(""), $imgLoaded = maverick_js.signal(false), $error = maverick_js.signal(false), $coords = maverick_js.signal(null), $cueList = maverick_js.signal(null), $activeCue = maverick_js.signal(null), $hidden = () => $error() || !Number.isFinite($media.duration), $slider = useSliderStore(), { $store: $media } = useMedia();
    host.setAttributes({
      "data-loading": () => !$hidden() && !$imgLoaded(),
      "data-hidden": $hidden
    });
    maverick_js.effect(() => {
      if (!$media.canLoad)
        return;
      const video = document.createElement("video");
      video.crossOrigin = "";
      const track = document.createElement("track");
      track.src = $src();
      track.default = true;
      track.kind = "metadata";
      video.append(track);
      let cancelled = false;
      $error.set(false);
      $imgLoaded.set(false);
      track.onload = () => {
        if (cancelled)
          return;
        $cueList.set(track.track.cues);
      };
      track.onerror = () => $error.set(true);
      return () => {
        cancelled = true;
        $cueList.set(null);
      };
    });
    maverick_js.effect(() => {
      const cues = $cueList();
      if (!cues || !Number.isFinite($media.duration)) {
        $activeCue.set(null);
        return;
      }
      const currentTime = $slider.pointerRate * $media.duration;
      for (let i = 0; i < cues.length; i++) {
        if (currentTime >= cues[i].startTime && currentTime <= cues[i].endTime) {
          $activeCue.set(cues[i]);
          break;
        }
      }
    });
    maverick_js.effect(() => {
      const cue = $activeCue();
      if (!cue) {
        $imgSrc.set("");
        $coords.set(null);
        return;
      }
      const [_src, _coords] = (cue.text || "").split("#");
      const [_props, _values] = _coords.split("=");
      $imgSrc.set(
        !maverick_js.peek($src).startsWith("/") && _src.startsWith("/") ? `${new URL(maverick_js.peek($src)).origin}${_src}` : _src
      );
      if (_props && _values) {
        const coords = {}, values = _values.split(",");
        for (let i = 0; i < _props.length; i++)
          coords[_props[i]] = +values[i];
        $coords.set(coords);
      } else {
        $coords.set(null);
      }
    });
    maverick_js.effect(() => {
      $imgSrc();
      $imgLoaded.set(false);
    });
    const styleReverts = [];
    function applyStyle(el, name, value, priority) {
      el.style.setProperty(name, value, priority);
      styleReverts.push(() => el.style.removeProperty(name));
    }
    maverick_js.effect(() => {
      const img = $img(), coords = $coords();
      if (!img || !coords || !$imgLoaded()) {
        for (const revert of styleReverts)
          revert();
        return;
      }
      const { w, h, x, y } = coords, { maxWidth, maxHeight, minWidth, minHeight } = getComputedStyle(host.el), minRatio = Math.max(parseInt(minWidth) / w, parseInt(minHeight) / h), maxRatio = Math.min(parseInt(maxWidth) / w, parseInt(maxHeight) / h), scale = maxRatio < 1 ? maxRatio : minRatio > 1 ? minRatio : 1;
      styleReverts.length = 0;
      applyStyle(host.el, "--thumbnail-width", `${w * scale}px`);
      applyStyle(host.el, "--thumbnail-height", `${h * scale}px`);
      applyStyle(img, "width", `${img.naturalWidth * scale}px`);
      applyStyle(img, "height", `${img.naturalHeight * scale}px`);
      applyStyle(img, "transform", `translate(-${x * scale}px, -${y * scale}px)`);
    });
    return () => ssr.$$_ssr($$_templ8, ssr.$$_attr("src", $imgSrc));
  }
});

// src/player/ui/slider-value/element.tsx
init_number();

// src/utils/time.ts
function padNumberWithZeroes(num, expectedLength) {
  const str = String(num);
  const actualLength = str.length;
  const shouldPad = actualLength < expectedLength;
  if (shouldPad) {
    const padLength = expectedLength - actualLength;
    const padding = `0`.repeat(padLength);
    return `${padding}${num}`;
  }
  return str;
}
function parseTime(duration) {
  const hours = Math.trunc(duration / 3600);
  const minutes = Math.trunc(duration % 3600 / 60);
  const seconds = Math.trunc(duration % 60);
  const fraction = Number((duration - Math.trunc(duration)).toPrecision(3));
  return {
    hours,
    minutes,
    seconds,
    fraction
  };
}
function formatTime(duration, shouldPadHours = false, shouldAlwaysShowHours = false) {
  const { hours, minutes, seconds } = parseTime(duration);
  const paddedHours = shouldPadHours ? padNumberWithZeroes(hours, 2) : hours;
  const paddedMinutes = padNumberWithZeroes(minutes, 2);
  const paddedSeconds = padNumberWithZeroes(seconds, 2);
  if (hours > 0 || shouldAlwaysShowHours) {
    return `${paddedHours}:${paddedMinutes}:${paddedSeconds}`;
  }
  return `${minutes}:${paddedSeconds}`;
}
function formatSpokenTime(duration) {
  const spokenParts = [];
  const { hours, minutes, seconds } = parseTime(duration);
  const pluralize = (num, word) => num === 1 ? word : `${word}s`;
  if (hours > 0) {
    spokenParts.push(`${hours} ${pluralize(hours, "hour")}`);
  }
  if (minutes > 0) {
    spokenParts.push(`${minutes} ${pluralize(minutes, "minute")}`);
  }
  if (seconds > 0 || spokenParts.length === 0) {
    spokenParts.push(`${seconds} ${pluralize(seconds, "second")}`);
  }
  return spokenParts.join(", ");
}

// src/player/ui/slider-value/props.ts
var sliderValueTextProps = {
  type: { initial: "current" },
  format: {},
  showHours: { initial: false },
  padHours: { initial: false },
  decimalPlaces: { initial: 2 }
};

// src/player/ui/slider-value/element.tsx
var $$_templ9 = ["<!$><span><!$>", "</span>"];
var SliderValueDefinition = element.defineCustomElement({
  tagName: "media-slider-value",
  props: sliderValueTextProps,
  setup({ props: { $type, $format, $decimalPlaces, $padHours, $showHours } }) {
    const $slider = useSliderStore(), formatters = maverick_js.useContext(sliderValueFormattersContext);
    const $text = maverick_js.computed(() => {
      var _a4;
      const value = $type() === "current" ? $slider.value : $slider.pointerValue;
      const format = $format();
      if (format === "percent") {
        const range = $slider.max - $slider.min;
        const percent = value / range * 100;
        return (formatters.percent ?? round)(percent, $decimalPlaces()) + "\uFE6A";
      } else if (format === "time") {
        return (formatters.time ?? formatTime)(value, $padHours(), $showHours());
      } else {
        return ((_a4 = formatters.value) == null ? void 0 : _a4.call(formatters, value)) ?? value.toFixed(2);
      }
    });
    return () => ssr.$$_ssr($$_templ9, $text);
  }
});

// src/player/ui/slider-video/element.tsx
init_context();

// src/player/ui/slider-video/props.ts
var sliderVideoProps = {
  src: {}
};

// src/player/ui/slider-video/element.tsx
var $$_templ10 = ['<!$><video muted="" playsinline="" preload="auto"', ' part="video" style="max-width: unset"></video>'];
var SliderVideoDefinition = element.defineCustomElement({
  tagName: "media-slider-video",
  props: sliderVideoProps,
  setup({ host, props: { $src } }) {
    let videoElement = null;
    const $canPlay = maverick_js.signal(false), $error = maverick_js.signal(false), $slider = useSliderStore(), { $store: $media } = useMedia(), $videoSrc = () => $media.canLoad ? $src() : null, $hidden = () => !!$error() || !Number.isFinite($media.duration);
    host.setAttributes({
      "data-loading": () => !$canPlay() && !$hidden(),
      "data-hidden": $hidden
    });
    maverick_js.effect(() => {
      if ($canPlay() && videoElement && Number.isFinite($media.duration)) {
        videoElement.currentTime = $slider.pointerRate * $media.duration;
      }
    });
    maverick_js.effect(() => {
      $src();
      $canPlay.set(false);
      $error.set(false);
    });
    element.onConnect(() => {
      if (videoElement.readyState >= 2)
        onCanPlay();
    });
    function onCanPlay(trigger) {
      $canPlay.set(true);
      std.dispatchEvent(host.el, "can-play", { trigger });
    }
    return () => ssr.$$_ssr($$_templ10, ssr.$$_attr("src", $videoSrc));
  }
});
init_context();

// src/player/ui/time/props.ts
var timeProps = {
  type: { initial: "current" },
  showHours: { initial: false },
  padHours: { initial: false },
  remainder: { initial: false }
};

// src/player/ui/time/element.tsx
var $$_templ11 = ["<!$><span><!$>", "</span>"];
var TimeDefinition = element.defineCustomElement({
  tagName: "media-time",
  props: timeProps,
  setup({ props: { $remainder, $padHours, $showHours, $type } }) {
    const $media = useMedia().$store;
    const $formattedTime = maverick_js.computed(() => {
      const seconds = getSeconds($type(), $media), duration = $media.duration;
      if (!Number.isFinite(seconds + duration))
        return "LIVE";
      const time = $remainder() ? Math.max(0, duration - seconds) : seconds;
      return formatTime(time, $padHours(), $showHours());
    });
    return () => ssr.$$_ssr($$_templ11, $formattedTime);
  }
});
function getSeconds(type, $media) {
  switch (type) {
    case "buffered":
      return $media.bufferedEnd;
    case "duration":
      return $media.duration;
    default:
      return $media.currentTime;
  }
}

// src/player/ui/time-slider/element.tsx
init_just_throttle();
init_context();

// src/player/ui/time-slider/props.ts
var timeSliderProps = {
  ...sliderProps,
  min: { initial: 0, attribute: false },
  max: { initial: 0, attribute: false },
  value: { initial: 0, attribute: false },
  pauseWhileDragging: { initial: false },
  seekingRequestThrottle: { initial: 100 }
};

// src/player/ui/time-slider/element.tsx
var TimeSliderDefinition = element.defineCustomElement({
  tagName: "media-time-slider",
  props: timeSliderProps,
  setup({
    host,
    props: { $pauseWhileDragging, $seekingRequestThrottle, $disabled, ...props },
    accessors
  }) {
    const { $store: $media, remote } = useMedia(), { $store, members } = createSlider(
      host,
      {
        $props: {
          ...props,
          $step: () => props.$step() / $media.duration * 100,
          $keyStep: () => props.$keyStep() / $media.duration * 100,
          $disabled: () => $disabled() || !$media.canSeek
        },
        readonly: true,
        aria: { valueMin: 0, valueMax: 100, valueText: getSpokenText },
        onDragStart,
        onDragEnd,
        onValueChange,
        onDragValueChange
      },
      accessors
    );
    element.onAttach(() => {
      setAttributeIfEmpty(host.el, "aria-label", "Media time");
    });
    maverick_js.effect(() => {
      const newValue = getPercent($media.currentTime);
      if (!maverick_js.peek(() => $store.dragging)) {
        $store.value = newValue;
        std.dispatchEvent(host.el, "value-change", { detail: newValue });
      }
    });
    let dispatchSeeking;
    maverick_js.effect(() => {
      dispatchSeeking = functionThrottle(seeking, $seekingRequestThrottle());
    });
    function seeking(time, event) {
      remote.seeking(time, event);
    }
    function seek(time, percent, event) {
      dispatchSeeking.cancel();
      if ($media.live && percent >= 99) {
        remote.seekToLiveEdge(event);
        return;
      }
      remote.seek(time, event);
    }
    let wasPlayingBeforeDragStart = false;
    function onDragStart(event) {
      if ($pauseWhileDragging()) {
        wasPlayingBeforeDragStart = !$media.paused;
        remote.pause(event);
      }
    }
    function onValueChange(event) {
      if ($store.dragging || !event.trigger)
        return;
      onDragEnd(event);
    }
    function onDragValueChange(event) {
      dispatchSeeking(getTime(event.detail), event);
    }
    function onDragEnd(event) {
      const percent = event.detail;
      seek(getTime(percent), percent, event);
      if ($pauseWhileDragging() && wasPlayingBeforeDragStart) {
        remote.play(event);
        wasPlayingBeforeDragStart = false;
      }
    }
    function getTime(percent) {
      return Math.round(percent / 100 * $media.duration);
    }
    function getPercent(time) {
      const rate = Math.max(
        0,
        Math.min(1, $media.liveEdge ? 1 : Math.min(time, $media.duration) / $media.duration)
      );
      return Number.isNaN(rate) ? 0 : Number.isFinite(rate) ? rate * 100 : 100;
    }
    function getSpokenText() {
      const time = getTime($store.value);
      return Number.isFinite(time) ? `${formatSpokenTime(time)} out of ${formatSpokenTime($media.duration)}` : "live";
    }
    maverick_js.provideContext(sliderValueFormattersContext, {
      value(percent) {
        const time = getTime(percent);
        return Number.isFinite(time) ? ($media.live ? time - $media.duration : time).toFixed(0) : "LIVE";
      },
      time(percent, padHours, showHours) {
        const time = getTime(percent);
        const value = $media.live ? time - $media.duration : time;
        return Number.isFinite(time) ? `${value < 0 ? "-" : ""}${formatTime(Math.abs(value), padHours, showHours)}` : "LIVE";
      }
    });
    return std.mergeProperties(members, {
      get min() {
        return members.min;
      },
      get max() {
        return members.max;
      },
      get value() {
        return members.value;
      }
    });
  }
});
var ToggleButtonDefinition = element.defineCustomElement({
  tagName: "media-toggle-button",
  props: toggleButtonProps,
  setup({ host, props }) {
    const $pressed = maverick_js.signal(props.$defaultPressed()), toggle = useToggleButton(host, {
      $props: { ...props, $pressed },
      onPress
    });
    function onPress() {
      if (props.$disabled())
        return;
      $pressed.set((p) => !p);
    }
    return toggle;
  }
});

// src/player/ui/volume-slider/element.tsx
init_just_throttle();
init_number();
init_context();

// src/player/ui/volume-slider/props.ts
var volumeSliderProps = {
  ...sliderProps,
  min: { initial: 0, attribute: false },
  max: { initial: 100, attribute: false },
  value: { initial: 100, attribute: false }
};

// src/player/ui/volume-slider/element.tsx
var VolumeSliderDefinition = element.defineCustomElement({
  tagName: "media-volume-slider",
  props: volumeSliderProps,
  setup({ host, props, accessors }) {
    const { $store: $media, remote } = useMedia(), { $store, members } = createSlider(
      host,
      {
        $props: props,
        readonly: true,
        aria: { valueMin: 0, valueMax: 100 },
        onValueChange: functionThrottle(onVolumeChange, 25)
      },
      accessors
    );
    element.onAttach(() => {
      setAttributeIfEmpty(host.el, "aria-label", "Media volume");
    });
    maverick_js.effect(() => {
      const newValue = $media.muted ? 0 : $media.volume * 100;
      $store.value = newValue;
      std.dispatchEvent(host.el, "value-change", { detail: newValue });
    });
    function onVolumeChange(event) {
      if (!event.trigger)
        return;
      const mediaVolume = round(event.detail / 100, 3);
      remote.changeVolume(mediaVolume, event);
    }
    return std.mergeProperties(members, {
      get min() {
        return members.min;
      },
      get max() {
        return members.max;
      },
      get value() {
        return members.value;
      }
    });
  }
});

Object.defineProperty(exports, 'appendTriggerEvent', {
  enumerable: true,
  get: function () { return std.appendTriggerEvent; }
});
Object.defineProperty(exports, 'findTriggerEvent', {
  enumerable: true,
  get: function () { return std.findTriggerEvent; }
});
Object.defineProperty(exports, 'hasTriggerEvent', {
  enumerable: true,
  get: function () { return std.hasTriggerEvent; }
});
Object.defineProperty(exports, 'walkTriggerEventChain', {
  enumerable: true,
  get: function () { return std.walkTriggerEventChain; }
});
exports.FullscreenButtonDefinition = FullscreenButtonDefinition;
exports.LiveIndicatorDefinition = LiveIndicatorDefinition;
exports.MediaIconDefinition = MediaIconDefinition;
exports.MuteButtonDefinition = MuteButtonDefinition;
exports.OutletDefinition = OutletDefinition;
exports.PlayButtonDefinition = PlayButtonDefinition;
exports.PosterDefinition = PosterDefinition;
exports.SeekButtonDefinition = SeekButtonDefinition;
exports.SliderDefinition = SliderDefinition;
exports.SliderThumbnailDefinition = SliderThumbnailDefinition;
exports.SliderValueDefinition = SliderValueDefinition;
exports.SliderVideoDefinition = SliderVideoDefinition;
exports.TimeDefinition = TimeDefinition;
exports.TimeSliderDefinition = TimeSliderDefinition;
exports.ToggleButtonDefinition = ToggleButtonDefinition;
exports.VolumeSliderDefinition = VolumeSliderDefinition;
exports.createTimeRanges = createTimeRanges;
exports.getTimeRangesEnd = getTimeRangesEnd;
exports.getTimeRangesStart = getTimeRangesStart;
exports.isAudioProvider = isAudioProvider;
exports.isHLSProvider = isHLSProvider;
exports.isHTMLAudioElement = isHTMLAudioElement;
exports.isHTMLVideoElement = isHTMLVideoElement;
exports.isVideoProvider = isVideoProvider;
exports.sliderStore = sliderStore;
exports.sliderStoreContext = sliderStoreContext;
exports.softResetMediaStore = softResetMediaStore;
exports.useSliderStore = useSliderStore;
