import { AUDIO_EXTENSIONS, AUDIO_TYPES, VIDEO_EXTENSIONS, VIDEO_TYPES, isHLSSrc, HLS_VIDEO_EXTENSIONS, HLS_VIDEO_TYPES } from './chunk-K2X6MWIX.js';
import { MediaRemoteControl, preconnect } from './chunk-FL2I7HKN.js';
import { functionThrottle } from './chunk-JELAJF2G.js';
import { canOrientScreen, isHLSSupported, IS_IOS, canPlayHLSNatively } from './chunk-LNPU55YF.js';
import { clampNumber, round } from './chunk-CVLY5S52.js';
import { useKeyboard, MEDIA_KEY_SHORTCUTS } from './chunk-HNFYBM6K.js';
import { useFocusVisible } from './chunk-YQSJJLRL.js';
import { mediaContext } from './chunk-3ULVZKKX.js';
import { listenEvent, dispatchEvent, isNull, camelToKebabCase, mergeProperties, noop, isArray, isUndefined, isString, isObject, keysOf, useDisposalBin, appendTriggerEvent, createEvent, isNumber, DOMEvent, deferredPromise } from 'maverick.js/std';
import { createStore, signal, getScope, effect, onDispose, scoped, tick, provideContext, computed, peek, root } from 'maverick.js';
import { defineCustomElement, onAttach, onConnect } from 'maverick.js/element';
import { $$_create_walker, $$_effect, $$_attr, $$_ref, $$_create_template } from 'maverick.js/dom';

function getRange(fnName, valueIndex, ranges, rangeIndex) {
  throwIfOutOfRange(fnName, rangeIndex, ranges.length - 1);
  return ranges[rangeIndex][valueIndex] || Infinity;
}
function buildTimeRanges(ranges) {
  if (isUndefined(ranges) || ranges.length === 0) {
    return { length: 0, start: emptyTimeRange, end: emptyTimeRange };
  }
  return {
    length: ranges.length,
    start: getRange.bind(null, "start", 0, ranges),
    end: getRange.bind(null, "end", 1, ranges)
  };
}
function createTimeRanges(start, end) {
  if (isArray(start)) {
    return buildTimeRanges(start);
  } else if (isUndefined(start) || isUndefined(end)) {
    return buildTimeRanges();
  }
  return buildTimeRanges([[start, end]]);
}
function getTimeRangesStart(ranges) {
  if (!ranges.length)
    return null;
  let min = ranges.start(0);
  for (let i = 1; i < ranges.length; i++) {
    const value = ranges.start(i);
    if (value < min)
      min = value;
  }
  return min;
}
function getTimeRangesEnd(ranges) {
  if (!ranges.length)
    return null;
  let max = ranges.end(0);
  for (let i = 1; i < ranges.length; i++) {
    const value = ranges.end(i);
    if (value > max)
      max = value;
  }
  return max;
}
function throwIfOutOfRange(fnName, index, end) {
  if (!isNumber(index) || index < 0 || index > end) {
    throw new Error(
      `Failed to execute '${fnName}' on 'TimeRanges': The index provided (${index}) is non-numeric or out of bounds (0-${end}).`
    );
  }
}
function emptyTimeRange() {
  throw new Error("`TimeRanges` object is empty." );
}
var mediaStore = createStore({
  autoplay: false,
  autoplayError: void 0,
  buffered: createTimeRanges(),
  duration: 0,
  canLoad: false,
  canFullscreen: false,
  canPlay: false,
  controls: false,
  poster: "",
  currentTime: 0,
  ended: false,
  error: void 0,
  fullscreen: false,
  loop: false,
  logLevel: "warn" ,
  mediaType: "unknown",
  muted: false,
  paused: true,
  played: createTimeRanges(),
  playing: false,
  playsinline: false,
  preload: "metadata",
  seekable: createTimeRanges(),
  seeking: false,
  source: { src: "", type: "" },
  sources: [],
  started: false,
  volume: 1,
  waiting: false,
  get viewType() {
    return this.providedViewType !== "unknown" ? this.providedViewType : this.mediaType;
  },
  get streamType() {
    return this.providedStreamType !== "unknown" ? this.providedStreamType : this.inferredStreamType;
  },
  get currentSrc() {
    return this.source;
  },
  get bufferedStart() {
    return getTimeRangesStart(this.buffered) ?? 0;
  },
  get bufferedEnd() {
    return getTimeRangesEnd(this.buffered) ?? 0;
  },
  get seekableStart() {
    return getTimeRangesStart(this.seekable) ?? 0;
  },
  get seekableEnd() {
    return this.canPlay ? getTimeRangesEnd(this.seekable) ?? Infinity : 0;
  },
  get seekableWindow() {
    return Math.max(0, this.seekableEnd - this.seekableStart);
  },
  userIdle: false,
  userBehindLiveEdge: false,
  liveEdgeTolerance: 10,
  minLiveDVRWindow: 60,
  get canSeek() {
    return /unknown|on-demand|:dvr/.test(this.streamType) && Number.isFinite(this.seekableWindow) && (!this.live || /:dvr/.test(this.streamType) && this.seekableWindow >= this.minLiveDVRWindow);
  },
  get live() {
    return this.streamType.includes("live") || !Number.isFinite(this.duration);
  },
  get liveEdgeStart() {
    return this.live && Number.isFinite(this.seekableEnd) ? Math.max(0, (this.liveSyncPosition ?? this.seekableEnd) - this.liveEdgeTolerance) : 0;
  },
  get liveEdge() {
    return this.live && (!this.canSeek || !this.userBehindLiveEdge && this.currentTime >= this.liveEdgeStart);
  },
  get liveEdgeWindow() {
    return this.live && Number.isFinite(this.seekableEnd) ? this.seekableEnd - this.liveEdgeStart : 0;
  },
  attemptingAutoplay: false,
  canLoadPoster: null,
  providedViewType: "unknown",
  providedStreamType: "unknown",
  inferredStreamType: "unknown",
  liveSyncPosition: null
});
var DO_NOT_RESET_ON_SRC_CHANGE = /* @__PURE__ */ new Set([
  "autoplay",
  "canFullscreen",
  "canLoad",
  "controls",
  "loop",
  "logLevel",
  "muted",
  "playsinline",
  "preload",
  "poster",
  "source",
  "sources",
  "volume",
  "canLoadPoster",
  "providedStreamType",
  "providedViewType"
]);
function softResetMediaStore($media) {
  mediaStore.reset($media, (prop) => !DO_NOT_RESET_ON_SRC_CHANGE.has(prop));
  tick();
}

// src/foundation/logger/colors.ts
var LOCAL_STORAGE_KEY = "@vidstack/log-colors";
var savedColors = init();
function getLogColor(key2) {
  return savedColors.get(key2);
}
function saveLogColor(key2, { color = generateColor(), overwrite = false } = {}) {
  if (!savedColors.has(key2) || overwrite) {
    savedColors.set(key2, color);
    localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(Object.entries(savedColors)));
  }
}
function generateColor() {
  return `hsl(${Math.random() * 360}, 55%, 70%)`;
}
function init() {
  let colors;
  try {
    colors = JSON.parse(localStorage.getItem(LOCAL_STORAGE_KEY));
  } catch {
  }
  return new Map(Object.entries(colors ?? {}));
}
var GROUPED_LOG = Symbol("GROUPED_LOG");
function isGroupedLog(data) {
  return isObject(data) && data[GROUPED_LOG];
}
function createGroupedLog(title, parent) {
  const logs = [];
  const group = {
    [GROUPED_LOG]: true,
    title,
    logs,
    log(...data) {
      logs.push({ data });
      return group;
    },
    labelledLog(label, ...data) {
      logs.push({ label, data });
      return group;
    },
    groupStart(title2) {
      return createGroupedLog(title2, group);
    },
    groupEnd() {
      parent?.logs.push(group);
      return parent ?? group;
    }
  };
  return group;
}

// src/foundation/logger/log-level.ts
var LogLevelValue = Object.freeze({
  silent: 0,
  error: 1,
  warn: 2,
  info: 3,
  debug: 4
});
var LogLevelColor = Object.freeze({
  silent: "white",
  error: "hsl(6, 58%, 50%)",
  warn: "hsl(51, 58%, 50%)",
  info: "hsl(219, 58%, 50%)",
  debug: "hsl(280, 58%, 50%)"
});

// src/foundation/logger/ms.ts
var s = 1e3;
var m = s * 60;
var h = m * 60;
var d = h * 24;
function ms(val) {
  const msAbs = Math.abs(val);
  if (msAbs >= d) {
    return Math.round(val / d) + "d";
  }
  if (msAbs >= h) {
    return Math.round(val / h) + "h";
  }
  if (msAbs >= m) {
    return Math.round(val / m) + "m";
  }
  if (msAbs >= s) {
    return Math.round(val / s) + "s";
  }
  return round(val, 2) + "ms";
}

// src/foundation/logger/log-printer.ts
function createLogPrinter($target) {
  let logLevel = "warn", lastLogTimestamp = void 0;
  effect(() => {
    const target = $target();
    if (!target)
      return;
    listenEvent(target, "vds-log", (event) => {
      event.stopPropagation();
      const eventTargetName = (event.path?.[0] ?? event.target).tagName.toLowerCase();
      const { level = "warn", data } = event.detail ?? {};
      if (LogLevelValue[logLevel] < LogLevelValue[level]) {
        return;
      }
      saveLogColor(eventTargetName);
      const hint = data?.length === 1 && isGroupedLog(data[0]) ? data[0].title : isString(data?.[0]) ? data[0] : "";
      console.groupCollapsed(
        `%c${level.toUpperCase()}%c ${eventTargetName}%c ${hint.slice(0, 50)}${hint.length > 50 ? "..." : ""}`,
        `background: ${LogLevelColor[level]}; color: white; padding: 1.5px 2.2px; border-radius: 2px; font-size: 11px;`,
        `color: ${getLogColor(eventTargetName)}; padding: 4px 0px; font-size: 11px;`,
        "color: gray; font-size: 11px; padding-left: 4px;"
      );
      if (data?.length === 1 && isGroupedLog(data[0])) {
        printGroup(level, data[0]);
      } else if (data) {
        print(level, ...data);
      }
      printTimeDiff();
      printStackTrace();
      console.groupEnd();
    });
    return () => {
      lastLogTimestamp = void 0;
    };
  });
  const calcLastLogTimeDiff = () => {
    const time = performance.now();
    const diff = time - (lastLogTimestamp ?? (lastLogTimestamp = performance.now()));
    lastLogTimestamp = time;
    return ms(diff);
  };
  const printTimeDiff = () => {
    labelledPrint("Time since last log", calcLastLogTimeDiff());
  };
  return {
    get logLevel() {
      return logLevel;
    },
    set logLevel(level) {
      logLevel = level;
    }
  };
}
function print(level, ...data) {
  console[level](...data);
}
function labelledPrint(label, ...data) {
  console.log(`%c${label}:`, "color: gray", ...data);
}
function printStackTrace() {
  console.groupCollapsed("%cStack Trace", "color: gray");
  console.trace();
  console.groupEnd();
}
function printGroup(level, groupedLog) {
  console.groupCollapsed(groupedLog.title);
  for (const log of groupedLog.logs) {
    if (isGroupedLog(log)) {
      printGroup(level, log);
    } else if ("label" in log && !isUndefined(log.label)) {
      labelledPrint(log.label, ...log.data);
    } else {
      print(level, ...log.data);
    }
  }
  console.groupEnd();
}
function dispatchLogEvent(target, level, ...data) {
  return dispatchEvent(target, "vds-log", {
    bubbles: true,
    composed: true,
    detail: { level, data }
  });
}

// src/foundation/logger/create-logger.ts
function createLogger() {
  let target = null;
  const createGroupedLogger = (level, title, rootGroup, parentGroup) => {
    const group = createGroupedLog(title, parentGroup);
    group.dispatch = () => dispatchLogEvent(target, level, rootGroup ?? group);
    return {
      ...group,
      groupStart: (title2) => createGroupedLogger(level, title2, rootGroup ?? group, group)
    };
  };
  return {
    error: (...data) => dispatchLogEvent(target, "error", ...data),
    warn: (...data) => dispatchLogEvent(target, "warn", ...data),
    info: (...data) => dispatchLogEvent(target, "info", ...data),
    debug: (...data) => dispatchLogEvent(target, "debug", ...data),
    errorGroup: (title) => createGroupedLogger("error", title),
    warnGroup: (title) => createGroupedLogger("warn", title),
    infoGroup: (title) => createGroupedLogger("info", title),
    debugGroup: (title) => createGroupedLogger("debug", title),
    setTarget: (newTarget) => {
      target = newTarget;
    }
  };
}

// src/foundation/logger/logger.ts
var loggers = /* @__PURE__ */ new WeakMap();
function useLogger($target) {
  const logger = loggers.get($target) ?? createLogger();
  if (!loggers.has($target)) {
    effect(() => logger.setTarget($target()));
    loggers.set($target, logger);
  }
  return logger;
}
function createIntersectionObserverAdapter($target, init2 = {}) {
  const $intersecting = signal(false), { skipInitial, callback, ...observerInit } = init2;
  let disconnect;
  effect(() => {
    const target = $target();
    if (!target) {
      $intersecting.set(false);
      return;
    }
    let first = true;
    const observer = new IntersectionObserver((entries) => {
      if (first && skipInitial) {
        first = false;
        return;
      }
      callback?.(entries, observer);
      $intersecting.set(entries[0].isIntersecting);
    }, observerInit);
    observer.observe(target);
    return disconnect = () => {
      observer.disconnect();
      disconnect = void 0;
    };
  });
  return {
    get intersecting() {
      return $intersecting();
    },
    disconnect() {
      disconnect?.();
    }
  };
}

// src/player/media/controller/can-load.ts
function useMediaCanLoad($controller, $load, callback) {
  onConnect(async () => {
    const load = $load();
    if (load === "eager") {
      requestAnimationFrame(callback);
    } else if (load === "idle") {
      const { waitIdlePeriod } = await import('maverick.js/std');
      waitIdlePeriod(callback);
    } else if (load === "visible") {
      root(async (dispose) => {
        const io = createIntersectionObserverAdapter($controller);
        effect(() => {
          if (io.intersecting) {
            callback();
            dispose();
          }
        });
      });
    }
  });
}
function createMediaControllerDelegate({ $player, $store, logger }, handle) {
  const dispatch = (type, ...init2) => {
    handle(new DOMEvent(type, init2?.[0]));
  };
  async function ready(info, trigger) {
    if (peek(() => $store.canPlay))
      return;
    dispatch("can-play", { detail: info, trigger });
    tick();
    {
      logger?.infoGroup("-~-~-~-~-~-~-~-~- \u2705 MEDIA READY -~-~-~-~-~-~-~-~-").labelledLog("Media Store", { ...$store }).labelledLog("Trigger Event", trigger).dispatch();
    }
    if ($store.canPlay && $store.autoplay && !$store.started) {
      await attemptAutoplay();
    }
  }
  async function attemptAutoplay() {
    $store.attemptingAutoplay = true;
    try {
      await $player().play();
      dispatch("autoplay", { detail: { muted: $store.muted } });
    } catch (error) {
      dispatch("autoplay-fail", {
        detail: {
          muted: $store.muted,
          error
        }
      });
    } finally {
      $store.attemptingAutoplay = false;
    }
  }
  return {
    dispatch,
    ready
  };
}
var mediaEvents = [
  "abort",
  "can-play",
  "can-play-through",
  "duration-change",
  "emptied",
  "ended",
  "error",
  "fullscreen-change",
  "loaded-data",
  "loaded-metadata",
  "load-start",
  "media-type-change",
  "pause",
  "play",
  "playing",
  "progress",
  "seeked",
  "seeking",
  "source-change",
  "sources-change",
  "stalled",
  "started",
  "suspend",
  "stream-type-change",
  "replay",
  "view-type-change",
  "volume-change",
  "waiting"
] ;
function useMediaEventsLogger({ $player, $store }, logger) {
  effect(() => {
    const player = $player();
    if (player) {
      for (const eventType of mediaEvents) {
        listenEvent(player, eventType, (event) => {
          logger?.infoGroup(`\u{1F4E1} dispatching \`${eventType}\``).labelledLog("Media Store", { ...$store }).labelledLog("Event", event).dispatch();
        });
      }
    }
  });
}
function useMediaPropChange({ $player, $store }, {
  $autoplay,
  $poster,
  $loop,
  $controls,
  $playsinline,
  $logLevel,
  $liveEdgeTolerance,
  $minLiveDVRWindow
}) {
  effect(() => {
    const player = $player();
    if (!player)
      return;
    {
      effect(() => {
        $store.logLevel = $logLevel();
      });
    }
    effect(() => {
      const autoplay = $autoplay();
      $store.autoplay = autoplay;
      dispatchEvent(player, "autoplay-change", { detail: autoplay });
    });
    effect(() => {
      const poster = $poster();
      $store.poster = poster;
      dispatchEvent(player, "poster-change", { detail: poster });
    });
    effect(() => {
      const loop = $loop();
      $store.loop = loop;
      dispatchEvent(player, "loop-change", { detail: loop });
    });
    effect(() => {
      const controls = $controls();
      $store.controls = controls;
      dispatchEvent(player, "controls-change", { detail: controls });
    });
    effect(() => {
      const playsinline = $playsinline();
      $store.playsinline = playsinline;
      dispatchEvent(player, "playsinline-change", { detail: playsinline });
    });
    effect(() => {
      $store.liveEdgeTolerance = $liveEdgeTolerance();
      $store.minLiveDVRWindow = $minLiveDVRWindow();
    });
    effect(() => {
      dispatchEvent(player, "live-change", { detail: $store.live });
    });
    effect(() => {
      dispatchEvent(player, "live-edge-change", { detail: $store.liveEdge });
    });
  });
}
var RequestQueue = class {
  constructor() {
    this._serving = false;
    this._pending = deferredPromise();
    this._queue = /* @__PURE__ */ new Map();
  }
  get _size() {
    return this._queue.size;
  }
  get _isServing() {
    return this._serving;
  }
  async _waitForFlush() {
    if (this._serving)
      return;
    await this._pending.promise;
  }
  _enqueue(key2, callback) {
    if (this._serving) {
      callback();
      return;
    }
    this._queue.delete(key2);
    this._queue.set(key2, callback);
  }
  _serve(key2) {
    this._queue.get(key2)?.();
    this._queue.delete(key2);
  }
  _start() {
    this._flush();
    this._serving = true;
    if (this._queue.size > 0)
      this._flush();
  }
  _stop() {
    this._serving = false;
  }
  _reset() {
    this._stop();
    this._queue.clear();
    this._release();
  }
  _flush() {
    for (const key2 of this._queue.keys())
      this._serve(key2);
    this._release();
  }
  _release() {
    this._pending.resolve();
    this._pending = deferredPromise();
  }
};

// src/player/media/controller/provider-delegate.ts
function useMediaProviderDelegate({ $provider, $store: $media }, requestManager, { $paused, $volume, $muted, $currentTime, $playsinline }) {
  const canPlayQueue = new RequestQueue();
  effect(() => {
    if ($media.canPlay && $provider())
      canPlayQueue._start();
    else
      canPlayQueue._stop();
  });
  effect(() => setMuted($muted()));
  effect(() => setPaused($paused()));
  effect(() => setVolume($volume()));
  effect(() => setCurrentTime($currentTime()));
  effect(() => setPlaysinline($playsinline()));
  function setPaused(paused) {
    if (paused)
      canPlayQueue._enqueue("paused", requestManager._pause);
    else
      canPlayQueue._enqueue("paused", requestManager._play);
  }
  function setVolume(volume) {
    const newVolume = clampNumber(0, volume, 1);
    canPlayQueue._enqueue("volume", () => $provider().volume = newVolume);
  }
  function setMuted(muted) {
    canPlayQueue._enqueue("muted", () => $provider().muted = muted);
  }
  function setCurrentTime(currentTime) {
    canPlayQueue._enqueue("currentTime", () => {
      const adapter = $provider();
      if (currentTime !== adapter.currentTime) {
        peek(() => {
          const boundTime = Math.min(
            Math.max($media.seekableStart + 0.1, currentTime),
            $media.seekableEnd - 0.1
          );
          if (Number.isFinite(boundTime))
            adapter.currentTime = boundTime;
        });
      }
    });
  }
  function setPlaysinline(playsinline) {
    canPlayQueue._enqueue("playsinline", () => $provider().playsinline = playsinline);
  }
  const delegate = {};
  const setters = {
    paused: setPaused,
    muted: setMuted,
    volume: setVolume,
    currentTime: setCurrentTime,
    playsinline: setPlaysinline
  };
  for (const prop of Object.keys(setters)) {
    Object.defineProperty(delegate, prop, {
      get: () => $media[prop],
      set: setters[prop]
    });
  }
  return delegate;
}

// ../../node_modules/.pnpm/fscreen@1.2.0/node_modules/fscreen/dist/fscreen.esm.js
var key = {
  fullscreenEnabled: 0,
  fullscreenElement: 1,
  requestFullscreen: 2,
  exitFullscreen: 3,
  fullscreenchange: 4,
  fullscreenerror: 5,
  fullscreen: 6
};
var webkit = [
  "webkitFullscreenEnabled",
  "webkitFullscreenElement",
  "webkitRequestFullscreen",
  "webkitExitFullscreen",
  "webkitfullscreenchange",
  "webkitfullscreenerror",
  "-webkit-full-screen"
];
var moz = [
  "mozFullScreenEnabled",
  "mozFullScreenElement",
  "mozRequestFullScreen",
  "mozCancelFullScreen",
  "mozfullscreenchange",
  "mozfullscreenerror",
  "-moz-full-screen"
];
var ms2 = [
  "msFullscreenEnabled",
  "msFullscreenElement",
  "msRequestFullscreen",
  "msExitFullscreen",
  "MSFullscreenChange",
  "MSFullscreenError",
  "-ms-fullscreen"
];
var document = typeof window !== "undefined" && typeof window.document !== "undefined" ? window.document : {};
var vendor = "fullscreenEnabled" in document && Object.keys(key) || webkit[0] in document && webkit || moz[0] in document && moz || ms2[0] in document && ms2 || [];
var fscreen = {
  requestFullscreen: function(element) {
    return element[vendor[key.requestFullscreen]]();
  },
  requestFullscreenFunction: function(element) {
    return element[vendor[key.requestFullscreen]];
  },
  get exitFullscreen() {
    return document[vendor[key.exitFullscreen]].bind(document);
  },
  get fullscreenPseudoClass() {
    return ":" + vendor[key.fullscreen];
  },
  addEventListener: function(type, handler, options) {
    return document.addEventListener(vendor[key[type]], handler, options);
  },
  removeEventListener: function(type, handler, options) {
    return document.removeEventListener(vendor[key[type]], handler, options);
  },
  get fullscreenEnabled() {
    return Boolean(document[vendor[key.fullscreenEnabled]]);
  },
  set fullscreenEnabled(val) {
  },
  get fullscreenElement() {
    return document[vendor[key.fullscreenElement]];
  },
  set fullscreenElement(val) {
  },
  get onfullscreenchange() {
    return document[("on" + vendor[key.fullscreenchange]).toLowerCase()];
  },
  set onfullscreenchange(handler) {
    return document[("on" + vendor[key.fullscreenchange]).toLowerCase()] = handler;
  },
  get onfullscreenerror() {
    return document[("on" + vendor[key.fullscreenerror]).toLowerCase()];
  },
  set onfullscreenerror(handler) {
    return document[("on" + vendor[key.fullscreenerror]).toLowerCase()] = handler;
  }
};
var fscreen_esm_default = fscreen;
function createFullscreenAdapter($target) {
  const $active = signal(false), exit = () => exitFullscreen(peek($target));
  let listening = false;
  effect(() => {
    const target = $target();
    if (target) {
      listenEvent(fscreen_esm_default, "fullscreenchange", async (trigger) => {
        const active = isFullscreen(target);
        if (active === $active())
          return;
        if (!active)
          listening = false;
        $active.set(active);
        dispatchEvent(target, "fullscreen-change", { detail: active, trigger });
      });
      listenEvent(fscreen_esm_default, "fullscreenerror", (trigger) => {
        if (!listening)
          return;
        dispatchEvent(target, "fullscreen-error", { detail: null, trigger });
        listening = false;
      });
      return async () => {
        if (canFullscreen())
          await exit();
      };
    }
    return;
  });
  return {
    get active() {
      return $active();
    },
    get supported() {
      return canFullscreen();
    },
    async enter() {
      try {
        listening = true;
        return await requestFullscreen(peek($target));
      } catch (error) {
        listening = false;
        throw error;
      }
    },
    exit
  };
}
function canFullscreen() {
  return fscreen_esm_default.fullscreenEnabled;
}
function isFullscreen(host) {
  if (fscreen_esm_default.fullscreenElement === host)
    return true;
  try {
    return host.matches(
      fscreen_esm_default.fullscreenPseudoClass
    );
  } catch (error) {
    return false;
  }
}
async function requestFullscreen(host) {
  if (!host || isFullscreen(host))
    return;
  assertFullscreenAPI();
  return fscreen_esm_default.requestFullscreen(host);
}
async function exitFullscreen(host) {
  if (!host || !isFullscreen(host))
    return;
  assertFullscreenAPI();
  return fscreen_esm_default.exitFullscreen();
}
function assertFullscreenAPI() {
  if (canFullscreen())
    return;
  throw Error(
    "[vidstack] fullscreen API is not enabled or supported in this environment" 
  );
}
var CAN_ORIENT_SCREEN = canOrientScreen();
function createScreenOrientationAdapter($target) {
  const $orientation = signal(getScreenOrientation()), $locked = signal(false);
  let currentLock;
  if (CAN_ORIENT_SCREEN) {
    effect(() => {
      const target = $target();
      if (!target)
        return;
      listenEvent(screen.orientation, "change", (trigger) => {
        const orientation = getScreenOrientation();
        $orientation.set(orientation);
        dispatchEvent(target, "orientation-change", {
          detail: { orientation, lock: currentLock },
          trigger
        });
      });
      return async () => {
        if (CAN_ORIENT_SCREEN && $locked())
          await unlock();
      };
    });
  }
  async function lock(lockType) {
    if (peek($locked))
      return;
    assertScreenOrientationAPI();
    await screen.orientation.lock(lockType);
    $locked.set(true);
    currentLock = lockType;
  }
  async function unlock() {
    if (!peek($locked))
      return;
    assertScreenOrientationAPI();
    currentLock = void 0;
    await screen.orientation.unlock();
    $locked.set(false);
  }
  return {
    get orientation() {
      return $orientation();
    },
    get locked() {
      return $locked();
    },
    get supported() {
      return CAN_ORIENT_SCREEN;
    },
    lock,
    unlock
  };
}
function assertScreenOrientationAPI() {
  if (!CAN_ORIENT_SCREEN)
    return;
  throw Error(
    "[vidstack] screen orientation API is not available" 
  );
}
function getScreenOrientation() {
  return window.screen?.orientation?.type;
}

// src/foundation/queue/queue.ts
var Queue = class {
  constructor() {
    this._queue = /* @__PURE__ */ new Map();
  }
  _enqueue(key2, item) {
    if (!this._queue.has(key2))
      this._queue.set(key2, /* @__PURE__ */ new Set());
    this._queue.get(key2).add(item);
  }
  _serve(key2, callback) {
    const items = this._queue.get(key2);
    if (items)
      for (const item of items)
        callback(item);
    this._queue.delete(key2);
  }
  _delete(key2) {
    this._queue.delete(key2);
  }
  _size(key2) {
    return this._queue.get(key2)?.size ?? 0;
  }
  _reset() {
    this._queue.clear();
  }
};

// src/utils/error.ts
function coerceToError(error) {
  return error instanceof Error ? error : Error(JSON.stringify(error));
}
var STOP_IDLE_EVENTS = ["pointerup", "pointermove", "focus", "keydown", "playing"];
function createMediaUser($controller, $media) {
  let idleTimeout, delay = 2e3, trigger, $idle = signal(false), $userPaused = signal(false), $paused = computed(() => $userPaused() || $media.paused);
  effect(() => {
    const target = $controller();
    if (!target)
      return;
    effect(() => {
      if ($paused())
        return;
      for (const eventType of STOP_IDLE_EVENTS) {
        listenEvent(target, eventType, stopIdling);
      }
    });
    effect(() => {
      window.clearTimeout(idleTimeout);
      const idle = $idle() && !$paused();
      $media.userIdle = idle;
      dispatchEvent(target, "user-idle-change", { detail: idle, trigger });
      trigger = void 0;
    });
    return () => $idle.set(false);
  });
  function stopIdling(event) {
    if ($idle())
      trigger = event;
    $idle.set(false);
    window.clearTimeout(idleTimeout);
    idleTimeout = window.setTimeout(() => $idle.set(!peek($paused)), delay);
  }
  return {
    idle: {
      get idling() {
        return $idle();
      },
      get paused() {
        return $userPaused();
      },
      set paused(paused) {
        $userPaused.set(paused);
      },
      get delay() {
        return delay;
      },
      set delay(newDelay) {
        delay = newDelay;
      }
    }
  };
}

// src/player/media/controller/request-manager.ts
function createMediaRequestManager({ $player, $store: $media, $provider, logger }, handler, requests, $props) {
  const user = createMediaUser($player, $media), orientation = createScreenOrientationAdapter($player), fullscreen = createFullscreenAdapter($player);
  effect(() => {
    user.idle.delay = $props.$userIdleDelay();
  });
  effect(() => {
    const supported = fullscreen.supported || $provider()?.fullscreen?.supported || false;
    if ($media.canLoad && peek(() => $media.canFullscreen) === supported)
      return;
    $media.canFullscreen = supported;
  });
  function logRequest(event) {
    {
      logger?.infoGroup(`\u{1F4EC} received \`${event.type}\``).labelledLog("Request", event).dispatch();
    }
  }
  const eventHandlers = {
    "media-start-loading": onStartLoading,
    "media-mute-request": onMuteRequest,
    "media-unmute-request": onUnmuteRequest,
    "media-play-request": onPlayRequest,
    "media-pause-request": onPauseRequest,
    "media-seeking-request": onSeekingRequest,
    "media-seek-request": onSeekRequest,
    "media-live-edge-request": onSeekToLiveEdgeRequest,
    "media-volume-change-request": onVolumeChangeRequest,
    "media-enter-fullscreen-request": onEnterFullscreenRequest,
    "media-exit-fullscreen-request": onExitFullscreenRequest,
    "media-resume-user-idle-request": onResumeIdlingRequest,
    "media-pause-user-idle-request": onPauseIdlingRequest,
    "media-show-poster-request": onShowPosterRequest,
    "media-hide-poster-request": onHidePosterRequest,
    "media-loop-request": onLoopRequest
  };
  effect(() => {
    const target = $player();
    if (!target)
      return;
    for (const eventType of keysOf(eventHandlers)) {
      const handler2 = eventHandlers[eventType];
      listenEvent(target, eventType, (event) => {
        event.stopPropagation();
        logRequest(event);
        if (peek($provider))
          handler2(event);
      });
    }
  });
  function onStartLoading(event) {
    if ($media.canLoad)
      return;
    requests._queue._enqueue("load", event);
    handler.handle(createEvent($player, "can-load"));
  }
  function onMuteRequest(event) {
    if ($media.muted)
      return;
    requests._queue._enqueue("volume", event);
    $provider().muted = true;
  }
  function onUnmuteRequest(event) {
    if (!$media.muted)
      return;
    requests._queue._enqueue("volume", event);
    $provider().muted = false;
    if ($media.volume === 0) {
      requests._queue._enqueue("volume", event);
      $provider().volume = 0.25;
    }
  }
  async function onPlayRequest(event) {
    if (!$media.paused)
      return;
    try {
      requests._queue._enqueue("play", event);
      await $provider().play();
    } catch (e) {
      const errorEvent = createEvent($player, "play-fail", { detail: coerceToError(e) });
      handler.handle(errorEvent);
    }
  }
  async function onPauseRequest(event) {
    if ($media.paused)
      return;
    try {
      requests._queue._enqueue("pause", event);
      await $provider().pause();
    } catch (e) {
      requests._queue._delete("pause");
      logger?.error("pause-fail", e);
    }
  }
  function onSeekingRequest(event) {
    requests._queue._enqueue("seeking", event);
    $media.seeking = true;
    requests._$isSeeking.set(true);
  }
  function onSeekRequest(event) {
    if ($media.ended)
      requests._$isReplay.set(true);
    requests._$isSeeking.set(false);
    requests._queue._delete("seeking");
    const boundTime = Math.min(
      Math.max($media.seekableStart + 0.1, event.detail),
      $media.seekableEnd - 0.1
    );
    if (!Number.isFinite(boundTime) || !$media.canSeek)
      return;
    requests._queue._enqueue("seeked", event);
    $provider().currentTime = boundTime;
    if ($media.live && event.isOriginTrusted && Math.abs($media.seekableEnd - boundTime) >= 2) {
      $media.userBehindLiveEdge = true;
    }
  }
  function onSeekToLiveEdgeRequest(event) {
    if (!$media.live || $media.liveEdge || !$media.canSeek)
      return;
    requests._queue._enqueue("seeked", event);
    try {
      seekToLiveEdge();
    } catch (e) {
      logger?.error("seek to live edge fail", e);
    }
  }
  function onVolumeChangeRequest(event) {
    const volume = event.detail;
    if ($media.volume === volume)
      return;
    requests._queue._enqueue("volume", event);
    $provider().volume = volume;
    if (volume > 0 && $media.muted) {
      requests._queue._enqueue("volume", event);
      $provider().muted = false;
    }
  }
  async function onEnterFullscreenRequest(event) {
    try {
      requests._queue._enqueue("fullscreen", event);
      await enterFullscreen(event.detail);
    } catch (e) {
      const errorEvent = createEvent($player, "fullscreen-error", { detail: coerceToError(e) });
      handler.handle(errorEvent);
    }
  }
  async function onExitFullscreenRequest(event) {
    try {
      requests._queue._enqueue("fullscreen", event);
      await exitFullscreen2(event.detail);
    } catch (e) {
      const errorEvent = createEvent($player, "fullscreen-error", { detail: coerceToError(e) });
      handler.handle(errorEvent);
    }
  }
  function onResumeIdlingRequest(event) {
    requests._queue._enqueue("userIdle", event);
    user.idle.paused = false;
  }
  function onPauseIdlingRequest(event) {
    requests._queue._enqueue("userIdle", event);
    user.idle.paused = true;
  }
  function onShowPosterRequest(event) {
    $media.canLoadPoster = true;
  }
  function onHidePosterRequest(event) {
    $media.canLoadPoster = false;
  }
  function onLoopRequest(event) {
    window.requestAnimationFrame(async () => {
      try {
        requests._$isLooping.set(true);
        requests._$isReplay.set(true);
        await play();
      } catch (e) {
        requests._$isLooping.set(false);
        requests._$isReplay.set(false);
      }
    });
  }
  function throwIfFullscreenNotSupported(target, fullscreen2) {
    if (fullscreen2?.supported)
      return;
    throw Error(
      `[vidstack] fullscreen is not currently available on target \`${target}\`` 
    );
  }
  async function play() {
    if (!$media.paused)
      return;
    try {
      const provider = peek($provider);
      throwIfNotReadyForPlayback(provider, $player);
      if (peek(() => $media.ended))
        provider.currentTime = $media.seekableStart + 0.1;
      return provider.play();
    } catch (error) {
      const errorEvent = createEvent($player, "play-fail", { detail: coerceToError(error) });
      errorEvent.autoplay = $media.attemptingAutoplay;
      handler.handle(errorEvent);
      throw error;
    }
  }
  async function pause() {
    if ($media.paused)
      return;
    const provider = peek($provider);
    throwIfNotReadyForPlayback(provider, $player);
    return provider.pause();
  }
  async function enterFullscreen(target = "prefer-media") {
    const provider = peek($provider), fs = target === "prefer-media" && fullscreen.supported || target === "media" ? fullscreen : provider?.fullscreen;
    throwIfFullscreenNotSupported(target, fs);
    if (fs.active)
      return;
    const lockType = peek($props.$fullscreenOrientation);
    if (orientation.supported && !isUndefined(lockType))
      await orientation.lock(lockType);
    return fs.enter();
  }
  async function exitFullscreen2(target = "prefer-media") {
    const provider = peek($provider), fs = target === "prefer-media" && fullscreen.supported || target === "media" ? fullscreen : provider?.fullscreen;
    throwIfFullscreenNotSupported(target, fs);
    if (!fs.active)
      return;
    if (orientation.locked)
      await orientation.unlock();
    return fs.exit();
  }
  function seekToLiveEdge() {
    $media.userBehindLiveEdge = false;
    if (peek(() => !$media.live || $media.liveEdge || !$media.canSeek))
      return;
    const provider = peek($provider);
    throwIfNotReadyForPlayback(provider, $player);
    provider.currentTime = $media.liveSyncPosition ?? $media.seekableEnd - 2;
  }
  return {
    _user: user,
    _orientation: orientation,
    _play: play,
    _pause: pause,
    _enterFullscreen: enterFullscreen,
    _exitFullscreen: exitFullscreen2,
    _seekToLiveEdge: seekToLiveEdge
  };
}
function throwIfNotReadyForPlayback(provider, $player) {
  if (provider && peek(() => $player()?.state.canPlay))
    return;
  throw Error(
    `[vidstack] media is not ready - wait for \`can-play\` event.` 
  );
}
var MediaRequestContext = class {
  constructor() {
    this._queue = new Queue();
    this._$isSeeking = signal(false);
    this._$isLooping = signal(false);
    this._$isReplay = signal(false);
  }
};

// ../../node_modules/.pnpm/just-debounce-it@3.2.0/node_modules/just-debounce-it/index.mjs
var functionDebounce = debounce;
function debounce(fn, wait, callFirst) {
  var timeout = null;
  var debouncedFn = null;
  var clear = function() {
    if (timeout) {
      clearTimeout(timeout);
      debouncedFn = null;
      timeout = null;
    }
  };
  var flush = function() {
    var call = debouncedFn;
    clear();
    if (call) {
      call();
    }
  };
  var debounceWrapper = function() {
    if (!wait) {
      return fn.apply(this, arguments);
    }
    var context = this;
    var args = arguments;
    var callNow = callFirst && !timeout;
    clear();
    debouncedFn = function() {
      fn.apply(context, args);
    };
    timeout = setTimeout(function() {
      timeout = null;
      if (!callNow) {
        var call = debouncedFn;
        debouncedFn = null;
        return call();
      }
    }, wait);
    if (callNow) {
      return debouncedFn();
    }
  };
  debounceWrapper.cancel = clear;
  debounceWrapper.flush = flush;
  return debounceWrapper;
}
var trackedEventType = /* @__PURE__ */ new Set([
  "autoplay",
  "autoplay-fail",
  "can-load",
  "sources-change",
  "source-change",
  "load-start",
  "abort",
  "error",
  "loaded-metadata",
  "loaded-data",
  "can-play",
  "play",
  "play-fail",
  "pause",
  "playing",
  "seeking",
  "seeked",
  "waiting"
]);
function createMediaStateManager({ $player, $loader, $provider, $store: $media, logger }, requests) {
  const disposal = useDisposalBin(), trackedEvents = /* @__PURE__ */ new Map();
  let skipInitialSrcChange = true, fireWaitingEvent, firingWaiting = false, lastWaitingEvent;
  onAttach(() => {
    $player()?.setAttribute("aria-busy", "true");
  });
  effect(() => {
    const target = $player();
    if (!target)
      return;
    listenEvent(target, "fullscreen-change", onFullscreenChange);
    listenEvent(target, "fullscreen-error", onFullscreenError);
  });
  effect(() => {
    if ($provider())
      return;
    resetTracking();
    softResetMediaStore($media);
    disposal.empty();
    requests._queue._reset();
    skipInitialSrcChange = true;
  });
  const eventHandlers = {
    "provider-loader-change": onProviderLoaderChange,
    "provider-change": onProviderChange,
    autoplay: onAutoplay,
    "autoplay-fail": onAutoplayFail,
    "can-load": onCanLoad,
    "can-play-through": onCanPlayThrough,
    "can-play": onCanPlay,
    "duration-change": onDurationChange,
    "load-start": onLoadStart,
    "loaded-data": onLoadedData,
    "loaded-metadata": onLoadedMetadata,
    "media-type-change": onMediaTypeChange,
    "stream-type-change": onStreamTypeChange,
    "play-fail": onPlayFail,
    "source-change": onSourceChange,
    "sources-change": onSourcesChange,
    "time-update": onTimeUpdate,
    "volume-change": onVolumeChange,
    "fullscreen-change": onFullscreenChange,
    "fullscreen-error": onFullscreenError,
    abort: onAbort,
    ended: onEnded,
    error: onError,
    pause: onPause,
    play: onPlay,
    playing: onPlaying,
    progress: onProgress,
    seeked: onSeeked,
    seeking: functionThrottle(onSeeking, 150, { leading: true }),
    waiting: onWaiting
  };
  function resetTracking() {
    stopWaiting();
    requests._$isReplay.set(false);
    requests._$isLooping.set(false);
    firingWaiting = false;
    lastWaitingEvent = void 0;
    trackedEvents.clear();
  }
  function onProviderLoaderChange(event) {
    $loader.set(event.detail);
  }
  function onProviderChange(event) {
    $provider.set(event.detail);
  }
  function onMediaTypeChange(event) {
    appendTriggerEvent(event, trackedEvents.get("source-change"));
    const viewType = $media.viewType;
    $media.mediaType = event.detail;
    if (viewType !== $media.viewType) {
      setTimeout(
        () => $player()?.dispatchEvent(
          createEvent($player, "view-type-change", {
            detail: $media.viewType,
            trigger: event
          })
        ),
        0
      );
    }
  }
  function onStreamTypeChange(event) {
    appendTriggerEvent(event, trackedEvents.get("source-change"));
    $media.inferredStreamType = event.detail;
    event.detail = $media.streamType;
  }
  function onCanLoad(event) {
    $media.canLoad = true;
    trackedEvents.set("can-load", event);
    satisfyMediaRequest("load", event);
  }
  function onSourcesChange(event) {
    $media.sources = event.detail;
  }
  function onSourceChange(event) {
    appendTriggerEvent(event, trackedEvents.get("sources-change"));
    $media.source = event.detail;
    $player()?.setAttribute("aria-busy", "true");
    {
      logger?.infoGroup("\u{1F4FC} Media source change").labelledLog("Source", event.detail).dispatch();
    }
    if (skipInitialSrcChange) {
      skipInitialSrcChange = false;
      return;
    }
    resetTracking();
    softResetMediaStore($media);
    trackedEvents.set(event.type, event);
  }
  function onAbort(event) {
    appendTriggerEvent(event, trackedEvents.get("source-change"));
    appendTriggerEvent(event, trackedEvents.get("can-load"));
  }
  function onLoadStart(event) {
    appendTriggerEvent(event, trackedEvents.get("source-change"));
  }
  function onError(event) {
    $media.error = event.detail;
    appendTriggerEvent(event, trackedEvents.get("abort"));
  }
  function onLoadedMetadata(event) {
    appendTriggerEvent(event, trackedEvents.get("load-start"));
  }
  function onLoadedData(event) {
    appendTriggerEvent(event, trackedEvents.get("load-start"));
  }
  function onCanPlay(event) {
    if (event.trigger?.type !== "loadedmetadata") {
      appendTriggerEvent(event, trackedEvents.get("loaded-metadata"));
    }
    onCanPlayDetail(event.detail);
    $player()?.setAttribute("aria-busy", "false");
  }
  function onCanPlayThrough(event) {
    onCanPlayDetail(event.detail);
    appendTriggerEvent(event, trackedEvents.get("can-play"));
  }
  function onCanPlayDetail({ buffered, seekable }) {
    $media.seekable = seekable;
    $media.buffered = buffered;
    $media.duration = $media.seekableEnd;
    $media.canPlay = true;
  }
  function onDurationChange(event) {
    const duration = event.detail;
    if (!$media.live)
      $media.duration = !Number.isNaN(duration) ? duration : 0;
  }
  function onProgress(event) {
    const { buffered, seekable } = event.detail;
    $media.buffered = buffered;
    $media.seekable = seekable;
    if ($media.live) {
      $media.duration = $media.seekableEnd;
      dispatchEvent($player(), "duration-change", {
        detail: $media.seekableEnd,
        trigger: event
      });
    }
  }
  function onAutoplay(event) {
    appendTriggerEvent(event, trackedEvents.get("play"));
    appendTriggerEvent(event, trackedEvents.get("can-play"));
    $media.autoplayError = void 0;
  }
  function onAutoplayFail(event) {
    appendTriggerEvent(event, trackedEvents.get("play-fail"));
    appendTriggerEvent(event, trackedEvents.get("can-play"));
    $media.autoplayError = event.detail;
    resetTracking();
  }
  function onPlay(event) {
    event.autoplay = $media.attemptingAutoplay;
    if (requests._$isLooping() || !$media.paused) {
      event.stopImmediatePropagation();
      return;
    }
    appendTriggerEvent(event, trackedEvents.get("waiting"));
    satisfyMediaRequest("play", event);
    $media.paused = false;
    $media.autoplayError = void 0;
    if ($media.ended || requests._$isReplay()) {
      requests._$isReplay.set(false);
      $media.ended = false;
      handleMediaEvent(createEvent($player, "replay", { trigger: event }));
    }
  }
  function onPlayFail(event) {
    appendTriggerEvent(event, trackedEvents.get("play"));
    satisfyMediaRequest("play", event);
    $media.paused = true;
    $media.playing = false;
    resetTracking();
  }
  function onPlaying(event) {
    const playEvent = trackedEvents.get("play");
    if (playEvent) {
      appendTriggerEvent(event, trackedEvents.get("waiting"));
      appendTriggerEvent(event, playEvent);
    } else {
      appendTriggerEvent(event, trackedEvents.get("seeked"));
    }
    setTimeout(() => resetTracking(), 0);
    $media.paused = false;
    $media.playing = true;
    $media.seeking = false;
    $media.ended = false;
    if (requests._$isLooping()) {
      event.stopImmediatePropagation();
      requests._$isLooping.set(false);
      return;
    }
    onStarted(event);
  }
  function onStarted(event) {
    if (!$media.started) {
      if ($media.live) {
        const end = $media.liveSyncPosition ?? $media.seekableEnd - 2;
        if (Number.isFinite(end))
          $provider().currentTime = end;
      }
      $media.started = true;
      handleMediaEvent(createEvent($player, "started", { trigger: event }));
    }
  }
  function onPause(event) {
    if (requests._$isLooping()) {
      event.stopImmediatePropagation();
      return;
    }
    appendTriggerEvent(event, trackedEvents.get("seeked"));
    satisfyMediaRequest("pause", event);
    $media.paused = true;
    $media.playing = false;
    $media.seeking = false;
    resetTracking();
  }
  function onTimeUpdate(event) {
    const { currentTime, played } = event.detail;
    $media.currentTime = currentTime;
    $media.played = played;
    $media.waiting = false;
  }
  function onVolumeChange(event) {
    $media.volume = event.detail.volume;
    $media.muted = event.detail.muted || event.detail.volume === 0;
    satisfyMediaRequest("volume", event);
  }
  function onSeeking(event) {
    $media.seeking = true;
    $media.currentTime = event.detail;
    satisfyMediaRequest("seeking", event);
  }
  function onSeeked(event) {
    if (requests._$isSeeking()) {
      $media.seeking = true;
      event.stopImmediatePropagation();
    } else if ($media.seeking) {
      appendTriggerEvent(event, trackedEvents.get("waiting"));
      appendTriggerEvent(event, trackedEvents.get("seeking"));
      if ($media.paused)
        stopWaiting();
      $media.seeking = false;
      if (event.detail !== $media.duration)
        $media.ended = false;
      $media.currentTime = event.detail;
      satisfyMediaRequest("seeked", event);
      const origin = event.originEvent;
      if (origin && origin.isTrusted && !/seek/.test(origin.type)) {
        onStarted(event);
      }
    }
  }
  fireWaitingEvent = functionDebounce(() => {
    if (!lastWaitingEvent)
      return;
    firingWaiting = true;
    $media.waiting = true;
    $media.playing = false;
    const event = createEvent($player, "waiting", { trigger: lastWaitingEvent });
    trackedEvents.set("waiting", event);
    $player()?.dispatchEvent(event);
    lastWaitingEvent = void 0;
    firingWaiting = false;
  }, 300);
  function onWaiting(event) {
    if (firingWaiting || requests._$isSeeking())
      return;
    event.stopImmediatePropagation();
    lastWaitingEvent = event;
    fireWaitingEvent();
  }
  function onEnded(event) {
    if (requests._$isLooping()) {
      event.stopImmediatePropagation();
      return;
    }
    $media.paused = true;
    $media.playing = false;
    $media.seeking = false;
    $media.ended = true;
    resetTracking();
  }
  function stopWaiting() {
    fireWaitingEvent?.cancel();
    $media.waiting = false;
  }
  function onFullscreenChange(event) {
    $media.fullscreen = event.detail;
    satisfyMediaRequest("fullscreen", event);
  }
  function onFullscreenError(event) {
    satisfyMediaRequest("fullscreen", event);
  }
  function satisfyMediaRequest(request, event) {
    requests._queue._serve(request, (requestEvent) => {
      event.request = requestEvent;
      appendTriggerEvent(event, requestEvent);
    });
  }
  function handleMediaEvent(event) {
    eventHandlers[event.type]?.(event);
    if (trackedEventType.has(event.type)) {
      trackedEvents.set(event.type, event);
    }
    $player()?.dispatchEvent(event);
  }
  return { handle: handleMediaEvent };
}

// src/player/media/controller/create-controller.ts
function createMediaController(props) {
  const context = {
    $player: signal(null),
    $loader: signal(null),
    $provider: signal(null),
    $store: mediaStore.create()
  };
  provideContext(mediaContext, context);
  context.logger = useLogger(context.$player);
  context.remote = new MediaRemoteControl(context.logger );
  const $store = context.$store, requests = new MediaRequestContext(), stateManager = createMediaStateManager(context, requests), requestManager = createMediaRequestManager(context, stateManager, requests, props), delegate = createMediaControllerDelegate(context, stateManager.handle), providerDelegate = useMediaProviderDelegate(context, requestManager, props);
  context.delegate = delegate;
  const providedProps = {
    viewType: "providedViewType",
    streamType: "providedStreamType"
  };
  for (const prop of Object.keys(props)) {
    const propName = prop.slice(1);
    if (propName in $store)
      $store[providedProps[propName] ?? propName] = props[prop]();
  }
  effect(() => {
    $store.providedViewType = props.$viewType();
    $store.providedStreamType = props.$streamType();
  });
  $store.muted = props.$muted() || props.$volume() === 0;
  useMediaPropChange(context, props);
  useMediaCanLoad(context.$player, props.$load, startLoadingMedia);
  useMediaEventsLogger(context, context.logger);
  function startLoadingMedia() {
    delegate.dispatch("can-load");
  }
  return {
    _context: context,
    _start: startLoadingMedia,
    _request: requestManager,
    _provider: providerDelegate
  };
}
var $$_templ = /* @__PURE__ */ $$_create_template(`<!$><audio preload="none"></audio>`);
var $$_templ_2 = $$_templ;
var AudioProviderLoader = class {
  canPlay({ src, type }) {
    return isString(src) ? AUDIO_EXTENSIONS.test(src) || AUDIO_TYPES.has(type) || src.startsWith("blob:") && type === "audio/object" : type === "audio/object";
  }
  mediaType() {
    return "audio";
  }
  async load() {
    if (!this._audio) {
      throw Error(
        "[vidstack] `<audio>` element was not found - did you forget to include `<media-outlet>`?"
      );
    }
    return new (await import('./provider-WQ6Z4UZW.js')).AudioProvider(this._audio);
  }
  render($store) {
    const controls = () => $store.controls;
    return (() => {
      const [$$_root, $$_walker] = $$_create_walker($$_templ_2);
      $$_effect(() => $$_attr($$_root, "controls", controls()));
      $$_ref($$_root, (el) => void (this._audio = el));
      return $$_root;
    })();
  }
};
var $$_templ2 = /* @__PURE__ */ $$_create_template(`<!$><video preload="none"></video>`);
var $$_templ_22 = $$_templ2;
var VideoProviderLoader = class {
  canPlay(src) {
    return isString(src.src) ? VIDEO_EXTENSIONS.test(src.src) || VIDEO_TYPES.has(src.type) || src.src.startsWith("blob:") && src.type === "video/object" || isHLSSrc(src) && canPlayHLSNatively() : src.type === "video/object";
  }
  mediaType() {
    return "video";
  }
  async load(context) {
    if (!this._video) {
      throw Error(
        "[vidstack] `<video>` element was not found - did you forget to include `<media-outlet>`?"
      );
    }
    return new (await import('./provider-BU7HIZIM.js')).VideoProvider(this._video, context);
  }
  render($store) {
    const controls = () => $store.controls;
    const poster = () => $store.poster && $store.canLoadPoster === true ? $store.poster : null;
    return (() => {
      const [$$_root, $$_walker] = $$_create_walker($$_templ_22);
      $$_effect(() => $$_attr($$_root, "controls", controls()));
      $$_effect(() => $$_attr($$_root, "poster", poster()));
      $$_ref($$_root, (el) => void (this._video = el));
      return $$_root;
    })();
  }
};

// src/player/media/providers/hls/loader.tsx
var _HLSProviderLoader = class extends VideoProviderLoader {
  preconnect() {
    preconnect("https://cdn.jsdelivr.net", "preconnect");
  }
  canPlay({ src, type }) {
    return _HLSProviderLoader.supported && isString(src) && (HLS_VIDEO_EXTENSIONS.test(src) || HLS_VIDEO_TYPES.has(type));
  }
  async load(context) {
    if (!this._video) {
      throw Error(
        "[vidstack] `<video>` element was not found - did you forget to include `<media-outlet>`?"
      );
    }
    return new (await import('./provider-DFQQFLZA.js')).HLSProvider(this._video, context);
  }
};
var HLSProviderLoader = _HLSProviderLoader;
HLSProviderLoader.supported = isHLSSupported();

// src/player/media/controller/source-selection.ts
function useSourceSelection($src, $preferNativeHLS, context) {
  const { $loader, $store, delegate } = context;
  const HLS_LOADER = new HLSProviderLoader(), VIDEO_LOADER = new VideoProviderLoader(), AUDIO_LOADER = new AudioProviderLoader();
  const $loaders = computed(() => {
    return $preferNativeHLS() ? [VIDEO_LOADER, AUDIO_LOADER, HLS_LOADER] : [HLS_LOADER, VIDEO_LOADER, AUDIO_LOADER];
  });
  effect(() => {
    delegate.dispatch("sources-change", { detail: normalizeSrc($src()) });
  });
  effect(() => {
    const sources = $store.sources, currentSource = peek(() => $store.source);
    let newSource = { src: "", type: "" }, newLoader = null;
    for (const src of sources) {
      const loader = peek($loaders).find((loader2) => loader2.canPlay(src));
      if (loader) {
        newSource = src;
        newLoader = loader;
      }
    }
    if (newSource.src !== currentSource.src || newSource.type !== currentSource.type) {
      delegate.dispatch("source-change", { detail: newSource });
      delegate.dispatch("media-type-change", {
        detail: newLoader?.mediaType(newSource) || "unknown"
      });
    }
    if (newLoader !== peek($loader)) {
      delegate.dispatch("provider-change", { detail: null });
      newLoader && peek(() => newLoader.preconnect?.(context));
      delegate.dispatch("provider-loader-change", { detail: newLoader });
    }
    tick();
  });
  effect(() => {
    const provider = context.$provider();
    if (!provider)
      return;
    if (context.$store.canLoad) {
      peek(() => provider.setup({ ...context, player: context.$player() }));
      return;
    }
    peek(() => provider.preconnect?.(context));
  });
  effect(() => {
    const provider = context.$provider(), source = context.$store.source;
    if (context.$store.canLoad) {
      peek(
        () => provider?.loadSource(
          source,
          peek(() => context.$store.preload)
        )
      );
      return;
    }
    try {
      isString(source.src) && preconnect(new URL(source.src).origin, "preconnect");
    } catch (e) {
      {
        context.logger?.infoGroup(`Failed to preconnect to source: ${source.src}`).labelledLog("Error", e).dispatch();
      }
    }
  });
}
function normalizeSrc(src) {
  return (isArray(src) ? src : [!isString(src) && "src" in src ? src : { src }]).map(
    ({ src: src2, type }) => ({
      src: src2,
      type: type ?? (!isString(src2) || src2.startsWith("blob:") ? "video/object" : "?")
    })
  );
}

// src/player/element/props.ts
var mediaPlayerProps = {
  autoplay: { initial: false },
  aspectRatio: {
    initial: null,
    type: {
      from(value) {
        if (!value)
          return null;
        const [width, height] = value.split("/").map(Number);
        return +(width / height).toFixed(4);
      }
    }
  },
  controls: { initial: false },
  currentTime: { initial: 0 },
  fullscreenOrientation: {},
  load: { initial: "visible" },
  logLevel: { initial: "silent" },
  loop: { initial: false },
  muted: { initial: false },
  paused: { initial: true },
  playsinline: { initial: false },
  poster: { initial: "" },
  preload: { initial: "metadata" },
  preferNativeHLS: {
    initial: false,
    attribute: "prefer-native-hls"
  },
  src: { initial: "" },
  userIdleDelay: { initial: 2e3 },
  viewType: { initial: "unknown" },
  streamType: { initial: "unknown" },
  volume: { initial: 1 },
  liveEdgeTolerance: { initial: 10 },
  minLiveDVRWindow: { initial: 60 },
  keyDisabled: { initial: false },
  keyTarget: { initial: "player" },
  keyShortcuts: { initial: MEDIA_KEY_SHORTCUTS }
};

// src/player/element/element.ts
var MEDIA_ATTRIBUTES = [
  "autoplay",
  "autoplayError",
  "canFullscreen",
  "canLoad",
  "canPlay",
  "canSeek",
  "ended",
  "error",
  "fullscreen",
  "loop",
  "live",
  "liveEdge",
  "mediaType",
  "muted",
  "paused",
  "playing",
  "playsinline",
  "seeking",
  "started",
  "streamType",
  "userIdle",
  "viewType",
  "waiting"
];
var HLS_LISTENERS = Symbol("HLS_LISTENERS" );
var PlayerDefinition = defineCustomElement({
  tagName: "media-player",
  props: mediaPlayerProps,
  construct() {
    this[HLS_LISTENERS] = signal([]);
    const addEventListener = this.addEventListener;
    this.addEventListener = function(type, handler, options) {
      if (type.startsWith("hls-"))
        this[HLS_LISTENERS].set((x) => [...x, type]);
      return addEventListener.call(this, type, handler, options);
    };
  },
  setup({ host, props, accessors }) {
    const scope = getScope(), controller = createMediaController(props), context = controller._context, $media = context.$store;
    {
      const logPrinter = createLogPrinter(host.$el);
      effect(() => void (logPrinter.logLevel = props.$logLevel()));
    }
    onAttach(() => {
      host.el.setAttribute("tabindex", "0");
      if (!host.el.hasAttribute("aria-label")) {
        host.el.setAttribute("aria-label", "Media Player");
      }
      context.$player.set(host.el);
      context.remote.setTarget(host.el);
      context.remote.setPlayer(host.el);
      listenEvent(host.el, "find-media-player", ({ detail }) => detail(host.el));
    });
    onConnect(() => {
      dispatchEvent(host.el, "media-player-connect", {
        detail: host.el,
        bubbles: true,
        composed: true
      });
      window.requestAnimationFrame(() => {
        if (isNull($media.canLoadPoster))
          $media.canLoadPoster = true;
      });
    });
    context.ariaKeys = {};
    context.$keyShortcuts = props.$keyShortcuts;
    useKeyboard(context, props);
    useFocusVisible(host.$el);
    useSourceSelection(props.$src, props.$preferNativeHLS, controller._context);
    const $attrs = {
      "aspect-ratio": props.$aspectRatio,
      "data-ios-controls": () => IS_IOS && $media.mediaType === "video" && $media.controls && (!props.$playsinline() || $media.fullscreen)
    };
    for (const prop of MEDIA_ATTRIBUTES) {
      $attrs["data-" + camelToKebabCase(prop)] = () => $media[prop];
    }
    host.setAttributes($attrs);
    host.setCSSVars({
      "--media-aspect-ratio": () => {
        const ratio = props.$aspectRatio();
        return ratio ? +ratio.toFixed(4) : null;
      },
      "--media-buffered": () => +$media.bufferedEnd.toFixed(3),
      "--media-current-time": () => +$media.currentTime.toFixed(3),
      "--media-duration": () => Number.isFinite($media.duration) ? +$media.duration.toFixed(3) : 0
    });
    onDispose(() => {
      dispatchEvent(host.el, "destroy");
    });
    return mergeProperties(
      {
        get user() {
          return controller._request._user;
        },
        get orientation() {
          return controller._request._orientation;
        },
        get provider() {
          return context.$provider();
        },
        get $store() {
          return $media;
        },
        state: new Proxy($media, {
          set: noop
        }),
        subscribe: (callback) => scoped(() => effect(() => callback($media)), scope),
        startLoading: controller._start,
        play: controller._request._play,
        pause: controller._request._pause,
        seekToLiveEdge: controller._request._seekToLiveEdge,
        enterFullscreen: controller._request._enterFullscreen,
        exitFullscreen: controller._request._exitFullscreen
      },
      accessors(),
      controller._provider
    );
  }
});

export { HLS_LISTENERS, PlayerDefinition, coerceToError, createTimeRanges, getTimeRangesEnd, getTimeRangesStart, mediaStore, softResetMediaStore };
