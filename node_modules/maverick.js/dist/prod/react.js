import { $$_attach_declarative_shadow_dom, registerCustomElement, registerLiteCustomElement } from './chunks/chunk-OTJ4ZT3V.js';
import { kebabToPascalCase } from './chunks/chunk-BEB5E3XQ.js';
import { createElementInstance } from './chunks/chunk-TPU3CTRP.js';
import { PROPS } from './chunks/chunk-ZWFN6IXV.js';
import { provideContext } from './chunks/chunk-PIC675LO.js';
import { getContext, createScope, tick, SCOPE } from '@maverick-js/signals';
import * as React2 from 'react';

var ReactComputeScopeContext = React2.createContext(null);
function WithScope(scope, children) {
  return React2.createElement(ReactComputeScopeContext.Provider, { value: scope }, children);
}
function useReactScope() {
  return React2.useContext(ReactComputeScopeContext);
}
function useReactContext(context) {
  const scope = useReactScope();
  return React2.useMemo(() => {
    return getContext(context.id, scope);
  }, [scope]);
}
function createReactScopeProvider() {
  return ScopeProvider;
}
function createReactContextProvider(context, provide) {
  var _a;
  return _a = class extends ScopeProvider {
  }, _a.p = context, _a.v = provide, _a;
}
var ScopeProvider = class extends React2.Component {
  constructor(props, context) {
    super(props);
    const scope = createScope();
    this.x = scope;
    if (context)
      context.append(scope);
    const ctor = this.constructor;
    if (ctor.p)
      provideContext(ctor.p, ctor.v?.(), scope);
  }
  render() {
    return WithScope(this.x, this.props?.children);
  }
};
ScopeProvider.contextType = ReactComputeScopeContext;

// src/react/utils.ts
function setRef(ref, value) {
  if (typeof ref === "function") {
    ref(value);
  } else {
    ref.current = value;
  }
}

// src/react/create-react-element.ts
function createReactElement(definition, init) {
  return createReactClientElement(registerCustomElement, definition, init);
}
function createLiteReactElement(definition, init) {
  return createReactClientElement(registerLiteCustomElement, definition, init);
}
function createReactClientElement(registerCustomElement2, definition, init) {
  registerCustomElement2(definition);
  class CustomElement extends ReactCustomElement {
  }
  CustomElement.displayName = init?.displayName ?? kebabToPascalCase(definition.tagName);
  CustomElement.contextType = ReactComputeScopeContext;
  CustomElement.c = definition;
  CustomElement.y = new Set(Object.keys(definition.props ?? {}));
  const ForwardedComponent = React2.forwardRef(
    (props, ref) => React2.createElement(CustomElement, { ...props, E: ref }, props?.children)
  );
  ForwardedComponent.displayName = "ForwardRef_" + CustomElement.displayName;
  return ForwardedComponent;
}
var ReactCustomElement = class extends React2.Component {
  constructor() {
    super(...arguments);
    this.d = null;
  }
  componentDidMount() {
    if (!this.d || this.d.instance)
      return;
    $$_attach_declarative_shadow_dom(this.d);
    this.d.onEventDispatch((eventType) => {
      const callbackName = `on${kebabToPascalCase(eventType)}`;
      const callback = this.props[callbackName];
      const ctor = this.constructor;
      ctor.q.set(callbackName, eventType);
      if (callback)
        this.A(eventType, callback);
    });
    this.d.attachComponent(this.b);
  }
  componentWillUnmount() {
    window.requestAnimationFrame(() => {
      if (!this.d)
        this.b.destroy();
    });
  }
  render() {
    const ctor = this.constructor;
    const { E: __forwardedRef, className, children, ...restProps } = this.props;
    if (!this.b) {
      this.l = /* @__PURE__ */ new Map();
      this.b = createElementInstance(ctor.c, {
        props: this.props,
        scope: this.context
      });
    }
    if (!this.r || this.z !== __forwardedRef) {
      this.r = (value) => {
        this.d = value;
        if (__forwardedRef)
          setRef(__forwardedRef, value);
        this.z = __forwardedRef;
      };
    }
    const props = { class: className, ref: this.r };
    const $props = this.b[PROPS];
    for (const prop of Object.keys(restProps)) {
      const value = restProps[prop];
      if (ctor.q.has(prop)) {
        this.A(ctor.q.get(prop), value);
      } else if (ctor.y.has(prop)) {
        $props["$" + prop].set(value);
      } else {
        props[prop] = value;
      }
    }
    tick();
    return WithScope(
      this.b[SCOPE],
      React2.createElement(
        ctor.c.tagName,
        { ...props, "mk-d": true, suppressHydrationWarning: true },
        React2.createElement(ShadowRoot, {
          shadow: ctor.c.shadowRoot
        }),
        children
      )
    );
  }
  A(eventType, listener) {
    let handler = this.l.get(eventType);
    if (!this.d || handler?.handleEvent === listener)
      return;
    if (listener) {
      if (!handler) {
        this.l.set(eventType, handler = { handleEvent: listener });
        this.d.addEventListener(eventType, handler);
      } else {
        handler.handleEvent = listener;
      }
    } else if (handler) {
      this.l.delete(eventType);
      this.d.removeEventListener(eventType, handler);
    }
  }
};
ReactCustomElement.q = /* @__PURE__ */ new Map();
function ShadowRoot(props) {
  return React2.createElement(props.shadow ? "template" : "shadow-root", {
    dangerouslySetInnerHTML: { __html: "" },
    suppressHydrationWarning: true
  });
}

export { ReactComputeScopeContext, WithScope, createLiteReactElement, createReactContextProvider, createReactElement, createReactScopeProvider, useReactContext, useReactScope };
