import { signal, effect as effect$1, computed, onError, peek, setContext, getScope, getContext } from '@maverick-js/signals';
export { computed, createScope, getScope, isReadSignal, isWriteSignal, onDispose, onError, peek, readonly, root, scoped, signal, tick, untrack } from '@maverick-js/signals';
import { computedMap, computedKeyedMap } from '@maverick-js/signals/map';

// src/runtime/accessors.ts
function createAccessors(record) {
  const accessors = {};
  for (const name of Object.keys(record)) {
    Object.defineProperty(accessors, name, {
      configurable: true,
      enumerable: true,
      get: record[name],
      set: record[name].set
    });
  }
  return accessors;
}

// src/std/unit.ts
function noop(...args) {
}
function isNull(value) {
  return value === null;
}
function isUndefined(value) {
  return typeof value === "undefined";
}
function isNil(value) {
  return isNull(value) || isUndefined(value);
}
function isObject(value) {
  return value?.constructor === Object;
}
function isNumber(value) {
  return typeof value === "number" && !Number.isNaN(value);
}
function isString(value) {
  return typeof value === "string";
}
function isBoolean(value) {
  return typeof value === "boolean";
}
function isFunction(value) {
  return typeof value === "function";
}
function isArray(value) {
  return Array.isArray(value);
}
function createRegex(regex) {
  return isString(regex) ? new RegExp(regex) : regex;
}
function isWindow(value) {
  return value === window;
}
function createStore(initial) {
  const descriptors = Object.getOwnPropertyDescriptors(initial);
  return {
    initial,
    create: () => {
      const store = {};
      for (const name of Object.keys(initial)) {
        const $value = descriptors[name].get || signal(initial[name]);
        Object.defineProperty(store, name, {
          configurable: true,
          enumerable: true,
          get: $value,
          set: $value.set
        });
      }
      return store;
    },
    reset: (record, filter) => {
      for (const name of Object.keys(record)) {
        if (!descriptors[name].get && (!filter || filter(name))) {
          record[name] = initial[name];
        }
      }
    }
  };
}

// src/runtime/reactivity.ts
var effect = effect$1;

// src/runtime/components/CustomElement.ts
function CustomElement(props) {
  return null;
}

// src/std/signal.ts
function unwrap(fn) {
  return isFunction(fn) ? fn() : fn;
}
function unwrapDeep(fn) {
  let value = fn;
  while (typeof value === "function")
    value = value();
  return value;
}

// src/runtime/components/ErrorBoundary.ts
function ErrorBoundary(props) {
  const $e = signal(null);
  const $error = () => $e();
  $error.handled = () => $e.set(null);
  return computed(
    () => {
      const $children = unwrap(props.$children);
      onError((error) => {
        $e.set(error);
        props.onError?.(error, $error.handled);
      });
      return isFunction($children) && $children.length > 0 ? peek(() => $children($error)) : $children;
    },
    { initial: null }
  );
}
function For(props) {
  return computedMap(
    () => unwrap(props.each),
    unwrap(props.$children),
    void 0
  );
}
function ForKeyed(props) {
  return computedKeyedMap(
    () => unwrap(props.each),
    unwrap(props.$children),
    void 0
  );
}

// src/runtime/components/HostElement.ts
function HostElement(props) {
  return null;
}
function createContext(provide) {
  return { id: Symbol(), provide };
}
function provideContext(context, value, scope = getScope()) {
  const hasProvidedValue = !isUndefined(value);
  setContext(context.id, hasProvidedValue ? value : context.provide?.(), scope);
}
function useContext(context) {
  const value = getContext(context.id);
  return value;
}
function hasProvidedContext(context) {
  return !isUndefined(getContext(context.id));
}

export { CustomElement, ErrorBoundary, For, ForKeyed, HostElement, createAccessors, createContext, createRegex, createStore, effect, hasProvidedContext, isArray, isBoolean, isFunction, isNil, isNull, isNumber, isObject, isString, isUndefined, isWindow, noop, provideContext, unwrap, unwrapDeep, useContext };
