import { createComment, isDOMNode, createFragment, attachDeclarativeShadowDOM, setAttribute, toggleClass, setStyle, listenEvent, trimTrailingSemicolon, flattenArray } from './chunk-3ZBTVF5F.js';
import { createElementInstance } from './chunk-GAIAW3NQ.js';
import { getCustomElementInstance, RENDER, SCOPE, PROPS, ATTACH, HOST, CONNECT } from './chunk-ZWFN6IXV.js';
import { root, isFunction, isArray, isString, isNumber, unwrapDeep, effect, isUndefined, onDispose, scoped, peek, computed, isNull, isBoolean, noop } from './chunk-FPYVZR2H.js';
import { root as root$1 } from '@maverick-js/signals';

// src/std/html.ts
function escape(value, isAttr = false) {
  const type = typeof value;
  if (type !== "string") {
    if (!isAttr && type === "function")
      return escape(value());
    if (isAttr && type === "boolean")
      return value + "";
    return value;
  }
  const delimeter = isAttr ? '"' : "<", escapeDelimeter = isAttr ? "&quot;" : "&lt;";
  let iDelimeter = value.indexOf(delimeter), isAmpersand = value.indexOf("&");
  if (iDelimeter < 0 && isAmpersand < 0)
    return value;
  let left = 0, out = "";
  while (iDelimeter >= 0 && isAmpersand >= 0) {
    if (iDelimeter < isAmpersand) {
      if (left < iDelimeter)
        out += value.substring(left, iDelimeter);
      out += escapeDelimeter;
      left = iDelimeter + 1;
      iDelimeter = value.indexOf(delimeter, left);
    } else {
      if (left < isAmpersand)
        out += value.substring(left, isAmpersand);
      out += "&amp;";
      left = isAmpersand + 1;
      isAmpersand = value.indexOf("&", left);
    }
  }
  if (iDelimeter >= 0) {
    do {
      if (left < iDelimeter)
        out += value.substring(left, iDelimeter);
      out += escapeDelimeter;
      left = iDelimeter + 1;
      iDelimeter = value.indexOf(delimeter, left);
    } while (iDelimeter >= 0);
  } else
    while (isAmpersand >= 0) {
      if (left < isAmpersand)
        out += value.substring(left, isAmpersand);
      out += "&amp;";
      left = isAmpersand + 1;
      isAmpersand = value.indexOf("&", left);
    }
  return left < value.length ? out + value.substring(left) : out;
}

// src/runtime/ssr/render.ts
function renderToString(root3) {
  const result = root((dispose) => {
    const value = root3();
    dispose();
    return value;
  });
  return { code: resolve(escape(result)) };
}
var SSR_TEMPLATE = /* @__PURE__ */ Symbol();
function resolve(node) {
  if (isFunction(node)) {
    return resolve(node());
  } else if (isArray(node)) {
    let result = "";
    const flattened = node.flat(10);
    for (let i = 0; i < flattened.length; i++) {
      result += resolve(escape(flattened[i]));
    }
    return result + "<!/[]>";
  } else if (isString(node) || isNumber(node)) {
    return node + "";
  } else if (node == null ? void 0 : node[SSR_TEMPLATE]) {
    return node[SSR_TEMPLATE];
  }
  return "";
}
function injectHTML(html) {
  return { [SSR_TEMPLATE]: html };
}

// src/runtime/dom/reconcile.ts
function reconcile(parent, nodesA, nodesB) {
  let lengthB = nodesB.length, endA = nodesA.length, endB = lengthB, startA = 0, startB = 0, after = nodesA[endA - 1].nextSibling, map = null;
  while (startA < endA || startB < endB) {
    if (nodesA[startA] === nodesB[startB]) {
      startA++;
      startB++;
      continue;
    }
    while (nodesA[endA - 1] === nodesB[endB - 1]) {
      endA--;
      endB--;
    }
    if (endA === startA) {
      const node = endB < lengthB ? startB ? nodesB[startB - 1].nextSibling : nodesB[endB - startB] : after;
      while (startB < endB)
        parent.insertBefore(nodesB[startB++], node);
    } else if (endB === startB) {
      while (startA < endA) {
        if (!map || !map.has(nodesA[startA]))
          nodesA[startA].remove();
        startA++;
      }
    } else if (nodesA[startA] === nodesB[endB - 1] && nodesB[startB] === nodesA[endA - 1]) {
      const node = nodesA[--endA].nextSibling;
      parent.insertBefore(nodesB[startB++], nodesA[startA++].nextSibling);
      parent.insertBefore(nodesB[--endB], node);
      nodesA[endA] = nodesB[endB];
    } else {
      if (!map) {
        map = /* @__PURE__ */ new Map();
        let i = startB;
        while (i < endB)
          map.set(nodesB[i], i++);
      }
      const index = map.get(nodesA[startA]);
      if (index != null) {
        if (startB < index && index < endB) {
          let i = startA, sequence = 1, t;
          while (++i < endA && i < endB) {
            if ((t = map.get(nodesA[i])) == null || t !== index + sequence)
              break;
            sequence++;
          }
          if (sequence > index - startB) {
            const node = nodesA[startA];
            while (startB < index)
              parent.insertBefore(nodesB[startB++], node);
          } else
            parent.replaceChild(nodesB[startB++], nodesA[startA++]);
        } else
          startA++;
      } else
        nodesA[startA++].remove();
    }
  }
}

// src/runtime/dom/walker.ts
var createMarkerWalker = (root3) => document.createTreeWalker(root3, NodeFilter.SHOW_COMMENT, (node) => node.nodeValue === "$");

// src/runtime/dom/render.ts
var hydration = null;
function hydrate(root3, options) {
  return runHydration(root3, render, options);
}
function runHydration(root3, renderer, options) {
  const prev = hydration;
  hydration = options.resume && hydration ? hydration : { w: createMarkerWalker(options.target) };
  const dispose = renderer(root3, options);
  hydration = prev;
  return dispose;
}
function render(root3, options) {
  return root((dispose) => {
    if (!hydration) {
      insert(options.target, root3(), options.before);
    } else {
      unwrapDeep(root3);
    }
    return dispose;
  });
}

// src/runtime/dom/insert.ts
function insert(parent, value, marker) {
  let isSignal = isFunction(value);
  if (isSignal && value[$$CHILDREN]) {
    value = value();
    isSignal = isFunction(value);
  }
  if (isSignal) {
    let current;
    effect(
      () => void (current = insertExpression(
        parent,
        unwrapDeep(value()),
        marker,
        current,
        true
      ))
    );
    return;
  } else if (hydration) {
    marker.remove();
  } else
    insertExpression(parent, value, marker);
}
function insertExpression(parent, value, marker, current, isSignal = false) {
  if (value === current)
    return current;
  if (isArray(value)) {
    const newNodes = [], currentNodes = hydration ? claimArray(marker) : current && isArray(current) ? current : [];
    if (value.length && resolveArray(newNodes, value, currentNodes, isSignal)) {
      effect(() => void (current = insertExpression(parent, newNodes, marker, currentNodes, true)));
      return () => current;
    }
    if (hydration)
      return currentNodes;
    if (newNodes.length === 0) {
      updateDOM(parent, current);
    } else if (currentNodes.length) {
      reconcile(parent, currentNodes, newNodes);
    } else {
      current && updateDOM(parent, current, marker);
      appendArray(parent, newNodes, marker);
    }
    return newNodes;
  } else if (isString(value) || isNumber(value)) {
    if (!isUndefined(marker)) {
      if (isDOMNode(current) && current.nodeType === 3) {
        current.data = value + "";
      } else if (!hydration) {
        return updateDOM(parent, current, marker, document.createTextNode(value + ""));
      } else {
        return marker.nextSibling;
      }
    } else if (current !== "" && isString(current)) {
      return parent.firstChild.data = value + "";
    } else
      return parent.textContent = value + "";
  } else if (isDOMNode(value)) {
    if (hydration) ; else if (marker || isArray(current)) {
      if (!isUndefined(marker))
        return current = updateDOM(parent, current, marker, value);
      updateDOM(parent, current, null, value);
    } else if (!current || !parent.firstChild) {
      parent.appendChild(value);
    } else
      parent.replaceChild(value, parent.firstChild);
    return value;
  } else {
    return updateDOM(parent, current, marker);
  }
  return current;
}
function appendArray(parent, nodes, marker) {
  if (isUndefined(marker)) {
    for (let i = 0; i < nodes.length; i++)
      parent.appendChild(nodes[i]);
  } else {
    for (let i = 0; i < nodes.length; i++)
      parent.insertBefore(nodes[i], marker);
  }
}
function resolveArray(nodes, values, current, computed2) {
  let value, prev, effect3 = false;
  for (let i = 0; i < values.length; i++) {
    value = values[i], prev = current[i];
    if (isDOMNode(value)) {
      nodes.push(value);
    } else if (isArray(value)) {
      effect3 = resolveArray(nodes, value, isArray(prev) ? prev : [], computed2) || effect3;
    } else if (isFunction(value)) {
      if (computed2) {
        value = value();
        effect3 = resolveArray(
          nodes,
          isArray(value) ? value : [value],
          isArray(prev) ? prev : [prev],
          true
        ) || effect3;
      } else {
        nodes.push(value);
        effect3 = true;
      }
    } else if (value || value === 0) {
      const text = value + "";
      if (prev && prev.nodeType === 3 && prev.data === text) {
        nodes.push(prev);
      } else {
        nodes.push(document.createTextNode(text));
      }
    }
  }
  return effect3;
}
var ARRAY_END_MARKER = "/[]";
function claimArray(marker) {
  let node = marker.nextSibling, nodes = [];
  while (node) {
    if (node.nodeType !== 8) {
      nodes.push(node);
    } else if (node.nodeValue === ARRAY_END_MARKER) {
      node.remove();
      break;
    }
    node = node.nextSibling;
  }
  return nodes;
}
function updateDOM(parent, current, marker, replace) {
  if (isUndefined(marker)) {
    parent.textContent = "";
    return;
  }
  const node = replace || createComment("~");
  if (isArray(current) && current.length) {
    let el, inserted = false, isParent = false;
    for (let i = current.length - 1; i >= 0; i--) {
      el = current[i];
      if (el !== node) {
        isParent = el.parentNode === parent;
        if (!inserted && !i)
          isParent ? parent.replaceChild(node, el) : parent.insertBefore(node, marker);
        else
          isParent && parent.removeChild(el);
      } else
        inserted = true;
    }
  } else if (isDOMNode(current)) {
    parent.replaceChild(node, current);
  } else {
    parent.insertBefore(node, marker);
  }
  return node;
}

// src/runtime/dom/insert-lite.ts
var CONNECTED = /* @__PURE__ */ Symbol(0);
var INSERT_MARKER_NODE = createComment("$$");
var END_MARKER = /* @__PURE__ */ Symbol(0);
var END_MARKER_NODE = /* @__PURE__ */ createComment("/$");
var ARRAY_END_MARKER_VALUE = "/[]";
function insertLite(parent, value, before) {
  let isSignal = isFunction(value);
  if (isSignal && value[$$CHILDREN]) {
    value = value();
    isSignal = isFunction(value);
  }
  if (isSignal) {
    insertEffect(parent, value, before);
  } else if (!hydration && (value || value === 0)) {
    addChild(
      parent,
      isArray(value) ? resolveArray2(value) : isDOMNode(value) ? value : document.createTextNode(value + ""),
      before
    );
  }
}
function addChild(parent, node, before) {
  if (!node)
    return;
  if (before)
    parent.insertBefore(node, before);
  else
    parent.appendChild(node);
}
function insertEffect(parent, value, before) {
  const marker = before && before.nodeType === 8 ? before : INSERT_MARKER_NODE.cloneNode();
  if (marker !== before)
    addChild(parent, marker, before);
  effect(() => void insertExpression2(marker, unwrapDeep(value)));
}
function insertExpression2(start, value) {
  const end = start[END_MARKER];
  if (isArray(value)) {
    if (hydration) {
      start[END_MARKER] = findArrayEndMarker(start);
    } else {
      if (end)
        removeOldNodes(start, end);
      const fragment = resolveArray2(value);
      if (!fragment)
        return;
      if (!end)
        fragment.appendChild(createEndMarker(start));
      start.after(fragment);
    }
  } else if (isDOMNode(value)) {
    if (end)
      removeOldNodes(start, end);
    if (!hydration)
      start.after(value);
    if (!end)
      value.after(createEndMarker(start));
  } else if (isString(value) || isNumber(value)) {
    if (start[CONNECTED]) {
      start.nextSibling.data = value + "";
      return;
    }
    if (end)
      removeOldNodes(start, end);
    let text;
    if (!hydration) {
      text = document.createTextNode(value + "");
      start.after(text);
    } else {
      text = start.nextSibling;
    }
    start[CONNECTED] = true;
    if (!end)
      text.after(createEndMarker(start));
  } else if (end) {
    removeOldNodes(start, end);
  }
}
function createEndMarker(start) {
  return start[END_MARKER] = END_MARKER_NODE.cloneNode();
}
function findArrayEndMarker(node) {
  while (node) {
    if (node.nodeType === 8 && node.nodeValue === ARRAY_END_MARKER_VALUE)
      return node;
    node = node.nextSibling;
  }
}
function removeOldNodes(start, end) {
  while (start.nextSibling !== end)
    start.nextSibling.remove();
  start[CONNECTED] = false;
}
function resolveArray2(value) {
  const flattened = flattenArray(value);
  if (!flattened.length)
    return null;
  const fragment = createFragment();
  for (let i = 0; i < flattened.length; i++) {
    const child = flattened[i];
    if (isFunction(child)) {
      insertEffect(fragment, child);
    } else {
      fragment.append(child);
    }
  }
  return fragment;
}

// src/runtime/dom/internal.ts
function $$_create_template(html) {
  const template = document.createElement("template");
  template.innerHTML = html;
  return template.content;
}
var $$_create_fragment = createFragment;
function $$_create_walker(fragment, walker = ((_a3) => (_a3 = hydration) == null ? void 0 : _a3.w)()) {
  try {
    return [$$_next_element(walker), walker];
  } catch (e) {
    return $$_create_walker(fragment, createMarkerWalker(fragment.cloneNode(true)));
  }
}
function $$_next_template(fragment) {
  return $$_create_walker(fragment)[0];
}
function $$_next_element(walker) {
  return walker.nextNode().nextSibling;
}
function $$_host_element() {
  return getCustomElementInstance().host.el;
}
function $$_next_custom_element(definition, walker = ((_a3) => (_a3 = hydration) == null ? void 0 : _a3.w)()) {
  const { tagName } = definition;
  let next;
  if (walker) {
    next = walker.nextNode();
    const element2 = next.nextSibling;
    if (element2 && element2.localName === tagName)
      return element2;
  }
  const element = $$_create_element(tagName);
  element.setAttribute("mk-d", "");
  if (next)
    insert(next.parentElement, element, next);
  return element;
}
function $$_setup_custom_element(element, definition, props) {
  if (definition.shadowRoot)
    $$_attach_declarative_shadow_dom(element);
  const instance = createElementInstance(definition, { props });
  element.attachComponent(instance);
  onDispose(() => instance.destroy());
  if (!props)
    return;
  if (props.innerHTML)
    return $$_inner_html(element, props.innerHTML);
  if ((!instance[RENDER] || definition.shadowRoot) && props.$children) {
    scoped(() => insert(element, props.$children), instance[SCOPE]);
  }
}
function $$_clone(fragment) {
  const clone = fragment.cloneNode(true);
  return clone.firstElementChild;
}
function $$_create_element(tagName) {
  return document.createElement(tagName);
}
function $$_attach_declarative_shadow_dom(element) {
  var _a3;
  if (((_a3 = element.firstChild) == null ? void 0 : _a3.nodeName) === "TEMPLATE") {
    if (element.firstChild.hasAttribute("shadowroot")) {
      attachDeclarativeShadowDOM(element);
    } else {
      element.firstChild.remove();
    }
  }
}
var $$_insert = insert;
function $$_insert_at_marker(marker, value) {
  insert(marker.parentElement, value, marker);
}
var $$_insert_lite = insertLite;
function $$_insert_at_marker_lite(marker, value) {
  insertLite(marker.parentElement, value, marker);
}
function $$_create_component(component, props = {}) {
  return peek(() => component(props));
}
var $$CHILDREN = /* @__PURE__ */ Symbol(0);
function $$_children(fn) {
  fn[$$CHILDREN] = true;
  return fn;
}
function $$_ref(element, ref) {
  if (isArray(ref)) {
    ref.filter(isFunction).forEach((ref2) => ref2(element));
  } else if (isFunction(ref)) {
    ref(element);
  }
}
function $$_directive(element, directive, args) {
  if (isFunction(directive))
    directive(element, ...args);
}
var $$_attr = setAttribute;
function $$_inner_html(element, value) {
  if (isFunction(value)) {
    effect(() => {
      if (!hydration)
        element.innerHTML = value() + "";
    });
  } else if (!hydration) {
    element.innerHTML = value + "";
  }
}
var $$_class = toggleClass;
var $$_style = setStyle;
function $$_spread(element, props) {
  const keys = Object.keys(props);
  for (let i = 0; i < keys.length; i++) {
    const prop = keys[i];
    if (prop in element) {
      if (isFunction(props[prop])) {
        effect(() => void (element[prop] = props[prop]()));
      } else {
        element[prop] = props[prop];
      }
    } else if (isFunction(props[prop])) {
      effect(() => void $$_attr(element, prop, props[prop]()));
    } else {
      $$_attr(element, prop, props[prop]);
    }
  }
}
function $$_merge_props(...sources) {
  const target = sources[0] || {};
  for (let i = 1; i < sources.length; i++) {
    const source = sources[i];
    if (source)
      Object.assign(target, source);
  }
  return target;
}
function $$_listen(target, type, handler, capture = false) {
  if (isFunction(handler))
    listenEvent(target, type, handler, { capture });
}
var DELEGATED_EVENTS = /* @__PURE__ */ Symbol(0);
function $$_delegate_events(types, document2 = window.document) {
  const events = document2[DELEGATED_EVENTS] ??= /* @__PURE__ */ new Set();
  for (let i = 0, len = types.length; i < len; i++) {
    const type = types[i];
    if (!events.has(type)) {
      events.add(type);
      document2.addEventListener(type, delegated_event_handler);
    }
  }
}
function delegated_event_handler(event) {
  const eventKey = `$$${event.type}`, dataKey = `$$${event.type}Data`;
  let node = event.composedPath && event.composedPath()[0] || event.target;
  if (event.target !== node) {
    Object.defineProperty(event, "target", {
      configurable: true,
      value: node
    });
  }
  Object.defineProperty(event, "currentTarget", {
    configurable: true,
    get() {
      return node || document;
    }
  });
  let handler, data;
  while (node) {
    handler = node[eventKey];
    if (handler && !node.disabled && isFunction(handler)) {
      data = node[dataKey];
      !isUndefined(data) ? handler.call(node, data, event) : handler.call(node, event);
    }
    node = node.parentNode || node.host;
  }
}
var $$_peek = peek;
var $$_effect = effect;
var $$_computed = computed;
function hydrateLite(root3, options) {
  return runHydration(root3, renderLite, options);
}
function renderLite(root3, options) {
  return root$1((dispose) => {
    if (!hydration) {
      insertLite(options.target, root3());
    } else {
      unwrapDeep(root3);
    }
    return dispose;
  });
}

// src/element/create-html-element.ts
function createHTMLElement(definition, init) {
  {
    throw Error(
      "[maverick] `createHTMLElement` was called outside of browser - use `createServerElement`"
    );
  }
}

// src/element/create-server-element.ts
var registry = /* @__PURE__ */ new WeakMap();
function createServerElement(definition) {
  if (registry.has(definition))
    return registry.get(definition);
  class MaverickElement extends ServerCustomElement {
  }
  MaverickElement._definition = definition;
  registry.set(definition, MaverickElement);
  return MaverickElement;
}
var _a2;
var ServerCustomElement = class {
  constructor() {
    this[_a2] = true;
    this.keepAlive = false;
    this._instance = null;
    this._rendered = false;
    this._attachCallbacks = /* @__PURE__ */ new Set();
    this.attributes = new Attributes();
    this.style = new Style();
    this.classList = new ClassList();
  }
  get instance() {
    return this._instance;
  }
  attachComponent(instance) {
    this.setAttribute("mk-h", "");
    this.setAttribute("mk-d", "");
    if (this.hasAttribute("class")) {
      parseClassAttr(this.classList.tokens, this.getAttribute("class"));
    }
    if (this.hasAttribute("style")) {
      parseStyleAttr(this.style.tokens, this.getAttribute("style"));
    }
    const { $attrs, $styles } = instance.host[PROPS];
    for (const name of Object.keys($attrs))
      setAttribute(this, name, unwrapDeep($attrs[name]));
    for (const name of Object.keys($styles))
      setStyle(this, name, unwrapDeep($styles[name]));
    instance.host[PROPS].$attrs = null;
    instance.host[PROPS].$styles = null;
    instance.host.el = this;
    this._instance = instance;
    for (const attachCallback of [...instance[ATTACH], ...this._attachCallbacks]) {
      scoped(attachCallback, instance[SCOPE]);
    }
    this._attachCallbacks = null;
    const $render = instance[RENDER];
    this._rendered = !!$render;
    this._ssr = $render ? renderToString($render).code : "";
    if (this.classList.length > 0) {
      this.setAttribute("class", this.classList.toString());
    }
    if (this.style.length > 0) {
      this.setAttribute("style", this.style.toString());
    }
  }
  render() {
    if (typeof this._ssr !== "string") {
      throw Error("[maverick] called `render` before attaching component");
    }
    const innerHTML = this.renderInnerHTML();
    const definition = this.constructor._definition;
    return this._rendered || definition.shadowRoot && definition.css ? definition.shadowRoot ? `<template shadowroot="${this.getShadowRootMode()}">${innerHTML}</template>` : `<shadow-root>${innerHTML}</shadow-root>` : innerHTML;
  }
  renderInnerHTML() {
    if (typeof this._ssr !== "string") {
      throw Error("[maverick] called `renderInnerHTML` before attaching component");
    }
    const definition = this.constructor._definition;
    const styleTag = definition.shadowRoot && definition.css ? `<style>${definition.css.map((css2) => css2.text).join("")}</style>` : "";
    return styleTag + this._ssr;
  }
  getShadowRootMode() {
    const definition = this.constructor._definition;
    return definition.shadowRoot ? isBoolean(definition.shadowRoot) ? "open" : definition.shadowRoot.mode : "open";
  }
  getAttribute(name) {
    return this.attributes.getAttribute(name);
  }
  setAttribute(name, value) {
    this.attributes.setAttribute(name, value);
  }
  hasAttribute(name) {
    return this.attributes.hasAttribute(name);
  }
  removeAttribute(name) {
    return this.attributes.removeAttribute(name);
  }
  dispatchEvent() {
    return false;
  }
  onEventDispatch() {
  }
  addEventListener() {
  }
  removeEventListener() {
  }
  onAttach(callback) {
    if (this._instance) {
      callback();
      return noop;
    } else {
      this._attachCallbacks.add(callback);
      return () => {
        var _a3;
        return (_a3 = this._attachCallbacks) == null ? void 0 : _a3.delete(callback);
      };
    }
  }
  destroy() {
    var _a3;
    (_a3 = this._instance) == null ? void 0 : _a3.destroy();
  }
};
_a2 = HOST;
var Attributes = class {
  constructor() {
    this._tokens = /* @__PURE__ */ new Map();
  }
  get length() {
    return this._tokens.size;
  }
  get tokens() {
    return this._tokens;
  }
  getAttribute(name) {
    return this._tokens.get(name) ?? null;
  }
  hasAttribute(name) {
    return this._tokens.has(name);
  }
  setAttribute(name, value) {
    this._tokens.set(name, value + "");
  }
  removeAttribute(name) {
    this._tokens.delete(name);
  }
  toString() {
    if (this._tokens.size === 0)
      return "";
    let result = "";
    for (const [name, value] of this._tokens) {
      result += ` ${name}="${escape(value, true)}"`;
    }
    return result;
  }
};
var Style = class {
  constructor() {
    this._tokens = /* @__PURE__ */ new Map();
  }
  get length() {
    return this._tokens.size;
  }
  get tokens() {
    return this._tokens;
  }
  getPropertyValue(prop) {
    return this._tokens.get(prop) ?? "";
  }
  setProperty(prop, value) {
    this._tokens.set(prop, value ?? "");
  }
  removeProperty(prop) {
    const value = this._tokens.get(prop);
    this._tokens.delete(prop);
    return value ?? "";
  }
  toString() {
    if (this._tokens.size === 0)
      return "";
    let result = "";
    for (const [name, value] of this._tokens) {
      result += `${name}: ${value};`;
    }
    return result;
  }
};
var ClassList = class {
  constructor() {
    this._tokens = /* @__PURE__ */ new Set();
  }
  get length() {
    return this._tokens.size;
  }
  get tokens() {
    return this._tokens;
  }
  add(...tokens) {
    for (const token of tokens) {
      this._tokens.add(token);
    }
  }
  contains(token) {
    return this._tokens.has(token);
  }
  remove(token) {
    this._tokens.delete(token);
  }
  replace(token, newToken) {
    if (!this._tokens.has(token))
      return false;
    this._tokens.delete(token);
    this._tokens.add(newToken);
    return true;
  }
  toggle(token, force) {
    if (force !== true && (this._tokens.has(token) || force === false)) {
      this._tokens.delete(token);
      return false;
    } else {
      this._tokens.add(token);
      return true;
    }
  }
  toString() {
    return Array.from(this._tokens).join(" ");
  }
};

// src/element/css.ts
var CSS = /* @__PURE__ */ Symbol();
var sheetCache = /* @__PURE__ */ new WeakMap();
var supported;
var supportsAdoptedStyleSheets = () => !isUndefined(supported) ? supported : supported = false;
function injectCSS(value) {
  return createCSS(value + "");
}
function css(strings, ...values) {
  let css2 = strings[0] ?? "";
  for (let i = 0; i < values.length; i++) {
    const value = values[i];
    if (value == null ? void 0 : value[CSS]) {
      css2 += value.text;
    } else if (typeof value === "number") {
      css2 += value;
    } else ;
    css2 += strings[i + 1];
  }
  return createCSS(css2, strings);
}
function createCSS(css2, strings) {
  let styleSheet;
  return {
    [CSS]: true,
    get text() {
      return css2;
    },
    get sheet() {
      if (styleSheet) {
        return styleSheet;
      } else if (strings && sheetCache.has(strings)) {
        return sheetCache.get(strings);
      } else if (supportsAdoptedStyleSheets()) {
        (styleSheet = new CSSStyleSheet()).replaceSync(css2);
        if (strings)
          sheetCache.set(strings, styleSheet);
        return styleSheet;
      }
      return;
    },
    toString() {
      return css2;
    }
  };
}
function adoptCSS(root3, css2) {
  if (supportsAdoptedStyleSheets()) {
    root3.adoptedStyleSheets = css2.map((css3) => css3.sheet);
  } else {
    const style = document.createElement("style");
    style.textContent = css2.map((css3) => css3.text).join("");
    root3.appendChild(style);
  }
}

// src/element/define.ts
function defineCustomElement(declaration) {
  const definition = {
    ...declaration,
    setup(instance) {
      var _a3;
      const setup = ((_a3 = declaration.setup) == null ? void 0 : _a3.call(
        declaration,
        instance
      )) ?? {};
      return isFunction(setup) ? { $render: setup } : setup;
    }
  };
  if ("props" in definition) {
    for (const prop of Object.values(definition.props)) {
      if (prop.attribute !== false && !prop.type) {
        prop.type = inferAttributeType(prop.initial);
      }
    }
  }
  return definition;
}
var STRING = {
  from: (v) => v === null ? "" : v + ""
};
var NUMBER = {
  from: (v) => v === null ? 0 : Number(v)
};
var BOOLEAN = {
  from: (v) => v !== null,
  to: (v) => v ? "" : null
};
var FUNCTION = {
  from: false,
  to: () => null
};
var ARRAY = {
  from: (v) => v === null ? [] : JSON.parse(v),
  to: (v) => JSON.stringify(v)
};
var OBJECT = {
  from: (v) => v === null ? {} : JSON.parse(v),
  to: (v) => JSON.stringify(v)
};
function inferAttributeType(value) {
  switch (typeof value) {
    case "undefined":
      return STRING;
    case "string":
      return STRING;
    case "boolean":
      return BOOLEAN;
    case "number":
      return NUMBER;
    case "function":
      return FUNCTION;
    case "object":
      return isArray(value) ? ARRAY : OBJECT;
    default:
      return STRING;
  }
}

// src/element/lifecycle.ts
var createLifecycleMethod = (type) => {
  return (callback) => {
    if (type !== ATTACH)
      return;
    const instance = getCustomElementInstance();
    if (!instance) {
      return;
    }
    instance[type].push(callback);
  };
};
var onAttach = /* @__PURE__ */ createLifecycleMethod(ATTACH);
var onConnect = /* @__PURE__ */ createLifecycleMethod(CONNECT);

// src/element/register.ts
function registerCustomElement(definition) {
}
function registerLiteCustomElement(definition) {
}
function registerHeadlessCustomElement(definition) {
}

// src/runtime/ssr/internal.ts
function $$_ssr(template, ...parts) {
  let result = "";
  for (let i = 0; i < template.length; i++) {
    result += template[i];
    result += resolve(escape(parts[i]));
  }
  return { [SSR_TEMPLATE]: result };
}
function $$_host_element2(spreads) {
  const host = getCustomElementInstance().host.el;
  if (spreads && spreads.length > 0) {
    const spread = $$_merge_spreads(spreads);
    for (const [key, value] of spread.attributes) {
      host.setAttribute(key, value);
    }
    for (const token of spread.classList) {
      host.classList.add(token);
    }
    for (const [key, value] of spread.styles) {
      host.style.setProperty(key, value);
    }
  }
  return "";
}
function $$_custom_element(definition, props, spreads) {
  const host = new (createServerElement(definition))();
  if (spreads && spreads.length > 0) {
    const spread = $$_merge_spreads(spreads);
    for (const [key, value] of spread.attributes) {
      host.attributes.setAttribute(key, value);
    }
    for (const token of spread.classList) {
      host.classList.add(token);
    }
    for (const [key, value] of spread.styles) {
      host.style.setProperty(key, value);
    }
  }
  const hasInnerHTML = !!(props == null ? void 0 : props.innerHTML), innerHTML = hasInnerHTML ? resolve(props.innerHTML) : null, children = hasInnerHTML ? innerHTML : resolve(props == null ? void 0 : props.$children), instance = createElementInstance(definition, { props });
  host.attachComponent(instance);
  return {
    [SSR_TEMPLATE]: `<${definition.tagName}${host.attributes}>${hasInnerHTML ? children : host.render() + children}</${definition.tagName}>`
  };
}
function $$_attr2(name, value) {
  const attrValue = resolveAtrr(value);
  return isString(attrValue) ? ` ${name}="${escape(attrValue, true)}"` : "";
}
function resolveAtrr(value) {
  if (isFunction(value))
    return resolveAtrr(value());
  if (!value && value !== "" && value !== 0) {
    return null;
  } else {
    return value + "";
  }
}
function $$_classes(base, tokens) {
  let baseValue = unwrapDeep(base), result = isString(baseValue) ? baseValue : "";
  if (Object.keys(tokens).length > 0) {
    const classList = /* @__PURE__ */ new Set();
    parseClassAttr(classList, result);
    resolveClasses(classList, tokens);
    result = Array.from(classList).join(" ");
  }
  result = result.trim();
  return result.length ? ` class="${escape(result, true)}"` : "";
}
var classSplitRE = /\s+/;
function parseClassAttr(tokens, attrValue) {
  const classes = attrValue.trim().split(classSplitRE);
  for (const token of classes)
    tokens.add(token);
}
function resolveClasses(classList, tokens) {
  for (const name of Object.keys(tokens)) {
    if (unwrapDeep(tokens[name])) {
      classList.add(name);
    } else {
      classList.delete(name);
    }
  }
}
function $$_styles(base, tokens) {
  let baseValue = unwrapDeep(base), result = isString(baseValue) ? trimTrailingSemicolon(baseValue) : "";
  if (Object.keys(tokens).length > 0) {
    const styleMap = /* @__PURE__ */ new Map();
    parseStyleAttr(styleMap, result);
    resolveStyles(styleMap, tokens);
    result = "";
    for (const [name, value] of styleMap)
      result += `${name}: ${value};`;
  }
  result = result.trim();
  return result.length ? ` style="${escape(result, true)}"` : result;
}
var styleSplitRE = /\s*:\s*/;
var stylesDelimeterRE = /\s*;\s*/;
function parseStyleAttr(tokens, attrValue) {
  const styles = attrValue.trim().split(stylesDelimeterRE);
  for (let i = 0; i < styles.length; i++) {
    if (styles[i] === "")
      continue;
    const [name, value] = styles[i].split(styleSplitRE);
    tokens.set(name, value);
  }
}
function resolveStyles(tokens, styles) {
  for (const name of Object.keys(styles)) {
    const value = unwrapDeep(styles[name]);
    if (!value && value !== 0) {
      tokens.delete(name);
    } else {
      tokens.set(name, value + "");
    }
  }
}
var propNameRE = /[A-Z]/;
function $$_merge_spreads(spreads) {
  let attributes = /* @__PURE__ */ new Map(), classList = /* @__PURE__ */ new Set(), styles = /* @__PURE__ */ new Map();
  for (let i = 0; i < spreads.length; i++) {
    const { $$class, $$style, class: classBase, style: styleBase, ...attrs } = spreads[i];
    const attrNames = Object.keys(attrs);
    for (let j = 0; j < attrNames.length; j++) {
      const attrName = attrNames[j];
      if (!propNameRE.test(attrName)) {
        const attrValue = resolveAtrr(attrs[attrName]);
        if (isString(attrValue)) {
          attributes.set(attrName, attrValue);
        } else {
          attributes.delete(attrName);
        }
      }
    }
    if ("class" in spreads[i]) {
      const base = unwrapDeep(classBase);
      if (isNull(base) || base === false) {
        classList.clear();
      } else if (isString(base) && base.length) {
        parseClassAttr(classList, base + "");
      }
    }
    if ($$class)
      resolveClasses(classList, $$class);
    if ("style" in spreads[i]) {
      const base = unwrapDeep(styleBase);
      if (isNull(base) || base === false) {
        styles.clear();
      } else if (isString(base) && base.length) {
        parseStyleAttr(styles, base);
      }
    }
    if ($$style)
      resolveStyles(styles, $$style);
  }
  return { attributes, classList, styles };
}
function $$_spread2(spreads) {
  const { attributes, classList, styles } = $$_merge_spreads(spreads);
  let result = "";
  if (classList.size > 0) {
    let _class = Array.from(classList).join(" ");
    result += `class="${escape(_class.trim(), true)}"`;
  }
  for (const [name, value] of attributes) {
    result += ` ${name}="${escape(value, true)}"`;
  }
  if (styles.size > 0) {
    let _styles = "";
    for (const [name, value] of styles)
      _styles += `${name}: ${value};`;
    result += ` style="${escape(_styles.trim(), true)}"`;
  }
  return result.trim();
}
function $$_inject_html(value) {
  return injectHTML(resolve(value));
}
/**
 * The code below this comment was adapted from Lit: https://github.dev/lit/lit
 *
 * @license
 * Copyright 2019 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */

export { $$CHILDREN, $$_attach_declarative_shadow_dom, $$_attr2 as $$_attr, $$_attr as $$_attr2, $$_children, $$_class, $$_classes, $$_clone, $$_computed, $$_create_component, $$_create_element, $$_create_fragment, $$_create_template, $$_create_walker, $$_custom_element, $$_delegate_events, $$_directive, $$_effect, $$_host_element2 as $$_host_element, $$_host_element as $$_host_element2, $$_inject_html, $$_inner_html, $$_insert, $$_insert_at_marker, $$_insert_at_marker_lite, $$_insert_lite, $$_listen, $$_merge_props, $$_merge_spreads, $$_next_custom_element, $$_next_element, $$_next_template, $$_peek, $$_ref, $$_setup_custom_element, $$_spread2 as $$_spread, $$_spread as $$_spread2, $$_ssr, $$_style, $$_styles, ARRAY, BOOLEAN, FUNCTION, NUMBER, OBJECT, SSR_TEMPLATE, STRING, adoptCSS, createHTMLElement, createServerElement, css, defineCustomElement, hydrate, hydrateLite, hydration, inferAttributeType, injectCSS, injectHTML, onAttach, onConnect, parseClassAttr, parseStyleAttr, registerCustomElement, registerHeadlessCustomElement, registerLiteCustomElement, render, renderLite, renderToString, resolve, runHydration };
