'use strict';

var signals = require('@maverick-js/signals');
var map = require('@maverick-js/signals/map');

// src/runtime/accessors.ts
function createAccessors(record) {
  const accessors = {};
  for (const name of Object.keys(record)) {
    Object.defineProperty(accessors, name, {
      configurable: true,
      enumerable: true,
      get: record[name],
      set: record[name].set
    });
  }
  return accessors;
}

// src/std/unit.ts
function noop(...args) {
}
function isNull(value) {
  return value === null;
}
function isUndefined(value) {
  return typeof value === "undefined";
}
function isNil(value) {
  return isNull(value) || isUndefined(value);
}
function isObject(value) {
  return (value == null ? void 0 : value.constructor) === Object;
}
function isNumber(value) {
  return typeof value === "number" && !Number.isNaN(value);
}
function isString(value) {
  return typeof value === "string";
}
function isBoolean(value) {
  return typeof value === "boolean";
}
function isFunction(value) {
  return typeof value === "function";
}
function isArray(value) {
  return Array.isArray(value);
}
function createRegex(regex) {
  return isString(regex) ? new RegExp(regex) : regex;
}
function isWindow(value) {
  return false;
}
function createStore(initial) {
  const descriptors = Object.getOwnPropertyDescriptors(initial);
  return {
    initial,
    create: () => {
      const store = {};
      for (const name of Object.keys(initial)) {
        const $value = descriptors[name].get || signals.signal(initial[name]);
        Object.defineProperty(store, name, {
          configurable: true,
          enumerable: true,
          get: $value,
          set: $value.set
        });
      }
      return store;
    },
    reset: (record, filter) => {
      for (const name of Object.keys(record)) {
        if (!descriptors[name].get && (!filter || filter(name))) {
          record[name] = initial[name];
        }
      }
    }
  };
}

// src/runtime/reactivity.ts
var effect = noop ;

// src/runtime/components/CustomElement.ts
function CustomElement(props) {
  return null;
}

// src/std/signal.ts
function unwrap(fn) {
  return isFunction(fn) ? fn() : fn;
}
function unwrapDeep(fn) {
  let value = fn;
  while (typeof value === "function")
    value = value();
  return value;
}

// src/runtime/components/ErrorBoundary.ts
function ErrorBoundary(props) {
  const $e = signals.signal(null);
  const $error = () => $e();
  $error.handled = () => $e.set(null);
  return signals.computed(
    () => {
      const $children = unwrap(props.$children);
      signals.onError((error) => {
        var _a;
        $e.set(error);
        (_a = props.onError) == null ? void 0 : _a.call(props, error, $error.handled);
      });
      return isFunction($children) && $children.length > 0 ? signals.peek(() => $children($error)) : $children;
    },
    { initial: null }
  );
}
function For(props) {
  return map.computedMap(
    () => unwrap(props.each),
    unwrap(props.$children),
    void 0
  );
}
function ForKeyed(props) {
  return map.computedKeyedMap(
    () => unwrap(props.each),
    unwrap(props.$children),
    void 0
  );
}

// src/runtime/components/HostElement.ts
function HostElement(props) {
  return null;
}
function createContext(provide) {
  return { id: Symbol(), provide };
}
function provideContext(context, value, scope = signals.getScope()) {
  var _a;
  const hasProvidedValue = !isUndefined(value);
  signals.setContext(context.id, hasProvidedValue ? value : (_a = context.provide) == null ? void 0 : _a.call(context), scope);
}
function useContext(context) {
  const value = signals.getContext(context.id);
  return value;
}
function hasProvidedContext(context) {
  return !isUndefined(signals.getContext(context.id));
}

Object.defineProperty(exports, 'computed', {
  enumerable: true,
  get: function () { return signals.computed; }
});
Object.defineProperty(exports, 'createScope', {
  enumerable: true,
  get: function () { return signals.createScope; }
});
Object.defineProperty(exports, 'getScope', {
  enumerable: true,
  get: function () { return signals.getScope; }
});
Object.defineProperty(exports, 'isReadSignal', {
  enumerable: true,
  get: function () { return signals.isReadSignal; }
});
Object.defineProperty(exports, 'isWriteSignal', {
  enumerable: true,
  get: function () { return signals.isWriteSignal; }
});
Object.defineProperty(exports, 'onDispose', {
  enumerable: true,
  get: function () { return signals.onDispose; }
});
Object.defineProperty(exports, 'onError', {
  enumerable: true,
  get: function () { return signals.onError; }
});
Object.defineProperty(exports, 'peek', {
  enumerable: true,
  get: function () { return signals.peek; }
});
Object.defineProperty(exports, 'readonly', {
  enumerable: true,
  get: function () { return signals.readonly; }
});
Object.defineProperty(exports, 'root', {
  enumerable: true,
  get: function () { return signals.root; }
});
Object.defineProperty(exports, 'scoped', {
  enumerable: true,
  get: function () { return signals.scoped; }
});
Object.defineProperty(exports, 'signal', {
  enumerable: true,
  get: function () { return signals.signal; }
});
Object.defineProperty(exports, 'tick', {
  enumerable: true,
  get: function () { return signals.tick; }
});
Object.defineProperty(exports, 'untrack', {
  enumerable: true,
  get: function () { return signals.untrack; }
});
exports.CustomElement = CustomElement;
exports.ErrorBoundary = ErrorBoundary;
exports.For = For;
exports.ForKeyed = ForKeyed;
exports.HostElement = HostElement;
exports.createAccessors = createAccessors;
exports.createContext = createContext;
exports.createRegex = createRegex;
exports.createStore = createStore;
exports.effect = effect;
exports.hasProvidedContext = hasProvidedContext;
exports.isArray = isArray;
exports.isBoolean = isBoolean;
exports.isFunction = isFunction;
exports.isNil = isNil;
exports.isNull = isNull;
exports.isNumber = isNumber;
exports.isObject = isObject;
exports.isString = isString;
exports.isUndefined = isUndefined;
exports.isWindow = isWindow;
exports.noop = noop;
exports.provideContext = provideContext;
exports.unwrap = unwrap;
exports.unwrapDeep = unwrapDeep;
exports.useContext = useContext;
