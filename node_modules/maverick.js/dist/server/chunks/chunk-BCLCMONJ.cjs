'use strict';

var chunkAH67QMAU_cjs = require('./chunk-AH67QMAU.cjs');

// src/std/dom.ts
function isDOMNode(node) {
  return node instanceof Node;
}
function isDOMElement(node) {
  return isDOMNode(node) && node.nodeType === 1;
}
function isDOMFragment(node) {
  return isDOMNode(node) && node.nodeType === 11;
}
function createFragment() {
  return document.createDocumentFragment();
}
function createComment(data) {
  return data;
}
function setAttribute(host, name, value) {
  if (!value && value !== "" && value !== 0) {
    host.removeAttribute(name);
  } else {
    const attrValue = value + "";
    if (host.getAttribute(name) !== attrValue) {
      host.setAttribute(name, attrValue);
    }
  }
}
function setStyle(host, property, value) {
  if (!value && value !== 0) {
    host.style.removeProperty(property);
  } else {
    host.style.setProperty(property, value + "");
  }
}
function toggleClass(host, name, value) {
  host.classList[value ? "add" : "remove"](name);
}
function getSlottedChildren(el, name) {
  var _a2;
  const selector = name ? `slot[name="${name}"]` : "slot:not([name])";
  const slot = (_a2 = el.shadowRoot) == null ? void 0 : _a2.querySelector(selector);
  const childNodes = (slot == null ? void 0 : slot.assignedNodes({ flatten: true })) ?? [];
  return Array.prototype.filter.call(childNodes, (node) => node.nodeType == 1);
}
function attachDeclarativeShadowDOM(element) {
  const template = element.firstChild;
  const mode = template.getAttribute("shadowroot");
  const shadowRoot = template.parentNode.attachShadow({ mode });
  shadowRoot.appendChild(template.content);
  template.remove();
}

// src/std/fn.ts
function run(fn) {
  return fn();
}
function runAll(fns) {
  for (const fn of fns)
    fn();
}

// src/std/string.ts
function camelToKebabCase(str) {
  return str.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
}
function camelToTitleCase(str) {
  return uppercaseFirstChar(str.replace(/([A-Z])/g, " $1"));
}
function kebabToCamelCase(str) {
  return str.replace(/-./g, (x) => x[1].toUpperCase());
}
function kebabToPascalCase(str) {
  return kebabToTitleCase(str).replace(/\s/g, "");
}
function kebabToTitleCase(str) {
  return uppercaseFirstChar(str.replace(/-./g, (x) => " " + x[1].toUpperCase()));
}
function uppercaseFirstChar(str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
}
function lowercaseFirstLetter(str) {
  return str.charAt(0).toLowerCase() + str.slice(1);
}
var trailingSemicolon = /;\s*$/;
function trimTrailingSemicolon(text) {
  return text.replace(trailingSemicolon, "");
}

// src/std/array.ts
function flattenArray(array) {
  const flat = [];
  for (let i = 0; i < array.length; i++) {
    if (chunkAH67QMAU_cjs.isArray(array[i])) {
      flat.push(...flattenArray(array[i]));
    } else if (array[i] || array[i] === 0) {
      flat.push(array[i]);
    }
  }
  return flat;
}

// src/std/event.ts
var EVENT = class Event2 {
} ;
var DOM_EVENT = Symbol("DOM_EVENT");
var _a;
var DOMEvent = class extends EVENT {
  constructor(type, ...init) {
    var _a2, _b;
    super(type, init[0]);
    this[_a] = true;
    this.detail = (_a2 = init[0]) == null ? void 0 : _a2.detail;
    this.trigger = (_b = init[0]) == null ? void 0 : _b.trigger;
  }
  get originEvent() {
    return getOriginEvent(this) ?? this;
  }
  get isOriginTrusted() {
    var _a2;
    return ((_a2 = getOriginEvent(this)) == null ? void 0 : _a2.isTrusted) ?? false;
  }
};
_a = DOM_EVENT;
function createEvent(target, event, ...init) {
  return new DOMEvent(event, init[0]);
}
function dispatchEvent(target, event, ...init) {
  return false;
}
function isDOMEvent(event) {
  return !!(event == null ? void 0 : event[DOM_EVENT]);
}
function getOriginEvent(event) {
  let trigger = event.trigger;
  while (trigger && trigger.trigger) {
    trigger = trigger.trigger;
  }
  return trigger;
}
function walkTriggerEventChain(event, callback) {
  if (!isDOMEvent(event))
    return;
  let trigger = event.trigger;
  while (trigger) {
    const returnValue = callback(trigger);
    if (returnValue)
      return [trigger, returnValue];
    trigger = trigger.trigger;
  }
  return;
}
function findTriggerEvent(event, type) {
  var _a2;
  return (_a2 = walkTriggerEventChain(event, (e) => e.type === type)) == null ? void 0 : _a2[0];
}
function hasTriggerEvent(event, type) {
  return !!findTriggerEvent(event, type);
}
function appendTriggerEvent(event, trigger) {
  const origin = getOriginEvent(event) ?? event;
  if (origin === trigger) {
    throw Error(
      ""
    );
  }
  Object.defineProperty(origin, "trigger", {
    configurable: true,
    enumerable: true,
    get: () => trigger
  });
}
function listenEvent(target, type, handler, options) {
  return chunkAH67QMAU_cjs.noop;
}
function isPointerEvent(event) {
  return !!(event == null ? void 0 : event.type.startsWith("pointer"));
}
function isTouchEvent(event) {
  return !!(event == null ? void 0 : event.type.startsWith("touch"));
}
function isMouseEvent(event) {
  return /^(click|mouse)/.test((event == null ? void 0 : event.type) ?? "");
}
function isKeyboardEvent(event) {
  return !!(event == null ? void 0 : event.type.startsWith("key"));
}
function wasEnterKeyPressed(event) {
  return isKeyboardEvent(event) && event.key === "Enter";
}
function wasEscapeKeyPressed(event) {
  return isKeyboardEvent(event) && event.key === "Escape";
}
function isKeyboardClick(event) {
  return isKeyboardEvent(event) && (event.key === "Enter" || event.key === " ");
}

exports.DOMEvent = DOMEvent;
exports.appendTriggerEvent = appendTriggerEvent;
exports.attachDeclarativeShadowDOM = attachDeclarativeShadowDOM;
exports.camelToKebabCase = camelToKebabCase;
exports.camelToTitleCase = camelToTitleCase;
exports.createComment = createComment;
exports.createEvent = createEvent;
exports.createFragment = createFragment;
exports.dispatchEvent = dispatchEvent;
exports.findTriggerEvent = findTriggerEvent;
exports.flattenArray = flattenArray;
exports.getOriginEvent = getOriginEvent;
exports.getSlottedChildren = getSlottedChildren;
exports.hasTriggerEvent = hasTriggerEvent;
exports.isDOMElement = isDOMElement;
exports.isDOMEvent = isDOMEvent;
exports.isDOMFragment = isDOMFragment;
exports.isDOMNode = isDOMNode;
exports.isKeyboardClick = isKeyboardClick;
exports.isKeyboardEvent = isKeyboardEvent;
exports.isMouseEvent = isMouseEvent;
exports.isPointerEvent = isPointerEvent;
exports.isTouchEvent = isTouchEvent;
exports.kebabToCamelCase = kebabToCamelCase;
exports.kebabToPascalCase = kebabToPascalCase;
exports.kebabToTitleCase = kebabToTitleCase;
exports.listenEvent = listenEvent;
exports.lowercaseFirstLetter = lowercaseFirstLetter;
exports.run = run;
exports.runAll = runAll;
exports.setAttribute = setAttribute;
exports.setStyle = setStyle;
exports.toggleClass = toggleClass;
exports.trimTrailingSemicolon = trimTrailingSemicolon;
exports.uppercaseFirstChar = uppercaseFirstChar;
exports.walkTriggerEventChain = walkTriggerEventChain;
exports.wasEnterKeyPressed = wasEnterKeyPressed;
exports.wasEscapeKeyPressed = wasEscapeKeyPressed;
