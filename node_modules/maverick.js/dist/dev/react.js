import { $$_attach_declarative_shadow_dom, registerCustomElement, registerLiteCustomElement } from './chunks/chunk-YLIJMT4K.js';
import { kebabToPascalCase } from './chunks/chunk-JJON6UQL.js';
import { createElementInstance } from './chunks/chunk-HXFROLDL.js';
import { PROPS } from './chunks/chunk-BKACTARQ.js';
import { provideContext } from './chunks/chunk-D2IDN6VA.js';
import { getContext, createScope, tick, SCOPE } from '@maverick-js/signals';
import * as React2 from 'react';

var ReactComputeScopeContext = React2.createContext(null);
function WithScope(scope, children) {
  return React2.createElement(ReactComputeScopeContext.Provider, { value: scope }, children);
}
function useReactScope() {
  return React2.useContext(ReactComputeScopeContext);
}
function useReactContext(context) {
  const scope = useReactScope();
  return React2.useMemo(() => {
    return getContext(context.id, scope);
  }, [scope]);
}
function createReactScopeProvider() {
  return ScopeProvider;
}
function createReactContextProvider(context, provide) {
  var _a;
  return _a = class extends ScopeProvider {
  }, _a._context = context, _a._provide = provide, _a;
}
var ScopeProvider = class extends React2.Component {
  constructor(props, context) {
    super(props);
    const scope = createScope();
    this._scope = scope;
    if (context)
      context.append(scope);
    const ctor = this.constructor;
    if (ctor._context)
      provideContext(ctor._context, ctor._provide?.(), scope);
  }
  render() {
    return WithScope(this._scope, this.props?.children);
  }
};
ScopeProvider.contextType = ReactComputeScopeContext;

// src/react/utils.ts
function setRef(ref, value) {
  if (typeof ref === "function") {
    ref(value);
  } else {
    ref.current = value;
  }
}

// src/react/create-react-element.ts
function createReactElement(definition, init) {
  return createReactClientElement(registerCustomElement, definition, init);
}
function createLiteReactElement(definition, init) {
  return createReactClientElement(registerLiteCustomElement, definition, init);
}
function createReactClientElement(registerCustomElement2, definition, init) {
  registerCustomElement2(definition);
  class CustomElement extends ReactCustomElement {
  }
  CustomElement.displayName = init?.displayName ?? kebabToPascalCase(definition.tagName);
  CustomElement.contextType = ReactComputeScopeContext;
  CustomElement._definition = definition;
  CustomElement._props = new Set(Object.keys(definition.props ?? {}));
  const ForwardedComponent = React2.forwardRef(
    (props, ref) => React2.createElement(CustomElement, { ...props, __forwardedRef: ref }, props?.children)
  );
  ForwardedComponent.displayName = "ForwardRef_" + CustomElement.displayName;
  return ForwardedComponent;
}
var ReactCustomElement = class extends React2.Component {
  constructor() {
    super(...arguments);
    this._element = null;
  }
  componentDidMount() {
    if (!this._element || this._element.instance)
      return;
    $$_attach_declarative_shadow_dom(this._element);
    this._element.onEventDispatch((eventType) => {
      const callbackName = `on${kebabToPascalCase(eventType)}`;
      const callback = this.props[callbackName];
      const ctor = this.constructor;
      ctor._callbacks.set(callbackName, eventType);
      if (callback)
        this._updateEventListener(eventType, callback);
    });
    this._element.attachComponent(this._instance);
  }
  componentWillUnmount() {
    window.requestAnimationFrame(() => {
      if (!this._element)
        this._instance.destroy();
    });
  }
  render() {
    const ctor = this.constructor;
    const { __forwardedRef, className, children, ...restProps } = this.props;
    if (!this._instance) {
      this._listeners = /* @__PURE__ */ new Map();
      this._instance = createElementInstance(ctor._definition, {
        props: this.props,
        scope: this.context
      });
    }
    if (!this._ref || this._forwardedRef !== __forwardedRef) {
      this._ref = (value) => {
        this._element = value;
        if (__forwardedRef)
          setRef(__forwardedRef, value);
        this._forwardedRef = __forwardedRef;
      };
    }
    const props = { class: className, ref: this._ref };
    const $props = this._instance[PROPS];
    for (const prop of Object.keys(restProps)) {
      const value = restProps[prop];
      if (ctor._callbacks.has(prop)) {
        this._updateEventListener(ctor._callbacks.get(prop), value);
      } else if (ctor._props.has(prop)) {
        $props["$" + prop].set(value);
      } else {
        props[prop] = value;
      }
    }
    tick();
    return WithScope(
      this._instance[SCOPE],
      React2.createElement(
        ctor._definition.tagName,
        { ...props, "mk-d": true, suppressHydrationWarning: true },
        React2.createElement(ShadowRoot, {
          shadow: ctor._definition.shadowRoot
        }),
        children
      )
    );
  }
  _updateEventListener(eventType, listener) {
    let handler = this._listeners.get(eventType);
    if (!this._element || handler?.handleEvent === listener)
      return;
    if (listener) {
      if (!handler) {
        this._listeners.set(eventType, handler = { handleEvent: listener });
        this._element.addEventListener(eventType, handler);
      } else {
        handler.handleEvent = listener;
      }
    } else if (handler) {
      this._listeners.delete(eventType);
      this._element.removeEventListener(eventType, handler);
    }
  }
};
ReactCustomElement._callbacks = /* @__PURE__ */ new Map();
function ShadowRoot(props) {
  return React2.createElement(props.shadow ? "template" : "shadow-root", {
    dangerouslySetInnerHTML: { __html: "" },
    suppressHydrationWarning: true
  });
}

export { ReactComputeScopeContext, WithScope, createLiteReactElement, createReactContextProvider, createReactElement, createReactScopeProvider, useReactContext, useReactScope };
